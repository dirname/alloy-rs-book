<!DOCTYPE HTML>
<html lang="en" class="ayu" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Alloy Book</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
                <meta name="twitter:card" content="summary">
                <meta property="og:title" content="Alloy Book" />
                <meta property="og:description" content="A book on all things Alloy" />
                <meta property="og:image" content="https://raw.githubusercontent.com/alloy-rs/book/master/src/images/banner.jpg" />
        <meta name="description" content="A book on all things Alloy">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "ayu";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('ayu')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item affix "><a href="index.html">ç®€ä»‹</a></li><li class="chapter-item affix "><li class="part-title">å…¥é—¨æŒ‡å—</li><li class="chapter-item "><a href="getting-started/installation.html"><strong aria-hidden="true">1.</strong> å®‰è£…</a></li><li class="chapter-item "><a href="getting-started/first-steps.html"><strong aria-hidden="true">2.</strong> Alloy çš„ç¬¬ä¸€æ­¥</a></li><li class="chapter-item affix "><li class="part-title">ä» ethers-rs è¿ç§»</li><li class="chapter-item "><a href="migrating-from-ethers/reference.html"><strong aria-hidden="true">3.</strong> å‚è€ƒ</a></li><li class="chapter-item affix "><li class="part-title">ä½¿ç”¨ Alloy æ„å»º</li><li class="chapter-item "><a href="building-with-alloy/basic-building-blocks/index.html"><strong aria-hidden="true">4.</strong> åŸºç¡€æ„å»ºæ¨¡å—</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="building-with-alloy/basic-building-blocks/using-big-numbers.html"><strong aria-hidden="true">4.1.</strong> ä½¿ç”¨å¤§æ•°</a></li><li class="chapter-item "><a href="building-with-alloy/basic-building-blocks/basic-hash-and-address-types.html"><strong aria-hidden="true">4.2.</strong> åŸºæœ¬å“ˆå¸Œå’Œåœ°å€ç±»å‹</a></li><li class="chapter-item "><a href="building-with-alloy/basic-building-blocks/common-conversions.html"><strong aria-hidden="true">4.3.</strong> å¸¸è§è½¬æ¢</a></li><li class="chapter-item "><a href="building-with-alloy/basic-building-blocks/creating-instances.html"><strong aria-hidden="true">4.4.</strong> åˆ›å»ºå®ä¾‹</a></li><li class="chapter-item "><a href="building-with-alloy/basic-building-blocks/comparisons-and-equivalence.html"><strong aria-hidden="true">4.5.</strong> æ¯”è¾ƒä¸ç­‰ä»·</a></li></ol></li><li class="chapter-item "><a href="building-with-alloy/connecting-to-a-blockchain/index.html"><strong aria-hidden="true">5.</strong> è¿æ¥åˆ°åŒºå—é“¾</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="building-with-alloy/connecting-to-a-blockchain/setting-up-a-provider.html"><strong aria-hidden="true">5.1.</strong> è®¾ç½®æä¾›è€…</a></li><li class="chapter-item "><a href="building-with-alloy/connecting-to-a-blockchain/http-provider.html"><strong aria-hidden="true">5.2.</strong> åˆ›å»º HTTP æä¾›è€…</a></li><li class="chapter-item "><a href="building-with-alloy/connecting-to-a-blockchain/ws-provider.html"><strong aria-hidden="true">5.3.</strong> åˆ›å»º WS æä¾›è€…</a></li><li class="chapter-item "><a href="building-with-alloy/connecting-to-a-blockchain/ipc-provider.html"><strong aria-hidden="true">5.4.</strong> åˆ›å»º IPC æä¾›è€…</a></li></ol></li><li class="chapter-item "><a href="building-with-alloy/understanding-fillers.html"><strong aria-hidden="true">6.</strong> ç†è§£å¡«å……å™¨</a></li><li class="chapter-item "><a href="building-with-alloy/queries.html"><strong aria-hidden="true">7.</strong> æŸ¥è¯¢</a></li><li class="chapter-item "><a href="building-with-alloy/transactions/index.html"><strong aria-hidden="true">8.</strong> äº¤æ˜“</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="building-with-alloy/transactions/using-the-transaction-builder.html"><strong aria-hidden="true">8.1.</strong> ä½¿ç”¨äº¤æ˜“æ„å»ºå™¨</a></li><li class="chapter-item "><a href="building-with-alloy/transactions/sending-an-EIP-1559-transaction.html"><strong aria-hidden="true">8.2.</strong> å‘é€ EIP-1559 äº¤æ˜“</a></li><li class="chapter-item "><a href="building-with-alloy/transactions/sending-a-legacy-transaction.html"><strong aria-hidden="true">8.3.</strong> å‘é€ä¼ ç»Ÿäº¤æ˜“</a></li><li class="chapter-item "><a href="building-with-alloy/transactions/sending-an-EIP-4844-transaction.html"><strong aria-hidden="true">8.4.</strong> å‘é€ EIP-4844 äº¤æ˜“</a></li><li class="chapter-item "><a href="building-with-alloy/transactions/using-access-lists.html"><strong aria-hidden="true">8.5.</strong> ä½¿ç”¨è®¿é—®åˆ—è¡¨</a></li></ol></li><li class="chapter-item "><li class="part-title">äº®ç‚¹</li><li class="chapter-item "><a href="highlights/the-sol!-procedural-macro.html"><strong aria-hidden="true">9.</strong> sol! è¿‡ç¨‹å®</a></li><li class="chapter-item "><a href="highlights/the-transaction-lifecycle.html"><strong aria-hidden="true">10.</strong> äº¤æ˜“ç”Ÿå‘½å‘¨æœŸ</a></li><li class="chapter-item affix "><li class="part-title">ç¤ºä¾‹</li><li class="chapter-item "><a href="examples/anvil/index.html"><strong aria-hidden="true">11.</strong> Anvil</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="examples/anvil/deploy_contract_anvil.html"><strong aria-hidden="true">11.1.</strong> éƒ¨ç½²åˆçº¦</a></li><li class="chapter-item "><a href="examples/anvil/fork_anvil.html"><strong aria-hidden="true">11.2.</strong> åˆ†å‰</a></li><li class="chapter-item "><a href="examples/anvil/local_anvil.html"><strong aria-hidden="true">11.3.</strong> æœ¬åœ°</a></li></ol></li><li class="chapter-item "><a href="examples/big-numbers/index.html"><strong aria-hidden="true">12.</strong> å¤§æ•°</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="examples/big-numbers/comparison_equivalence.html"><strong aria-hidden="true">12.1.</strong> æ¯”è¾ƒä¸ç­‰ä»·</a></li><li class="chapter-item "><a href="examples/big-numbers/conversion.html"><strong aria-hidden="true">12.2.</strong> è½¬æ¢</a></li><li class="chapter-item "><a href="examples/big-numbers/create_instances.html"><strong aria-hidden="true">12.3.</strong> åˆ›å»ºå®ä¾‹</a></li><li class="chapter-item "><a href="examples/big-numbers/math_operations.html"><strong aria-hidden="true">12.4.</strong> æ•°å­¦è¿ç®—</a></li><li class="chapter-item "><a href="examples/big-numbers/math_utilities.html"><strong aria-hidden="true">12.5.</strong> æ•°å­¦å·¥å…·</a></li></ol></li><li class="chapter-item "><a href="examples/contracts/index.html"><strong aria-hidden="true">13.</strong> åˆçº¦</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="examples/contracts/deploy_from_artifact.html"><strong aria-hidden="true">13.1.</strong> ä»å·¥ä»¶éƒ¨ç½²</a></li><li class="chapter-item "><a href="examples/contracts/deploy_from_bytecode.html"><strong aria-hidden="true">13.2.</strong> ä»å­—èŠ‚ç éƒ¨ç½²</a></li><li class="chapter-item "><a href="examples/contracts/deploy_from_contract.html"><strong aria-hidden="true">13.3.</strong> ä»åˆçº¦éƒ¨ç½²</a></li><li class="chapter-item "><a href="examples/contracts/interact_with_abi.html"><strong aria-hidden="true">13.4.</strong> ä¸ ABI äº¤äº’</a></li><li class="chapter-item "><a href="examples/contracts/interact_with_contract_instance.html"><strong aria-hidden="true">13.5.</strong> ä¸åˆçº¦å®ä¾‹äº¤äº’</a></li><li class="chapter-item "><a href="examples/contracts/unknown_return_types.html"><strong aria-hidden="true">13.6.</strong> å¤„ç†æœªçŸ¥è¿”å›ç±»å‹</a></li></ol></li><li class="chapter-item "><a href="examples/fillers/index.html"><strong aria-hidden="true">14.</strong> å¡«å……å™¨</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="examples/fillers/gas_filler.html"><strong aria-hidden="true">14.1.</strong> Gas ä¼°è®¡å¡«å……å™¨</a></li><li class="chapter-item "><a href="examples/fillers/nonce_filler.html"><strong aria-hidden="true">14.2.</strong> Nonce ç®¡ç†å¡«å……å™¨</a></li><li class="chapter-item "><a href="examples/fillers/recommended_fillers.html"><strong aria-hidden="true">14.3.</strong> æ¨èçš„å¡«å……å™¨</a></li><li class="chapter-item "><a href="examples/fillers/wallet_filler.html"><strong aria-hidden="true">14.4.</strong> é’±åŒ…ç®¡ç†å¡«å……å™¨</a></li></ol></li><li class="chapter-item "><a href="examples/layers/index.html"><strong aria-hidden="true">15.</strong> å±‚</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="examples/layers/logging_layer.html"><strong aria-hidden="true">15.1.</strong> è¯·æ±‚/å“åº”æ—¥å¿—è®°å½•å±‚</a></li></ol></li><li class="chapter-item "><a href="examples/primitives/index.html"><strong aria-hidden="true">16.</strong> åŸºæœ¬ç±»å‹</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="examples/primitives/bytes_and_address_types.html"><strong aria-hidden="true">16.1.</strong> å­—èŠ‚å’Œåœ°å€ç±»å‹</a></li><li class="chapter-item "><a href="examples/primitives/hashing_functions.html"><strong aria-hidden="true">16.2.</strong> å“ˆå¸Œå‡½æ•°</a></li></ol></li><li class="chapter-item "><a href="examples/providers/index.html"><strong aria-hidden="true">17.</strong> æä¾›è€…</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="examples/providers/builder.html"><strong aria-hidden="true">17.1.</strong> æ„å»ºè€…</a></li><li class="chapter-item "><a href="examples/providers/builtin.html"><strong aria-hidden="true">17.2.</strong> å†…ç½®æä¾›è€…</a></li><li class="chapter-item "><a href="examples/providers/http.html"><strong aria-hidden="true">17.3.</strong> HTTP</a></li><li class="chapter-item "><a href="examples/providers/ws.html"><strong aria-hidden="true">17.4.</strong> WS</a></li><li class="chapter-item "><a href="examples/providers/ws_with_auth.html"><strong aria-hidden="true">17.5.</strong> å¸¦èº«ä»½éªŒè¯çš„ WS</a></li><li class="chapter-item "><a href="examples/providers/ipc.html"><strong aria-hidden="true">17.6.</strong> IPC</a></li></ol></li><li class="chapter-item "><a href="examples/queries/index.html"><strong aria-hidden="true">18.</strong> æŸ¥è¯¢</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="examples/queries/query_contract_storage.html"><strong aria-hidden="true">18.1.</strong> æŸ¥è¯¢åˆçº¦å­˜å‚¨</a></li><li class="chapter-item "><a href="examples/queries/query_deployed_bytecode.html"><strong aria-hidden="true">18.2.</strong> æŸ¥è¯¢åˆçº¦éƒ¨ç½²çš„å­—èŠ‚ç </a></li><li class="chapter-item "><a href="examples/queries/query_logs.html"><strong aria-hidden="true">18.3.</strong> æŸ¥è¯¢æ—¥å¿—</a></li></ol></li><li class="chapter-item "><a href="examples/sol-macro/index.html"><strong aria-hidden="true">19.</strong> sol! å®</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="examples/sol-macro/contract.html"><strong aria-hidden="true">19.1.</strong> åˆçº¦</a></li><li class="chapter-item "><a href="examples/sol-macro/decode_returns.html"><strong aria-hidden="true">19.2.</strong> è§£ç è¿”å›å€¼</a></li><li class="chapter-item "><a href="examples/sol-macro/events_errors.html"><strong aria-hidden="true">19.3.</strong> äº‹ä»¶å’Œé”™è¯¯</a></li><li class="chapter-item "><a href="examples/sol-macro/structs_enums.html"><strong aria-hidden="true">19.4.</strong> ç»“æ„ä½“å’Œæšä¸¾</a></li><li class="chapter-item "><a href="examples/sol-macro/user_defined_types.html"><strong aria-hidden="true">19.5.</strong> ç”¨æˆ·å®šä¹‰çš„ç±»å‹</a></li></ol></li><li class="chapter-item "><a href="examples/subscriptions/index.html"><strong aria-hidden="true">20.</strong> è®¢é˜…</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="examples/subscriptions/poll_logs.html"><strong aria-hidden="true">20.1.</strong> ç›‘è§†å’Œè½®è¯¢åˆçº¦äº‹ä»¶æ—¥å¿—</a></li><li class="chapter-item "><a href="examples/subscriptions/subscribe_blocks.html"><strong aria-hidden="true">20.2.</strong> è®¢é˜…å’Œç›‘è§†åŒºå—</a></li><li class="chapter-item "><a href="examples/subscriptions/subscribe_logs.html"><strong aria-hidden="true">20.3.</strong> è®¢é˜…å’Œç›‘å¬ç‰¹å®šåˆçº¦äº‹ä»¶æ—¥å¿—</a></li><li class="chapter-item "><a href="examples/subscriptions/subscribe_all_logs.html"><strong aria-hidden="true">20.4.</strong> è®¢é˜…å’Œç›‘å¬æ‰€æœ‰åˆçº¦äº‹ä»¶æ—¥å¿—</a></li><li class="chapter-item "><a href="examples/subscriptions/subscribe_pending_transactions.html"><strong aria-hidden="true">20.5.</strong> è®¢é˜…å¹¶ç›‘å¬å…¬å…±è®°å¿†æ± ä¸­çš„å¾…å¤„ç†äº¤æ˜“</a></li><li class="chapter-item "><a href="examples/subscriptions/event_multiplexer.html"><strong aria-hidden="true">20.6.</strong> äº‹ä»¶å¤šè·¯å¤ç”¨å™¨</a></li></ol></li><li class="chapter-item "><a href="examples/transactions/index.html"><strong aria-hidden="true">21.</strong> äº¤æ˜“</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="examples/transactions/decode_input.html"><strong aria-hidden="true">21.1.</strong> è§£ç è¾“å…¥</a></li><li class="chapter-item "><a href="examples/transactions/encode_decode_eip1559.html"><strong aria-hidden="true">21.2.</strong> ç¼–ç å’Œè§£ç  EIP-1559 äº¤æ˜“</a></li><li class="chapter-item "><a href="examples/transactions/gas_price_usd.html"><strong aria-hidden="true">21.3.</strong> è·å–ä»¥ç¾å…ƒè®¡çš„ Gas ä»·æ ¼</a></li><li class="chapter-item "><a href="examples/transactions/trace_call.html"><strong aria-hidden="true">21.4.</strong> è·Ÿè¸ªè°ƒç”¨</a></li><li class="chapter-item "><a href="examples/transactions/trace_transaction.html"><strong aria-hidden="true">21.5.</strong> è·Ÿè¸ªäº¤æ˜“</a></li><li class="chapter-item "><a href="examples/transactions/transfer_erc20.html"><strong aria-hidden="true">21.6.</strong> è½¬è´¦ ERC20 ä»£å¸</a></li><li class="chapter-item "><a href="examples/transactions/transfer_eth.html"><strong aria-hidden="true">21.7.</strong> è½¬è´¦ ETH</a></li><li class="chapter-item "><a href="examples/transactions/send_raw_transaction.html"><strong aria-hidden="true">21.8.</strong> ç­¾åå¹¶å‘é€åŸå§‹äº¤æ˜“</a></li><li class="chapter-item "><a href="examples/transactions/with_access_list.html"><strong aria-hidden="true">21.9.</strong> å‘é€å¸¦è®¿é—®åˆ—è¡¨çš„äº¤æ˜“</a></li><li class="chapter-item "><a href="examples/transactions/send_eip1559_transaction.html"><strong aria-hidden="true">21.10.</strong> å‘é€ EIP-1559 äº¤æ˜“</a></li><li class="chapter-item "><a href="examples/transactions/send_legacy_transaction.html"><strong aria-hidden="true">21.11.</strong> å‘é€ä¼ ç»Ÿäº¤æ˜“</a></li><li class="chapter-item "><a href="examples/transactions/send_eip4844_transaction.html"><strong aria-hidden="true">21.12.</strong> å‘é€ EIP-4844 äº¤æ˜“</a></li><li class="chapter-item "><a href="examples/transactions/send_private_transaction.html"><strong aria-hidden="true">21.13.</strong> ä½¿ç”¨ Flashbots Protect å‘é€ç§å¯†äº¤æ˜“</a></li></ol></li><li class="chapter-item "><a href="examples/wallets/index.html"><strong aria-hidden="true">22.</strong> é’±åŒ…</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="examples/wallets/aws_signer.html"><strong aria-hidden="true">22.1.</strong> AWS ç­¾åå™¨</a></li><li class="chapter-item "><a href="examples/wallets/ledger_signer.html"><strong aria-hidden="true">22.2.</strong> Ledger ç­¾åå™¨</a></li><li class="chapter-item "><a href="examples/wallets/private_key_signer.html"><strong aria-hidden="true">22.3.</strong> ç§é’¥ç­¾åå™¨</a></li><li class="chapter-item "><a href="examples/wallets/mnemonic_signer.html"><strong aria-hidden="true">22.4.</strong> åŠ©è®°è¯ç­¾åå™¨</a></li><li class="chapter-item "><a href="examples/wallets/sign_message.html"><strong aria-hidden="true">22.5.</strong> ç­¾åæ¶ˆæ¯</a></li><li class="chapter-item "><a href="examples/wallets/verify_message.html"><strong aria-hidden="true">22.6.</strong> éªŒè¯æ¶ˆæ¯</a></li><li class="chapter-item "><a href="examples/wallets/sign_permit_hash.html"><strong aria-hidden="true">22.7.</strong> ç­¾åè®¸å¯å“ˆå¸Œ</a></li><li class="chapter-item "><a href="examples/wallets/trezor_signer.html"><strong aria-hidden="true">22.8.</strong> Trezor ç­¾åå™¨</a></li><li class="chapter-item "><a href="examples/wallets/yubi_signer.html"><strong aria-hidden="true">22.9.</strong> Yubi ç­¾åå™¨</a></li><li class="chapter-item "><a href="examples/wallets/keystore_signer.html"><strong aria-hidden="true">22.10.</strong> å¯†é’¥åº“ç­¾åå™¨</a></li><li class="chapter-item "><a href="examples/wallets/create_keystore.html"><strong aria-hidden="true">22.11.</strong> åˆ›å»ºå¯†é’¥åº“</a></li></ol></li><li class="chapter-item "><a href="examples/advanced/index.html"><strong aria-hidden="true">23.</strong> é«˜çº§</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="examples/advanced/any_network.html"><strong aria-hidden="true">23.1.</strong> ä½¿ç”¨ AnyNetwork</a></li></ol></li><li class="chapter-item "><li class="part-title">é™„å½•</li><li class="chapter-item "><a href="appendix/contributing.html"><strong aria-hidden="true">24.</strong> å¸®åŠ©æˆ‘ä»¬æ”¹è¿› Alloy</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Alloy Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/alloy-rs/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <img src="images/banner.jpg">
<p>Welcome to the hands-on guide for getting started with Alloy!</p>
<p>Alloy connects applications to blockchains.</p>
<p>Alloy is a high performance rewrite of <a href="https://github.com/gakonst/ethers-rs" title="" target="_blank">
<code>ethers-rs</code></a> from the ground up with exciting new
features.</p>
<blockquote>
<p>ğŸ“– <strong>Documentation</strong></p>
<p>You can find the official documentation for <code>alloy</code> <a href="https://docs.rs/alloy/latest/alloy/" title="" target="_blank">here</a> and for <code>alloy-core</code> <a href="https://docs.rs/alloy-core/latest/alloy_core/" title="" target="_blank">here</a>.</p>
</blockquote>
<blockquote>
<p>âœ¨ <strong>Contributing</strong></p>
<p>You can contribute to this book on <a href="https://github.com/alloy-rs/book" title="" target="_blank">GitHub</a>.</p>
</blockquote>
<h2 id="sections"><a class="header" href="#sections">Sections</a></h2>
<h3 id="getting-started"><a class="header" href="#getting-started"><a href="./getting-started/installation.html">Getting Started</a></a></h3>
<p>To get started with Alloy, install Alloy and take your first steps.</p>
<h3 id="migrating-from-ethers"><a class="header" href="#migrating-from-ethers"><a href="./migrating-from-ethers/reference.html">Migrating from Ethers</a></a></h3>
<p>A practical guide to migrate from Ethers to Alloy.</p>
<h3 id="building-with-alloy"><a class="header" href="#building-with-alloy"><a href="./building-with-alloy/basic-building-blocks/using-big-numbers.html">Building with Alloy</a></a></h3>
<p>A walkthrough of building with Alloy.</p>
<h3 id="highlights"><a class="header" href="#highlights"><a href="./highlights/the-sol!-procedural-macro.html">Highlights</a></a></h3>
<p>Highlighted features of Alloy.</p>
<h3 id="examples"><a class="header" href="#examples"><a href="./examples/anvil/deploy_contract_anvil.html">Examples</a></a></h3>
<p>This section will give you practical examples of how Alloy can be used in your codebase.</p>
<h3 id="contributing"><a class="header" href="#contributing"><a href="./appendix/contributing.html">Contributing</a></a></h3>
<p>Thanks for your help improving the project! We are so happy to have you! We have
<a href="https://github.com/alloy-rs/book/tree/main/CONTRIBUTING.md" title="" target="_blank">a contributing guide</a> to help you get involved in the
Alloy project.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="å®‰è£…"><a class="header" href="#å®‰è£…">å®‰è£…</a></h2>
<p><a href="https://github.com/alloy-rs/alloy" title="" target="_blank">Alloy</a> åŒ…å«å¤šä¸ª crateï¼Œè¿™äº› crate æä¾›äº†ä¸ä»»ä½•åŸºäºä»¥å¤ªåŠçš„åŒºå—é“¾äº¤äº’æ‰€éœ€çš„å„ç§åŠŸèƒ½ã€‚</p>
<p>æœ€ç®€å•çš„å…¥é—¨æ–¹å¼æ˜¯ä½¿ç”¨ Cargo ä»å‘½ä»¤è¡Œæ·»åŠ å¸¦æœ‰ <code>full</code> åŠŸèƒ½æ ‡å¿—çš„ <code>alloy</code> crateï¼š</p>
<pre><code class="language-sh">cargo add alloy --features full
</code></pre>
<p>æˆ–è€…ï¼Œä½ å¯ä»¥åœ¨ä½ çš„ <code>Cargo.toml</code> æ–‡ä»¶ä¸­æ·»åŠ ä»¥ä¸‹å†…å®¹ï¼š</p>
<pre><code class="language-toml">alloy = { version = "0.1", features = ["full"] }
</code></pre>
<p>å¦‚æœä½ éœ€è¦æ›´ç»†ç²’åº¦çš„æ§åˆ¶æ‰€åŒ…å«çš„åŠŸèƒ½ï¼Œå¯ä»¥åœ¨ <code>Cargo.toml</code> æ–‡ä»¶ä¸­æ·»åŠ å„ä¸ªç‹¬ç«‹çš„ crateï¼Œæˆ–è€…ä½¿ç”¨å¸¦æœ‰æ‰€éœ€åŠŸèƒ½çš„ <code>alloy</code> crateã€‚</p>
<p>åœ¨ <code>alloy</code> è¢«æ·»åŠ ä¸ºä¾èµ–é¡¹åï¼Œä½ å¯ä»¥æŒ‰å¦‚ä¸‹æ–¹å¼å¯¼å…¥ <code>alloy</code>ï¼š</p>
<pre><code class="language-rust ignore">use alloy::{
    network::{eip2718::Encodable2718, EthereumWallet, TransactionBuilder},
    primitives::U256,
    providers::{Provider, ProviderBuilder},
    rpc::types::TransactionRequest,
    signers::local::PrivateKeySigner,
};</code></pre>
<h3 id="åŠŸèƒ½"><a class="header" href="#åŠŸèƒ½">åŠŸèƒ½</a></h3>
<a href="https://github.com/alloy-rs/alloy/tree/main/crates/alloy" title="" target="_blank">
`alloy`</a> meta-crate å®šä¹‰äº†è®¸å¤š <a href="https://github.com/alloy-rs/alloy/blob/main/crates/alloy/Cargo.toml" title="" target="_blank">åŠŸèƒ½æ ‡å¿—</a>ï¼š
<p>é»˜è®¤</p>
<ul>
<li><code>std</code></li>
<li><code>reqwest</code></li>
</ul>
<p>å…¨åŠŸèƒ½ï¼ŒåŒ…å«æœ€å¸¸ç”¨çš„æ ‡å¿—ï¼Œé€‚åˆå…¥é—¨ä½¿ç”¨ <code>alloy</code>ã€‚</p>
<ul>
<li><code>full</code></li>
</ul>
<p>é€šç”¨åŠŸèƒ½</p>
<ul>
<li><code>consensus</code></li>
<li><code>contract</code></li>
<li><code>eips</code></li>
<li><code>genesis</code></li>
<li><code>network</code></li>
<li><code>node-bindings</code></li>
</ul>
<p>æä¾›è€…</p>
<ul>
<li><code>providers</code></li>
<li><code>provider-http</code></li>
<li><code>provider-ipc</code></li>
<li><code>provider-ws</code></li>
</ul>
<p>RPC</p>
<ul>
<li><code>rpc</code></li>
<li><code>json-rpc</code></li>
<li><code>rpc-client</code></li>
<li><code>rpc-client-ipc</code></li>
<li><code>rpc-client-ws</code></li>
<li><code>rpc-types</code></li>
<li><code>rpc-types-admin</code></li>
<li><code>rpc-types-anvil</code></li>
<li><code>rpc-types-beacon</code></li>
<li><code>rpc-types-debug</code></li>
<li><code>rpc-types-engine</code></li>
<li><code>rpc-types-eth</code></li>
<li><code>rpc-types-json</code></li>
<li><code>rpc-types-trace</code></li>
<li><code>rpc-types-txpool</code></li>
</ul>
<p>ç­¾åè€…</p>
<ul>
<li><code>signers</code></li>
<li><code>signer-aws</code></li>
<li><code>signer-gcp</code></li>
<li><code>signer-ledger</code></li>
<li><code>signer-ledger-browser</code></li>
<li><code>signer-ledger-node</code></li>
<li><code>signer-local</code></li>
<li><code>signer-trezor</code></li>
<li><code>signer-keystore</code></li>
<li><code>signer-mnemonic</code></li>
<li><code>signer-mnemonic-all-languages</code></li>
<li><code>signer-yubihsm</code></li>
</ul>
<p>é»˜è®¤æƒ…å†µä¸‹ï¼Œ<code>alloy</code> ä½¿ç”¨ <a href="https://crates.io/crates/reqwest" title="" target="_blank">
<code>reqwest</code></a> ä½œä¸º HTTP å®¢æˆ·ç«¯ã€‚ä½ ä¹Ÿå¯ä»¥é€‰æ‹©åˆ‡æ¢åˆ° <a href="https://crates.io/crates/hyper" title="" target="_blank">
<code>hyper</code></a>ã€‚
<code>reqwest</code> å’Œ <code>hyper</code> åŠŸèƒ½æ ‡å¿—æ˜¯äº’æ–¥çš„ã€‚</p>
<p>å®Œæ•´çš„å¯ç”¨åŠŸèƒ½åˆ—è¡¨å¯ä»¥åœ¨ <a href="https://docs.rs/crate/alloy/latest/features" title="" target="_blank">docs.rs</a> æˆ–è€… <a href="https://github.com/alloy-rs/alloy/blob/main/crates/alloy/Cargo.toml" title="" target="_blank">
<code>alloy</code> crate çš„ <code>Cargo.toml</code></a> ä¸­æ‰¾åˆ°ã€‚</p>
<p>è¿™äº›åŠŸèƒ½æ ‡å¿—å¤§éƒ¨åˆ†ä¸ä»¥ä¸‹ç‹¬ç«‹ crate çš„åŠŸèƒ½ç›¸å¯¹åº”ï¼Œå¹¶å¯ç”¨è¿™äº›åŠŸèƒ½ã€‚</p>
<h3 id="crate"><a class="header" href="#crate">Crate</a></h3>
<p><code>alloy</code> åŒ…å«ä»¥ä¸‹ crateï¼š</p>
<ul>
<li><a href="https://github.com/alloy-rs/alloy/tree/main/crates/alloy" title="" target="_blank">alloy</a> - æ•´ä¸ªé¡¹ç›®çš„ meta-crateï¼ŒåŒ…æ‹¬ <a href="https://docs.rs/alloy-core" title="" target="_blank">
<code>alloy-core</code></a></li>
<li><a href="https://github.com/alloy-rs/alloy/tree/main/crates/consensus" title="" target="_blank">alloy-consensus</a> - ä»¥å¤ªåŠå…±è¯†æ¥å£</li>
<li><a href="https://github.com/alloy-rs/alloy/tree/main/crates/contract" title="" target="_blank">alloy-contract</a> - ä¸é“¾ä¸Šåˆçº¦äº¤äº’</li>
<li><a href="https://github.com/alloy-rs/alloy/tree/main/crates/eips" title="" target="_blank">alloy-eips</a> - ä»¥å¤ªåŠæ”¹è¿›ææ¡ˆ (EIP) å®ç°</li>
<li><a href="https://github.com/alloy-rs/alloy/tree/main/crates/genesis" title="" target="_blank">alloy-genesis</a> - ä»¥å¤ªåŠåˆ›ä¸–æ–‡ä»¶å®šä¹‰</li>
<li><a href="https://github.com/alloy-rs/alloy/tree/main/crates/json-rpc" title="" target="_blank">alloy-json-rpc</a> - JSON-RPC 2.0 å®¢æˆ·ç«¯çš„æ ¸å¿ƒæ•°æ®ç±»å‹</li>
<li><a href="https://github.com/alloy-rs/alloy/tree/main/crates/network" title="" target="_blank">alloy-network</a> - RPC ç±»å‹çš„ç½‘ç»œæŠ½è±¡</li>
<li><a href="https://github.com/alloy-rs/alloy/tree/main/crates/node-bindings" title="" target="_blank">alloy-node-bindings</a> - ä»¥å¤ªåŠæ‰§è¡Œå±‚å®¢æˆ·ç«¯ç»‘å®š</li>
<li><a href="https://github.com/alloy-rs/alloy/tree/main/crates/provider" title="" target="_blank">alloy-provider</a> - ä¸ä»¥å¤ªåŠåŒºå—é“¾æ¥å£</li>
<li><a href="https://github.com/alloy-rs/alloy/tree/main/crates/pubsub" title="" target="_blank">alloy-pubsub</a> - ä»¥å¤ªåŠ JSON-RPC <a href="https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern" title="" target="_blank">å‘å¸ƒ-è®¢é˜…</a> tower æœåŠ¡å’Œç±»å‹å®šä¹‰</li>
<li><a href="https://github.com/alloy-rs/alloy/tree/main/crates/rpc-client" title="" target="_blank">alloy-rpc-client</a> - ä½çº§ä»¥å¤ªåŠ JSON-RPC å®¢æˆ·ç«¯å®ç°</li>
<li><a href="https://github.com/alloy-rs/alloy/tree/main/crates/rpc-types" title="" target="_blank">alloy-rpc-types</a> - æ‰€æœ‰ä»¥å¤ªåŠ JSON-RPC ç±»å‹çš„ meta-crate
<ul>
<li><a href="https://github.com/alloy-rs/alloy/tree/main/crates/rpc-types-admin" title="" target="_blank">alloy-rpc-types-admin</a> - <code>admin</code> ä»¥å¤ªåŠ JSON-RPC å‘½åç©ºé—´çš„ç±»å‹</li>
<li><a href="https://github.com/alloy-rs/alloy/tree/main/crates/rpc-types-anvil" title="" target="_blank">alloy-rpc-types-anvil</a> - <a href="https://github.com/foundry-rs/foundry" title="" target="_blank">Anvil</a> å¼€å‘èŠ‚ç‚¹çš„ä»¥å¤ªåŠ JSON-RPC å‘½åç©ºé—´çš„ç±»å‹</li>
<li><a href="https://github.com/alloy-rs/alloy/tree/main/crates/rpc-types-beacon" title="" target="_blank">alloy-rpc-types-beacon</a> - <a href="https://ethereum.github.io/beacon-APIs" title="" target="_blank">ä»¥å¤ªåŠä¿¡æ ‡èŠ‚ç‚¹ API</a> ç±»å‹</li>
<li><a href="https://github.com/alloy-rs/alloy/tree/main/crates/rpc-types-engine" title="" target="_blank">alloy-rpc-types-engine</a> - <code>engine</code> ä»¥å¤ªåŠ JSON-RPC å‘½åç©ºé—´çš„ç±»å‹</li>
<li><a href="https://github.com/alloy-rs/alloy/tree/main/crates/rpc-types-eth" title="" target="_blank">alloy-rpc-types-eth</a> - <code>eth</code> ä»¥å¤ªåŠ JSON-RPC å‘½åç©ºé—´çš„ç±»å‹</li>
<li><a href="https://github.com/alloy-rs/alloy/tree/main/crates/rpc-types-trace" title="" target="_blank">alloy-rpc-types-trace</a> - <code>trace</code> ä»¥å¤ªåŠ JSON-RPC å‘½åç©ºé—´çš„ç±»å‹</li>
<li><a href="https://github.com/alloy-rs/alloy/tree/main/crates/rpc-types-txpool" title="" target="_blank">alloy-rpc-types-txpool</a> - <code>txpool</code> ä»¥å¤ªåŠ JSON-RPC å‘½åç©ºé—´çš„ç±»å‹</li>
</ul>
</li>
<li><a href="https://github.com/alloy-rs/alloy/tree/main/crates/serde" title="" target="_blank">alloy-serde</a> - <a href="https://serde.rs" title="" target="_blank">Serde</a> ç›¸å…³å®ç”¨å·¥å…·</li>
<li><a href="https://github.com/alloy-rs/alloy/tree/main/crates/signer" title="" target="_blank">alloy-signer</a> - ä»¥å¤ªåŠç­¾åè€…æŠ½è±¡
<ul>
<li><a href="https://github.com/alloy-rs/alloy/tree/main/crates/signer-aws" title="" target="_blank">alloy-signer-aws</a> - <a href="https://aws.amazon.com/kms" title="" target="_blank">AWS KMS</a> ç­¾åå®ç°</li>
<li><a href="https://github.com/alloy-rs/alloy/tree/main/crates/signer-gcp" title="" target="_blank">alloy-signer-gcp</a> - <a href="https://cloud.google.com/kms" title="" target="_blank">GCP KMS</a> ç­¾åå®ç°</li>
<li><a href="https://github.com/alloy-rs/alloy/tree/main/crates/signer-ledger" title="" target="_blank">alloy-signer-ledger</a> - <a href="https://www.ledger.com" title="" target="_blank">Ledger</a> ç­¾åå®ç°</li>
<li><a href="https://github.com/alloy-rs/alloy/tree/main/crates/signer-local" title="" target="_blank">alloy-signer-local</a> - æœ¬åœ°ï¼ˆç§é’¥ï¼Œå¯†é’¥åº“ï¼ŒåŠ©è®°è¯ï¼ŒYubiHSMï¼‰ç­¾åå®ç°</li>
<li><a href="https://github.com/alloy-rs/alloy/tree/main/crates/signer-trezor" title="" target="_blank">alloy-signer-trezor</a> - <a href="https://trezor.io" title="" target="_blank">Trezor</a> ç­¾åå®ç°</li>
</ul>
</li>
<li><a href="https://github.com/alloy-rs/alloy/tree/main/crates/transport" title="" target="_blank">alloy-transport</a> - ä½çº§ä»¥å¤ªåŠ JSON-RPC ä¼ è¾“æŠ½è±¡
<ul>
<li><a href="https://github.com/alloy-rs/alloy/tree/main/crates/transport-http" title="" target="_blank">alloy-transport-http</a> - HTTP ä¼ è¾“å®ç°</li>
<li><a href="https://github.com/alloy-rs/alloy/tree/main/crates/transport-ipc" title="" target="_blank">alloy-transport-ipc</a> - IPC ä¼ è¾“å®ç°</li>
<li><a href="https://github.com/alloy-rs/alloy/tree/main/crates/transport-ws" title="" target="_blank">alloy-transport-ws</a> - WS ä¼ è¾“å®ç°</li>
</ul>
</li>
</ul>
<p><code>alloy-core</code> åŒ…å«ä»¥ä¸‹ crateï¼š</p>
<ul>
<li><a href="https://github.com/alloy-rs/core/tree/main/crates/core" title="" target="_blank">alloy-core</a> - æ•´ä¸ªé¡¹ç›®çš„ meta-crate</li>
<li><a href="https://github.com/alloy-rs/core/tree/main/crates/dyn-abi" title="" target="_blank">alloy-dyn-abi</a> - è¿è¡Œæ—¶ <a href="https://docs.soliditylang.org/en/latest/abi-spec.html" title="" target="_blank">ABI</a> å’Œ <a href="https://eips.ethereum.org/EIPS/eip-712" title="" target="_blank">EIP-712</a> å®ç°</li>
<li><a href="https://github.com/alloy-rs/core/tree/main/crates/json-abi" title="" target="_blank">alloy-json-abi</a> - å…¨é¢çš„ä»¥å¤ªåŠ <a href="https://docs.soliditylang.org/en/latest/abi-spec.html#json" title="" target="_blank">JSON-ABI</a> å®ç°</li>
<li><a href="https://github.com/alloy-rs/core/tree/main/crates/primitives" title="" target="_blank">alloy-primitives</a> - åŸºæœ¬çš„æ•´æ•°å’Œå­—èŠ‚ç±»å‹</li>
<li><a href="https://github.com/alloy-rs/core/tree/main/crates/sol-macro-expander" title="" target="_blank">alloy-sol-macro-expander</a> - ç”¨äº Solidity åˆ° Rust è¿‡ç¨‹å®çš„æ‰©å±•å™¨</li>
<li><a href="https://github.com/alloy-rs/core/tree/main/crates/sol-macro-input" title="" target="_blank">alloy-sol-macro-input</a> - <a href="https://docs.rs/alloy-sol-macro/latest/alloy_sol_macro/macro.sol.html" title="" target="_blank">
<code>sol!</code></a> å®ç±»å‹çš„è¾“å…¥ç±»å‹</li>
<li><a href="https://github.com/alloy-rs/core/tree/main/crates/sol-macro" title="" target="_blank">alloy-sol-macro</a> - <a href="https://docs.rs/alloy-sol-macro/latest/alloy_sol_macro/macro.sol.html" title="" target="_blank">
<code>sol!</code></a> è¿‡ç¨‹å®</li>
<li><a href="https://github.com/alloy-rs/core/tree/main/crates/sol-type-parser" title="" target="_blank">alloy-sol-type-parser</a> - Solidity ç±»å‹å­—ç¬¦ä¸²çš„ç®€å•è§£æå™¨</li>
<li><a href="https://github.com/alloy-rs/core/tree/main/crates/sol-types" title="" target="_blank">alloy-sol-types</a> - ç¼–è¯‘æ—¶ <a href="https://docs.soliditylang.org/en/latest/abi-spec.html" title="" target="_blank">ABI</a> å’Œ <a href="https://eips.ethereum.org/EIPS/eip-712" title="" target="_blank">EIP-712</a> å®ç°</li>
<li><a href="https://github.com/alloy-rs/core/tree/main/crates/syn-solidity" title="" target="_blank">syn-solidity</a> - <a href="https://github.com/dtolnay/syn" title="" target="_blank">
<code>syn</code></a>-é©±åŠ¨çš„ Solidity è§£æå™¨</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="èµ·æ­¥"><a class="header" href="#èµ·æ­¥">èµ·æ­¥</a></h2>
<p>Alloy å…è®¸åº”ç”¨ç¨‹åºé€šè¿‡ä½¿ç”¨æä¾›è€…ï¼ˆprovidersï¼‰æ¥è¿æ¥åŒºå—é“¾ã€‚æä¾›è€…å……å½“åº”ç”¨ç¨‹åºå’Œä»¥å¤ªåŠèŠ‚ç‚¹ä¹‹é—´çš„æ¥å£ï¼Œä½¿æ‚¨èƒ½å¤Ÿé€šè¿‡ JSON-RPC æ¶ˆæ¯å‘é€è¯·æ±‚å’Œæ¥æ”¶å“åº”ã€‚</p>
<p>ä½¿ç”¨æä¾›è€…å¯ä»¥æ‰§è¡Œçš„ä¸€äº›å¸¸è§æ“ä½œåŒ…æ‹¬ï¼š</p>
<ul>
<li>è·å–å½“å‰åŒºå—å·</li>
<li>è·å–ä»¥å¤ªåŠåœ°å€çš„ä½™é¢</li>
<li>å‘åŒºå—é“¾å‘é€äº¤æ˜“</li>
<li>è°ƒç”¨æ™ºèƒ½åˆçº¦å‡½æ•°</li>
<li>è®¢é˜…æ—¥å¿—å’Œæ™ºèƒ½åˆçº¦äº‹ä»¶</li>
<li>è·å–åœ°å€çš„äº¤æ˜“å†å²è®°å½•</li>
</ul>
<p>åœ¨<a href="getting-started/./installation.html">å®‰è£…</a>äº† <code>alloy</code> ä¹‹åï¼Œè®©æˆ‘ä»¬åˆ›å»ºä¸€ä¸ªä½¿ç”¨ HTTP æä¾›è€…å¹¶è·å–æœ€æ–°åŒºå—å·çš„ç¤ºä¾‹ã€‚</p>
<p>å®‰è£… <a href="https://crates.io/crates/tokio" title="" target="_blank">
<code>tokio</code></a> å’Œ <a href="https://crates.io/crates/eyre" title="" target="_blank">
<code>eyre</code></a> ä½œä¸ºä¾èµ–é¡¹ï¼Œå¹¶æŒ‰å¦‚ä¸‹å®šä¹‰ä¸»ä½“ï¼š</p>
<pre><code class="language-rust ignore">//! ä½¿ç”¨ `ProviderBuilder` çš„ `on_http` æ–¹æ³•åˆ›å»º HTTP æä¾›è€…çš„ç¤ºä¾‹ã€‚

use alloy::providers::{Provider, ProviderBuilder};
use eyre::Result;

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    // ...

    Ok(())
}</code></pre>
<p>æ¥ä¸‹æ¥ï¼Œå‘ä¸»ä½“ä¸­æ·»åŠ ä»¥ä¸‹éƒ¨åˆ†ï¼Œä»¥ä½¿ç”¨ HTTP ä¼ è¾“åˆ›å»ºæä¾›è€…ï¼š</p>
<pre><code class="language-rust ignore">// è®¾ç½®ç”± RPC å®¢æˆ·ç«¯ä½¿ç”¨çš„ HTTP ä¼ è¾“ã€‚
let rpc_url = "https://eth.merkle.io".parse()?;

// ä½¿ç”¨ `reqwest` crate åˆ›å»ºå¸¦æœ‰ HTTP ä¼ è¾“çš„æä¾›è€…ã€‚
let provider = ProviderBuilder::new().on_http(rpc_url);</code></pre>
<p>æœ€åï¼Œæˆ‘ä»¬ä½¿ç”¨æä¾›è€…è·å–æœ€æ–°çš„åŒºå—å·ï¼š</p>
<pre><code class="language-rust ignore">// è·å–æœ€æ–°åŒºå—å·ã€‚
let latest_block = provider.get_block_number().await?;

// æ‰“å°åŒºå—å·ã€‚
println!("Latest block number: {latest_block}");</code></pre>
<p>å¯ä»¥åœ¨<a href="https://github.com/alloy-rs/examples/blob/main/examples/providers/examples/http.rs" title="" target="_blank">è¿™é‡Œ</a>æ‰¾åˆ°å®Œæ•´ä¸”å¯è¿è¡Œçš„ç¤ºä¾‹ï¼Œè¿™æ˜¯<a href="https://github.com/alloy-rs/examples/blob/main/README.md#overview" title="" target="_blank">è®¸å¤š Alloy å¯è¿è¡Œç¤ºä¾‹</a>ä¸­çš„ä¸€ä¸ªï¼Œä¾›æ‚¨æ¢ç´¢ã€‚</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="å‚è€ƒ"><a class="header" href="#å‚è€ƒ">å‚è€ƒ</a></h2>
<p><a href="https://github.com/gakonst/ethers-rs/" title="" target="_blank">ethers-rs</a> å·²ç»è¢«å¼ƒç”¨ï¼Œè¿ç§»è‡³ <a href="https://github.com/alloy-rs/" title="" target="_blank">Alloy</a> å’Œ <a href="https://github.com/foundry-rs/" title="" target="_blank">Foundry</a>ã€‚</p>
<p>ä»¥ä¸‹æ˜¯æ‰¾åˆ°ç‰¹å®š crateã€ä¾èµ–æˆ–ä¿¡æ¯æºçš„è¿ç§»è·¯å¾„çš„å‚è€ƒæŒ‡å—ã€‚</p>
<h3 id="æ–‡æ¡£"><a class="header" href="#æ–‡æ¡£">æ–‡æ¡£</a></h3>
<ul>
<li>ä¹¦ç±: <a href="https://github.com/gakonst/ethers-rs/tree/master/book" title="" target="_blank">
<code>ethers-rs/book</code></a> <code>-&gt;</code> <a href="https://github.com/alloy-rs/book" title="" target="_blank">
<code>alloy-rs/book</code></a></li>
</ul>
<h3 id="ç¤ºä¾‹"><a class="header" href="#ç¤ºä¾‹">ç¤ºä¾‹</a></h3>
<ul>
<li>ç¤ºä¾‹: <a href="https://github.com/gakonst/ethers-rs/tree/master/examples" title="" target="_blank">
<code>ethers-rs/examples</code></a> <code>-&gt;</code> <a href="https://github.com/alloy-rs/examples" title="" target="_blank">
<code>alloy-rs/examples</code></a></li>
</ul>
<h3 id="crates"><a class="header" href="#crates">Crates</a></h3>
<ul>
<li>
<p>Meta-crate: <a href="https://github.com/gakonst/ethers-rs/tree/master/ethers" title="" target="_blank">
<code>ethers</code></a> <code>-&gt;</code> <a href="https://github.com/alloy-rs/alloy/tree/main/crates/alloy" title="" target="_blank">
<code>alloy</code></a></p>
</li>
<li>
<p>åœ°å€ç°¿: <a href="https://github.com/gakonst/ethers-rs/tree/master/ethers-addressbook" title="" target="_blank">
<code>ethers::addressbook</code></a> <code>-&gt;</code> æ— è®¡åˆ’</p>
</li>
<li>
<p>ç¼–è¯‘å™¨: <a href="https://github.com/gakonst/ethers-rs/tree/master/ethers-solc" title="" target="_blank">
<code>ethers::solc</code></a> <code>-&gt;</code> <a href="https://github.com/foundry-rs/compilers" title="" target="_blank">
<code>foundry-compilers</code></a></p>
</li>
<li>
<p>åˆçº¦: <a href="https://github.com/gakonst/ethers-rs/tree/master/ethers-contract" title="" target="_blank">
<code>ethers::contract</code></a> <code>-&gt;</code> <a href="https://github.com/alloy-rs/alloy/tree/main/crates/contract" title="" target="_blank">
<code>alloy::contract</code></a></p>
</li>
<li>
<p>æ ¸å¿ƒ: <a href="https://github.com/gakonst/ethers-rs/tree/master/ethers-core" title="" target="_blank">
<code>ethers::core</code></a> <code>-&gt;</code> <a href="https://github.com/alloy-rs/core" title="" target="_blank">
<code>alloy::core</code></a></p>
<ul>
<li>ç±»å‹: <a href="https://github.com/gakonst/ethers-rs/tree/master/ethers-core/src/types" title="" target="_blank">
<code>ethers::core::types::*</code></a> <code>-&gt;</code> è§ <a href="migrating-from-ethers/reference.html#types">Types</a> éƒ¨åˆ†</li>
</ul>
</li>
<li>
<p>Etherscan: <a href="https://github.com/gakonst/ethers-rs/tree/master/ethers-etherscan" title="" target="_blank">
<code>ethers::etherscan</code></a> <code>-&gt;</code> <a href="https://github.com/foundry-rs/block-explorers" title="" target="_blank">
<code>foundry-block-explorers</code></a></p>
</li>
<li>
<p>ä¸­é—´ä»¶: <a href="https://github.com/gakonst/ethers-rs/tree/master/ethers-middleware" title="" target="_blank">
<code>ethers::middleware</code></a> <code>-&gt;</code> å¡«å……å™¨ <a href="https://github.com/alloy-rs/alloy/tree/main/crates/provider/src" title="" target="_blank">
<code>alloy::provider::{fillers, layers}</code></a></p>
<ul>
<li>Gas é¢„è¨€æœº: <a href="https://github.com/gakonst/ethers-rs/tree/master/ethers-middleware/src/gas_oracle/middleware.rs" title="" target="_blank">
<code>ethers::middleware::GasOracleMiddleware</code></a> <code>-&gt;</code> Gas å¡«å……å™¨ <a href="https://github.com/alloy-rs/examples/tree/main/examples/fillers/examples/gas_filler.rs" title="" target="_blank">
<code>alloy::provider::GasFiller</code></a></li>
<li>Gas åŠ é€Ÿå™¨: <a href="https://github.com/gakonst/ethers-rs/tree/master/ethers-middleware/src/gas_escalator" title="" target="_blank">
<code>ethers::middleware::GasEscalatorMiddleware</code></a> <code>-&gt;</code> æ— è®¡åˆ’</li>
<li>å˜æ¢å™¨: <a href="https://github.com/gakonst/ethers-rs/tree/master/ethers-middleware/src/transformer" title="" target="_blank">
<code>ethers::middleware::TransformerMiddleware</code></a> <code>-&gt;</code> æ— è®¡åˆ’</li>
<li>ç­–ç•¥: <a href="https://github.com/gakonst/ethers-rs/blob/master/ethers-middleware/src/policy.rs" title="" target="_blank">
<code>ethers::middleware::policy::*</code></a> <code>-&gt;</code> æ— è®¡åˆ’</li>
<li>Timelag: <a href="https://github.com/gakonst/ethers-rs/tree/master/ethers-middleware/src/timelag" title="" target="_blank">
<code>ethers::middleware::timelag::*</code></a> <code>-&gt;</code> æ— è®¡åˆ’</li>
<li>Nonce ç®¡ç†å™¨: <a href="https://github.com/gakonst/ethers-rs/tree/master/ethers-middleware/src/nonce_manager.rs" title="" target="_blank">
<code>ethers::middleware::NonceManagerMiddleware</code></a> <code>-&gt;</code> Nonce å¡«å……å™¨<a href="https://github.com/alloy-rs/alloy/tree/main/crates/provider/src/fillers/nonce.rs" title="" target="_blank">
<code>alloy::provider::NonceFiller</code></a></li>
<li>ç­¾å: <a href="https://github.com/gakonst/ethers-rs/tree/master/ethers-middleware/src/signer.rs" title="" target="_blank">
<code>ethers::middleware::Signer</code></a> <code>-&gt;</code> é’±åŒ…å¡«å……å™¨ <a href="https://github.com/alloy-rs/alloy/tree/main/crates/provider/src/fillers/wallet.rs" title="" target="_blank">
<code>alloy::provider::WalletFiller</code></a></li>
</ul>
</li>
<li>
<p>æä¾›è€…: <a href="https://github.com/gakonst/ethers-rs/tree/master/ethers-providers" title="" target="_blank">
<code>ethers::providers</code></a> <code>-&gt;</code> æä¾›è€… <a href="https://github.com/alloy-rs/alloy/tree/main/crates/provider" title="" target="_blank">
<code>alloy::providers</code></a></p>
</li>
<li>
<p>ä¼ è¾“: <a href="https://github.com/gakonst/ethers-rs/tree/master/ethers-providers/src/rpc/transports" title="" target="_blank">
<code>ethers::providers::transports</code></a> <code>-&gt;</code> <a href="https://github.com/alloy-rs/alloy/tree/main/crates/transport" title="" target="_blank">
<code>alloy::transports</code></a></p>
<ul>
<li>HTTP: <a href="https://github.com/gakonst/ethers-rs/tree/master/ethers-providers/src/rpc/transports/http.rs" title="" target="_blank">
<code>ethers::providers::Http</code></a> <code>-&gt;</code> <a href="https://github.com/alloy-rs/alloy/tree/main/crates/transport-http" title="" target="_blank">
<code>alloy::transports::http</code></a></li>
<li>IPC: <a href="https://github.com/gakonst/ethers-rs/tree/master/ethers-providers/src/rpc/transports/ipc.rs" title="" target="_blank">
<code>ethers::providers::Ipc</code></a> <code>-&gt;</code> <a href="https://github.com/alloy-rs/alloy/tree/main/crates/transport-ipc" title="" target="_blank">
<code>alloy::transports::ipc</code></a></li>
<li>WS: <a href="https://github.com/gakonst/ethers-rs/tree/master/ethers-providers/src/rpc/transports/ws" title="" target="_blank">
<code>ethers::providers::Ws</code></a> <code>-&gt;</code> <a href="https://github.com/alloy-rs/alloy/tree/main/crates/transport-ws" title="" target="_blank">
<code>alloy::transports::ws</code></a></li>
</ul>
</li>
<li>
<p>ç­¾åè€…: <a href="https://github.com/gakonst/ethers-rs/tree/master/ethers-signers" title="" target="_blank">
<code>ethers::signers</code></a> <code>-&gt;</code> ç­¾åè€… <a href="https://github.com/alloy-rs/alloy/tree/main/crates/signer" title="" target="_blank">
<code>alloy::signers</code></a></p>
<ul>
<li>AWS: <a href="https://github.com/gakonst/ethers-rs/tree/master/ethers-signers/src/aws" title="" target="_blank">
<code>ethers::signers::aws::*</code></a> <code>-&gt;</code> <a href="https://github.com/alloy-rs/alloy/tree/main/crates/signer-aws" title="" target="_blank">
<code>alloy::signers::aws</code></a></li>
<li>Ledger: <a href="https://github.com/gakonst/ethers-rs/tree/master/ethers-signers/src/ledger" title="" target="_blank">
<code>ethers::signers::ledger::*</code></a> <code>-&gt;</code> <a href="https://github.com/alloy-rs/alloy/tree/main/crates/signer-ledger" title="" target="_blank">
<code>alloy::signers::ledger</code></a></li>
<li>Trezor: <a href="https://github.com/gakonst/ethers-rs/tree/master/ethers-signers/src/trezor" title="" target="_blank">
<code>ethers::signers::trezor::*</code></a> <code>-&gt;</code> <a href="https://github.com/alloy-rs/alloy/tree/main/crates/signer-trezor" title="" target="_blank">
<code>alloy::signer::trezor</code></a></li>
<li>é’±åŒ…: <a href="https://github.com/gakonst/ethers-rs/tree/master/ethers-signers/src/wallet" title="" target="_blank">
<code>ethers::signers::wallet::*</code></a> <code>-&gt;</code> <a href="https://github.com/alloy-rs/alloy/tree/main/crates/signer-local" title="" target="_blank">
<code>alloy::signer::local</code></a></li>
</ul>
</li>
</ul>
<h3 id="ç±»å‹"><a class="header" href="#ç±»å‹">ç±»å‹</a></h3>
<h4 id="åŸå§‹ç±»å‹"><a class="header" href="#åŸå§‹ç±»å‹">åŸå§‹ç±»å‹</a></h4>
<ul>
<li>åœ°å€: <a href="https://github.com/gakonst/ethers-rs/tree/master/ethers-core/src/types/mod.rs" title="" target="_blank">
<code>ethers::types::Address</code></a> <code>-&gt;</code> <a href="https://github.com/alloy-rs/core/tree/main/crates/primitives/src/lib.rs" title="" target="_blank">
<code>alloy::primitives::Address</code></a></li>
<li>U64: <a href="https://github.com/gakonst/ethers-rs/tree/master/ethers-core/src/types/mod.rs" title="" target="_blank">
<code>ethers::types::U64</code></a> <code>-&gt;</code> <a href="https://github.com/alloy-rs/core/tree/main/crates/primitives/src/lib.rs" title="" target="_blank">
<code>alloy::primitives::U64</code></a></li>
<li>U128: <a href="https://github.com/gakonst/ethers-rs/tree/master/ethers-core/src/types/mod.rs" title="" target="_blank">
<code>ethers::types::U128</code></a> <code>-&gt;</code> <a href="https://github.com/alloy-rs/core/tree/main/crates/primitives/src/lib.rs" title="" target="_blank">
<code>alloy::primitives::U128</code></a></li>
<li>U256: <a href="https://github.com/gakonst/ethers-rs/tree/master/ethers-core/src/types/mod.rs" title="" target="_blank">
<code>ethers::types::U256</code></a> <code>-&gt;</code> <a href="https://github.com/alloy-rs/core/tree/main/crates/primitives/src/lib.rs" title="" target="_blank">
<code>alloy::primitives::U256</code></a></li>
<li>U512: <a href="https://github.com/gakonst/ethers-rs/tree/master/ethers-core/src/types/mod.rs" title="" target="_blank">
<code>ethers::types::U512</code></a> <code>-&gt;</code> <a href="https://github.com/alloy-rs/core/tree/main/crates/primitives/src/lib.rs" title="" target="_blank">
<code>alloy::primitives::U512</code></a></li>
<li>H32: <a href="https://github.com/gakonst/ethers-rs/tree/master/ethers-core/src/types/mod.rs" title="" target="_blank">
<code>ethers::types::H32</code></a> <code>-&gt;</code> <a href="https://github.com/alloy-rs/core/tree/main/crates/primitives/src/lib.rs" title="" target="_blank">
<code>alloy::primitives::aliases::B32</code></a></li>
<li>H64: <a href="https://github.com/gakonst/ethers-rs/tree/master/ethers-core/src/types/mod.rs" title="" target="_blank">
<code>ethers::types::H64</code></a> <code>-&gt;</code> <a href="https://github.com/alloy-rs/core/tree/main/crates/primitives/src/lib.rs" title="" target="_blank">
<code>alloy::primitives::B64</code></a></li>
<li>H128: <a href="https://github.com/gakonst/ethers-rs/tree/master/ethers-core/src/types/mod.rs" title="" target="_blank">
<code>ethers::types::H128</code></a> <code>-&gt;</code> <a href="https://github.com/alloy-rs/core/tree/main/crates/primitives/src/lib.rs" title="" target="_blank">
<code>alloy::primitives::B128</code></a></li>
<li>H160: <a href="https://github.com/gakonst/ethers-rs/tree/master/ethers-core/src/types/mod.rs" title="" target="_blank">
<code>ethers::types::H160</code></a> <code>-&gt;</code> <a href="https://github.com/alloy-rs/core/tree/main/crates/primitives/src/lib.rs" title="" target="_blank">
<code>alloy::primitives::B160</code></a></li>
<li>H256: <a href="https://github.com/gakonst/ethers-rs/tree/master/ethers-core/src/types/mod.rs" title="" target="_blank">
<code>ethers::types::H256</code></a> <code>-&gt;</code> <a href="https://github.com/alloy-rs/core/tree/main/crates/primitives/src/lib.rs" title="" target="_blank">
<code>alloy::primitives::B256</code></a></li>
<li>H512: <a href="https://github.com/gakonst/ethers-rs/tree/master/ethers-core/src/types/mod.rs" title="" target="_blank">
<code>ethers::types::H512</code></a> <code>-&gt;</code> <a href="https://github.com/alloy-rs/core/tree/main/crates/primitives/src/lib.rs" title="" target="_blank">
<code>alloy::primitives::B512</code></a></li>
<li>Bloom: <a href="https://github.com/gakonst/ethers-rs/tree/master/ethers-core/src/types/mod.rs" title="" target="_blank">
<code>ethers::types::Bloom</code></a> <code>-&gt;</code> <a href="https://github.com/alloy-rs/core/tree/main/crates/primitives/src/lib.rs" title="" target="_blank">
<code>alloy::primitives::Bloom</code></a></li>
<li>TxHash: <a href="https://github.com/gakonst/ethers-rs/tree/master/ethers-core/src/types/mod.rs" title="" target="_blank">
<code>ethers::types::TxHash</code></a> <code>-&gt;</code> <a href="https://github.com/alloy-rs/core/tree/main/crates/primitives/src/lib.rs" title="" target="_blank">
<code>alloy::primitives::TxHash</code></a></li>
</ul>
<p>ç”±äº <code>ruint</code> çš„ä¸€ä¸ª<a href="https://github.com/alloy-rs/core/issues/554#issuecomment-1978620017" title="" target="_blank">é™åˆ¶</a>ï¼ŒBigEndianHash <a href="https://github.com/gakonst/ethers-rs/tree/master/ethers-core/src/types/mod.rs" title="" target="_blank">
<code>ethers::types::BigEndianHash</code></a> å¯ä»¥å¦‚ä¸‹è¡¨ç¤ºï¼š</p>
<pre><code class="language-rust ignore">// `U256` =&gt; `B256`
let x = B256::from(u256);

// `B256` =&gt; `U256`
let x: U256 = b256.into();
let x = U256::from_be_bytes(b256.into())</code></pre>
<h4 id="rpc"><a class="header" href="#rpc">RPC</a></h4>
<ul>
<li>å­—èŠ‚: <a href="https://github.com/gakonst/ethers-rs/tree/master/ethers-core/src/types/bytes.rs" title="" target="_blank">
<code>ethers::types::bytes::*</code></a> <code>-&gt;</code> <a href="https://github.com/alloy-rs/core/tree/main/crates/primitives/src/lib.rs" title="" target="_blank">
<code>alloy::primitives::Bytes</code></a></li>
<li>é“¾: <a href="https://github.com/gakonst/ethers-rs/tree/master/ethers-core/src/types/chain.rs" title="" target="_blank">
<code>ethers::types::Chain</code></a> <code>-&gt;</code> <a href="https://github.com/alloy-rs/chains" title="" target="_blank">
<code>alloy-rs/chains</code></a></li>
<li>ENS: <a href="https://github.com/gakonst/ethers-rs/tree/master/ethers-core/src/types/ens.rs" title="" target="_blank">
<code>ethers::types::ens</code></a> <code>-&gt;</code> <a href="https://github.com/foundry-rs/foundry/tree/master/crates/common/src/ens.rs" title="" target="_blank">
<code>foundry-common</code></a></li>
<li>Trace: <a href="https://github.com/gakonst/ethers-rs/tree/master/ethers-core/src/types/trace" title="" target="_blank">
<code>ethers::types::trace::*</code></a> <code>-&gt;</code> <a href="https://github.com/alloy-rs/alloy/tree/main/crates/rpc-types-trace" title="" target="_blank">
<code>alloy::rpc::types::trace</code></a></li>
<li>{Block, Fee, Filter, Log, Syncing, Transaction, TxPool}: <a href="https://github.com/gakonst/ethers-rs/tree/master/ethers-core/src/types" title="" target="_blank">
<code>ethers::types::*</code></a> <code>-&gt;</code> <a href="https://github.com/alloy-rs/alloy/tree/main/crates/rpc-types/src/eth" title="" target="_blank">
<code>alloy::rpc::types::eth::*</code></a></li>
<li>Proof: <a href="https://github.com/gakonst/ethers-rs/tree/master/ethers-core/src/types/proof.rs" title="" target="_blank">
<code>ethers::types::proof::*</code></a> <code>-&gt;</code> è´¦æˆ· <a href="https://github.com/alloy-rs/alloy/tree/main/crates/rpc-types/src/eth/account.rs" title="" target="_blank">
<code>alloy::rpc::types::eth::account::*</code></a></li>
<li>ç­¾å: <a href="https://github.com/gakonst/ethers-rs/tree/master/ethers-core/src/types/signature.rs" title="" target="_blank">
<code>ethers::types::signature::*</code></a> <code>-&gt;</code> <a href="https://github.com/alloy-rs/alloy/tree/main/crates/rpc-types/src/eth/transaction/signature.rs" title="" target="_blank">
<code>alloy::rpc::types::eth::transaction::signature::*</code></a></li>
<li>æç°: <a href="https://github.com/gakonst/ethers-rs/tree/master/ethers-core/src/types/withdrawal.rs" title="" target="_blank">
<code>ethers::types::withdrawal::*</code></a> <code>-&gt;</code> EIP4895 <a href="https://github.com/alloy-rs/alloy/tree/main/crates/eips/src/eip4895.rs" title="" target="_blank">
<code>alloy::eips::eip4895</code></a></li>
<li>æ“ä½œç : <a href="https://github.com/gakonst/ethers-rs/tree/master/ethers-core/src/types/opcode.rs" title="" target="_blank">
<code>ethers::types::opcode::*</code></a> <code>-&gt;</code> <a href="https://github.com/alloy-rs/core/tree/main/crates/syn-solidity" title="" target="_blank">
<code>syn-solidity</code></a></li>
</ul>
<h3 id="abi"><a class="header" href="#abi">ABI</a></h3>
<ul>
<li>ç»‘å®š: <a href="https://github.com/gakonst/ethers-rs/tree/51fe937f6515689b17a3a83b74a05984ad3a7f11/ethers-contract/ethers-contract-abigen" title="" target="_blank">
<code>abigen!</code></a> <code>-&gt;</code> <a href="https://github.com/alloy-rs/core/tree/main/crates/sol-types" title="" target="_blank">
<code>sol!</code></a>ï¼Œå¯ç”¨äº <a href="https://github.com/alloy-rs/alloy/blob/aea7e07b4b335a3a35e3870a6c277d397d0f3932/crates/alloy/src/lib.rs#L52-L64" title="" target="_blank">
<code>alloy::sol</code></a>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="åŸºæœ¬æ„å»ºæ¨¡å—"><a class="header" href="#åŸºæœ¬æ„å»ºæ¨¡å—">åŸºæœ¬æ„å»ºæ¨¡å—</a></h1>
<ul>
<li><a href="building-with-alloy/basic-building-blocks/using-big-numbers.html">ä½¿ç”¨å¤§æ•°</a></li>
<li><a href="building-with-alloy/basic-building-blocks/basic-hash-and-address-types.html">åŸºæœ¬å“ˆå¸Œå’Œåœ°å€ç±»å‹</a></li>
<li><a href="building-with-alloy/basic-building-blocks/common-conversions.html">å¸¸è§è½¬æ¢</a></li>
<li><a href="building-with-alloy/basic-building-blocks/creating-instances.html">åˆ›å»ºå®ä¾‹</a></li>
<li><a href="building-with-alloy/basic-building-blocks/comparisons-and-equivalence.html">æ¯”è¾ƒå’Œç­‰ä»·</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="ä½¿ç”¨å¤§æ•°"><a class="header" href="#ä½¿ç”¨å¤§æ•°">ä½¿ç”¨å¤§æ•°</a></h2>
<p>ä»¥å¤ªåŠä½¿ç”¨å¤§æ•°ï¼ˆä¹Ÿç§°ä¸ºâ€œbignumsâ€æˆ–â€œä»»æ„ç²¾åº¦æ•´æ•°â€ï¼‰æ¥è¡¨ç¤ºå…¶ä»£ç åº“ä¸­çš„æŸäº›å€¼ä»¥åŠåŒºå—é“¾äº¤æ˜“ä¸­çš„ä¸€äº›å€¼ã€‚è¿™æ˜¯å¿…è¦çš„ï¼Œå› ä¸º <a href="https://ethereum.org/en/developers/docs/evm" title="" target="_blank">EVM</a> åœ¨ 256 ä½å­—å¤§å°ä¸Šè¿è¡Œï¼Œè¿™ä¸ç°ä»£æœºå™¨é€šå¸¸çš„ 32 ä½æˆ– 64 ä½ä¸åŒã€‚è¿™ç§é€‰æ‹©æ˜¯ä¸ºäº†æ–¹ä¾¿ä½¿ç”¨ 256 ä½å¯†ç å­¦ï¼ˆä¾‹å¦‚ <a href="https://github.com/ethereum/eth-hash" title="" target="_blank">Keccak-256</a> å“ˆå¸Œæˆ– <a href="https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm" title="" target="_blank">secp256k1</a> ç­¾åï¼‰ã€‚</p>
<p>å€¼å¾—æ³¨æ„çš„æ˜¯ï¼Œä¸ä»…ä»…æ˜¯ä»¥å¤ªåŠè¿™ç§åŒºå—é“¾æˆ–åŠ å¯†è´§å¸ä½¿ç”¨å¤§æ•°ã€‚è®¸å¤šå…¶ä»–åŒºå—é“¾å’ŒåŠ å¯†è´§å¸ä¹Ÿä½¿ç”¨å¤§æ•°æ¥è¡¨ç¤ºå…¶å„è‡ªç³»ç»Ÿä¸­çš„å€¼ã€‚</p>
<h3 id="å®ç”¨å·¥å…·"><a class="header" href="#å®ç”¨å·¥å…·">å®ç”¨å·¥å…·</a></h3>
<p>ä¸ºäº†åˆ›å»ºåº”ç”¨ç¨‹åºï¼Œé€šå¸¸éœ€è¦åœ¨å®¹æ˜“è®©äººç†è§£çš„å€¼ï¼ˆä¾‹å¦‚ etherï¼‰å’Œåˆçº¦åŠæ•°å­¦å‡½æ•°ä½¿ç”¨çš„æœºå™¨å¯è¯»å½¢å¼ï¼ˆä¾‹å¦‚ weiï¼‰ä¹‹é—´è¿›è¡Œè½¬æ¢ã€‚è¿™åœ¨ä»¥å¤ªåŠå·¥ä½œä¸­å°¤ä¸ºé‡è¦ï¼Œå› ä¸ºæŸäº›æ•°å€¼ï¼Œå¦‚ä½™é¢å’Œ gas ä»·æ ¼ï¼Œåœ¨å‘é€äº¤æ˜“æ—¶å¿…é¡»ä»¥ wei è¡¨ç¤ºï¼Œå³ä½¿å®ƒä»¬ä»¥å…¶ä»–æ ¼å¼ï¼ˆå¦‚ ether æˆ– gweiï¼‰æ˜¾ç¤ºç»™ç”¨æˆ·ã€‚ä¸ºäº†å¸®åŠ©è¿›è¡Œè¿™ç§è½¬æ¢ï¼Œ<code>alloy::primitives::utils</code> æä¾›äº†ä¸¤ä¸ªå‡½æ•°ï¼Œ<a href="https://github.com/alloy-rs/core/blob/main/crates/primitives/src/utils/units.rs" title="" target="_blank">
<code>parse_units</code></a> å’Œ <a href="https://github.com/alloy-rs/core/blob/main/crates/primitives/src/utils/units.rs" title="" target="_blank">
<code>format_units</code></a>ï¼Œå®ƒä»¬å¯ä»¥è½»æ¾åœ°åœ¨äººç±»å¯è¯»å’Œæœºå™¨å¯è¯»çš„å€¼å½¢å¼ä¹‹é—´è½¬æ¢ã€‚parse_units å¯ä»¥å°†è¡¨ç¤º ether å€¼çš„å­—ç¬¦ä¸²ï¼ˆä¾‹å¦‚ â€œ1.1â€ï¼‰è½¬æ¢ä¸ºå¯ä»¥åœ¨åˆçº¦å’Œæ•°å­¦å‡½æ•°ä¸­ä½¿ç”¨çš„ wei å¤§æ•°ã€‚format_units å¯ä»¥å°†å¤§æ•°å€¼è½¬æ¢ä¸ºäººç±»å¯è¯»çš„å­—ç¬¦ä¸²ï¼Œè¿™å¯¹äºå‘ç”¨æˆ·æ˜¾ç¤ºå€¼éå¸¸æœ‰ç”¨ã€‚</p>
<!-- DO NOT EDIT THIS FILE. IT IS GENERATED BY RUNNING `./scripts/update.sh` -->
<!-- ANY CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN -->
<!-- EDIT OR CREATE THIS TEMPLATE INSTEAD: ./src/templates/big-numbers/math_operations.md -->
<!-- LATEST UPDATE: https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="ç¤ºä¾‹-math_operationsæ•°å­¦è¿ç®—"><a class="header" href="#ç¤ºä¾‹-math_operationsæ•°å­¦è¿ç®—">ç¤ºä¾‹: <code>math_operations</code>ï¼ˆæ•°å­¦è¿ç®—ï¼‰</a></h2>
<h3 id="ç¤ºä¾‹-1"><a class="header" href="#ç¤ºä¾‹-1">ç¤ºä¾‹</a></h3>
<p>è¦è¿è¡Œæ­¤ç¤ºä¾‹ï¼š</p>
<ul>
<li>å…‹éš† <a href="https://github.com/alloy-rs/examples">examples</a> ä»“åº“: <code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>è¿è¡Œ: <code>cargo run --example math_operations</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example of performing arithmetic operations with `U256`.

use alloy::primitives::{utils::format_units, U256};
use eyre::Result;
use std::ops::{Div, Mul};

/// `U256` implements traits in `std::ops`, that means it supports arithmetic operations
/// using standard Rust operators `+`, `-`. `*`, `/`, `%`, along with additional utilities to
/// perform common mathematical tasks.
fn main() -&gt; Result&lt;()&gt; {
    let a = U256::from(10);
    let b = U256::from(2);

    // addition
    let sum = a + b;
    assert_eq!(sum, U256::from(12));

    // subtraction
    let difference = a - b;
    assert_eq!(difference, U256::from(8));

    // multiplication
    let product = a * b;
    assert_eq!(product, U256::from(20));

    // division
    let quotient = a / b;
    assert_eq!(quotient, U256::from(5));

    // modulo
    let remainder = a % b;
    assert_eq!(remainder, U256::ZERO); // equivalent to `U256::from(0)`

    // exponentiation
    let power = a.pow(b);
    assert_eq!(power, U256::from(100));

    // Multiply two 'ether' numbers:
    // Big numbers are integers, that can represent fixed point numbers.
    // For instance, 1 ether has 18 fixed
    // decimal places (1.000000000000000000), and its big number
    // representation is 10^18 = 1000000000000000000.
    // When we multiply such numbers we are summing up their exponents.
    // So if we multiply 10^18 * 10^18 we get 10^36, that is obviously incorrect.
    // In order to get the correct result we need to divide by 10^18.
    let eth1 = U256::from(10_000000000000000000_u128); // 10 ether
    let eth2 = U256::from(20_000000000000000000_u128); // 20 ether
    let base = U256::from(10).pow(U256::from(18));
    let mul = eth1.mul(eth2).div(base); // We also divide by 10^18
    let s: String = format_units(mul, "ether")?;
    assert_eq!(s, "200.000000000000000000"); // 200

    Ok(())
}</code></pre>
<p>åœ¨ Github ä¸Šæ‰¾åˆ°æºç  <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/big-numbers/examples/math_operations.rs">here</a>.</p>
<!-- DO NOT EDIT THIS FILE. IT IS GENERATED BY RUNNING `./scripts/update.sh` -->
<!-- ANY CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN -->
<!-- EDIT OR CREATE THIS TEMPLATE INSTEAD: ./src/templates/big-numbers/math_utilities.md -->
<!-- LATEST UPDATE: https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="ç¤ºä¾‹math_utilities"><a class="header" href="#ç¤ºä¾‹math_utilities">ç¤ºä¾‹ï¼š<code>math_utilities</code></a></h2>
<h3 id="ç¤ºä¾‹-2"><a class="header" href="#ç¤ºä¾‹-2">ç¤ºä¾‹</a></h3>
<p>è¿è¡Œæ­¤ç¤ºä¾‹ï¼š</p>
<ul>
<li>å…‹éš† <a href="https://github.com/alloy-rs/examples">examples</a> ä»“åº“ï¼š<code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>è¿è¡Œï¼š<code>cargo run --example math_utilities</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example of using math utilities to handle big numbers in 'wei' units.

use alloy::primitives::{
    utils::{format_units, parse_units},
    U256,
};
use eyre::Result;

fn main() -&gt; Result&lt;()&gt; {
    parse_units_example()?;
    format_units_example()?;

    Ok(())
}

/// dApps business logics handle big numbers in 'wei' units (i.e. sending transactions, on-chain
/// math, etc.). We provide convenient methods to map user inputs (usually in 'ether' or 'gwei')
/// into 'wei' format.
fn parse_units_example() -&gt; Result&lt;()&gt; {
    let pu = parse_units("1.0", "wei")?;
    let num: U256 = pu.into();
    assert_eq!(num, U256::from(1));

    let pu = parse_units("1.0", "kwei")?;
    let num: U256 = pu.into();
    assert_eq!(num, U256::from(1000));

    let pu = parse_units("1.0", "mwei")?;
    let num: U256 = pu.into();
    assert_eq!(num, U256::from(1000000));

    let pu = parse_units("1.0", "gwei")?;
    let num: U256 = pu.into();
    assert_eq!(num, U256::from(1000000000));

    let pu = parse_units("1.0", "szabo")?;
    let num: U256 = pu.into();
    assert_eq!(num, U256::from(1000000000000_u128));

    let pu = parse_units("1.0", "finney")?;
    let num: U256 = pu.into();
    assert_eq!(num, U256::from(1000000000000000_u128));

    let pu = parse_units("1.0", "ether")?;
    let num: U256 = pu.into();
    assert_eq!(num, U256::from(1000000000000000000_u128));

    let pu = parse_units("1.0", 18)?;
    let num: U256 = pu.into();
    assert_eq!(num, U256::from(1000000000000000000_u128));

    Ok(())
}

/// dApps business logics handle big numbers in 'wei' units (i.e. sending transactions, on-chain
/// math, etc.). On the other hand it is useful to convert big numbers into user readable formats
/// when displaying on a UI. Generally dApps display numbers in 'ether' and 'gwei' units,
/// respectively for displaying amounts and gas. The `format_units` function will format a big
/// number into a user readable string.
fn format_units_example() -&gt; Result&lt;()&gt; {
    // 1 ETHER = 10^18 WEI
    let one_ether = U256::from(1000000000000000000_u128);

    let num: String = format_units(one_ether, "wei")?;
    assert_eq!(num, "1000000000000000000.0");

    let num: String = format_units(one_ether, "gwei")?;
    assert_eq!(num, "1000000000.000000000");

    let num: String = format_units(one_ether, "ether")?;
    assert_eq!(num, "1.000000000000000000");

    // 1 GWEI = 10^9 WEI
    let one_gwei = U256::from(1000000000_u128);

    let num: String = format_units(one_gwei, 0)?;
    assert_eq!(num, "1000000000.0");

    let num: String = format_units(one_gwei, "wei")?;
    assert_eq!(num, "1000000000.0");

    let num: String = format_units(one_gwei, "kwei")?;
    assert_eq!(num, "1000000.000");

    let num: String = format_units(one_gwei, "mwei")?;
    assert_eq!(num, "1000.000000");

    let num: String = format_units(one_gwei, "gwei")?;
    assert_eq!(num, "1.000000000");

    let num: String = format_units(one_gwei, "szabo")?;
    assert_eq!(num, "0.001000000000");

    let num: String = format_units(one_gwei, "finney")?;
    assert_eq!(num, "0.000001000000000");

    let num: String = format_units(one_gwei, "ether")?;
    assert_eq!(num, "0.000000001000000000");

    Ok(())
}</code></pre>
<p>åœ¨ Github ä¸Šæ‰¾åˆ°æºä»£ç  <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/big-numbers/examples/math_utilities.rs">here</a>ã€‚</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="åŸºæœ¬å“ˆå¸Œå’Œåœ°å€ç±»å‹"><a class="header" href="#åŸºæœ¬å“ˆå¸Œå’Œåœ°å€ç±»å‹">åŸºæœ¬å“ˆå¸Œå’Œåœ°å€ç±»å‹</a></h2>
<!-- DO NOT EDIT THIS FILE. IT IS GENERATED BY RUNNING `./scripts/update.sh` -->
<!-- ANY CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN -->
<!-- EDIT OR CREATE THIS TEMPLATE INSTEAD: ./src/templates/primitives/bytes_and_address_types.md -->
<!-- LATEST UPDATE: https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="ç¤ºä¾‹-bytes_and_address_types"><a class="header" href="#ç¤ºä¾‹-bytes_and_address_types">ç¤ºä¾‹: <code>bytes_and_address_types</code></a></h2>
<h3 id="ç¤ºä¾‹-3"><a class="header" href="#ç¤ºä¾‹-3">ç¤ºä¾‹</a></h3>
<p>è¦è¿è¡Œæ­¤ç¤ºä¾‹ï¼š</p>
<ul>
<li>å…‹éš† <a href="https://github.com/alloy-rs/examples">examples</a> ä»“åº“ï¼š<code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>è¿è¡Œï¼š<code>cargo run --example bytes_and_address_types</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example of basic usage of bytes and address types and macros.

use alloy::primitives::{
    address, b128, b256, b512, b64, bytes, fixed_bytes, Address, Bytes, FixedBytes,
};
use eyre::Result;

fn main() -&gt; Result&lt;()&gt; {
    // Bytes type
    let a = bytes!("0123abcd");
    assert_eq!(a, Bytes::from(&amp;[0x01, 0x23, 0xab, 0xcd]));
    assert_eq!(a.len(), 4);

    // Address type
    let b = address!("f39Fd6e51aad88F6F4ce6aB8827279cffFb92266");
    assert_eq!(
        b,
        Address::from(&amp;[
            0xf3, 0x9f, 0xd6, 0xe5, 0x1a, 0xad, 0x88, 0xf6, 0xf4, 0xce, 0x6a, 0xb8, 0x82, 0x72,
            0x79, 0xcf, 0xff, 0xb9, 0x22, 0x66
        ])
    );
    assert_eq!(b.len(), 20);

    // FixedBytes&lt;8&gt; type
    let c = b64!("0102030405060708");
    assert_eq!(c, FixedBytes::from(&amp;[0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08]));
    assert_eq!(c.len(), 8);

    // FixedBytes&lt;16&gt; type
    let d = b128!("0102030405060708090a0b0c0d0e0f10");
    assert_eq!(
        d,
        FixedBytes::from(&amp;[
            0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e,
            0x0f, 0x10,
        ])
    );
    assert_eq!(d.len(), 16);

    // FixedBytes&lt;32&gt; type
    let e = b256!("0102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f20");
    assert_eq!(
        e,
        FixedBytes::from(&amp;[
            0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e,
            0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c,
            0x1d, 0x1e, 0x1f, 0x20,
        ]),
    );
    assert_eq!(e.len(), 32);

    // FixedBytes&lt;64&gt; type
    let f = b512!("0102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f202122232425262728292a2b2c2d2e2f303132333435363738393a3b3c3d3e3f40");
    assert_eq!(
        f,
        FixedBytes::from(&amp;[
            0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e,
            0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c,
            0x1d, 0x1e, 0x1f, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a,
            0x2b, 0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38,
            0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f, 0x40,
        ]),
    );
    assert_eq!(f.len(), 64);

    // FixedBytes&lt;20&gt; type, determined by the length of the input
    let g = fixed_bytes!("0102030405060708090a0b0c0d0e0f1011121314");
    assert_eq!(
        g,
        FixedBytes::from(&amp;[
            0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e,
            0x0f, 0x10, 0x11, 0x12, 0x13, 0x14,
        ]),
    );
    assert_eq!(g.len(), 20);

    Ok(())
}</code></pre>
<p>åœ¨ Github ä¸Šå¯ä»¥æ‰¾åˆ°æºç  <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/primitives/examples/bytes_and_address_types.rs">here</a>.</p>
<!-- DO NOT EDIT THIS FILE. IT IS GENERATED BY RUNNING `./scripts/update.sh` -->
<!-- ANY CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN -->
<!-- EDIT OR CREATE THIS TEMPLATE INSTEAD: ./src/templates/primitives/hashing_functions.md -->
<!-- LATEST UPDATE: https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="ç¤ºä¾‹-hashing_functions-å“ˆå¸Œå‡½æ•°"><a class="header" href="#ç¤ºä¾‹-hashing_functions-å“ˆå¸Œå‡½æ•°">ç¤ºä¾‹: <code>hashing_functions</code> å“ˆå¸Œå‡½æ•°</a></h2>
<h3 id="ç¤ºä¾‹-4"><a class="header" href="#ç¤ºä¾‹-4">ç¤ºä¾‹</a></h3>
<p>è¦è¿è¡Œè¿™ä¸ªç¤ºä¾‹ï¼š</p>
<ul>
<li>å…‹éš† <a href="https://github.com/alloy-rs/examples">examples</a> ä»£ç åº“: <code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>è¿è¡Œ: <code>cargo run --example hashing_functions</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example of basic usage of hashing functions.

use alloy::primitives::{eip191_hash_message, keccak256};
use eyre::{Ok, Result};

fn main() -&gt; Result&lt;()&gt; {
    // [`Keccak-256`]: https://en.wikipedia.org/wiki/SHA-3
    let hash = keccak256(b"hello world");
    assert_eq!(
        hash.to_string(),
        "0x47173285a8d7341e5e972fc677286384f802f8ef42a5ec5f03bbfa254cb01fad"
    );
    assert_eq!(hash.len(), 32);

    // Hash a message according to [EIP-191] (version `0x01`).
    //
    // The final message is a UTF-8 string, encoded as follows:
    // `"\x19Ethereum Signed Message:\n" + message.length + message`
    //
    // This message is then hashed using [`Keccak-256`]: https://en.wikipedia.org/wiki/SHA-3.
    //
    // [EIP-191]: https://eips.ethereum.org/EIPS/eip-191
    let eip191_hash = eip191_hash_message(b"hello_world");
    assert_eq!(
        eip191_hash.to_string(),
        "0xd52de6e039c023a7c77752126e4d9d99e2a7dacea3d19e97e9c2ebcb3ecf1c00"
    );
    assert_eq!(eip191_hash.len(), 32);

    Ok(())
}</code></pre>
<p>åœ¨ Github ä¸Šæ‰¾åˆ°æºç  <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/primitives/examples/hashing_functions.rs">è¿™é‡Œ</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="common-conversions"><a class="header" href="#common-conversions">Common conversions</a></h2>
<!-- DO NOT EDIT THIS FILE. IT IS GENERATED BY RUNNING `./scripts/update.sh` -->
<!-- ANY CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN -->
<!-- EDIT OR CREATE THIS TEMPLATE INSTEAD: ./src/templates/big-numbers/conversion.md -->
<!-- LATEST UPDATE: https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="ç¤ºä¾‹-conversion"><a class="header" href="#ç¤ºä¾‹-conversion">ç¤ºä¾‹: <code>conversion</code></a></h2>
<h3 id="ç¤ºä¾‹-5"><a class="header" href="#ç¤ºä¾‹-5">ç¤ºä¾‹</a></h3>
<p>è¿è¡Œè¿™ä¸ªç¤ºä¾‹:</p>
<ul>
<li>å…‹éš† <a href="https://github.com/alloy-rs/examples">examples</a> ä»“åº“: <code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>è¿è¡Œ: <code>cargo run --example conversion</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example of converting `U256` to native Rust types.

use alloy::primitives::{utils::format_units, U256};
use eyre::Result;

/// `U256` provides useful conversion functions to enable transformation into native Rust types.
///
/// It is important to note that converting a big-number to a floating point type (such as a `f32`
/// or `f64`) can result in a loss of precision, since you cannot fit 256 bits of information into
/// 64 bits.
///
/// However, there may be cases where you want to perform conversions for presentation purposes.
/// For example, you may want to display a large number to the user in a more readable format.
fn main() -&gt; Result&lt;()&gt; {
    let num = U256::from(42_u8);

    let a: u128 = num.to::&lt;u128&gt;();
    assert_eq!(a, 42);

    let b: u64 = num.to::&lt;u64&gt;();
    assert_eq!(b, 42);

    let c: u32 = num.to::&lt;u32&gt;();
    assert_eq!(c, 42);

    let d: usize = num.to::&lt;usize&gt;();
    assert_eq!(d, 42);

    let e: String = num.to_string();
    assert_eq!(e, "42");

    let f: String = format_units(num, 4)?;
    assert_eq!(f, "0.0042");

    Ok(())
}</code></pre>
<p>åœ¨ Github ä¸Šæ‰¾åˆ°æºä»£ç  <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/big-numbers/examples/conversion.rs">here</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="åˆ›å»ºå®ä¾‹"><a class="header" href="#åˆ›å»ºå®ä¾‹">åˆ›å»ºå®ä¾‹</a></h2>
<!-- DO NOT EDIT THIS FILE. IT IS GENERATED BY RUNNING `./scripts/update.sh` -->
<!-- ANY CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN -->
<!-- EDIT OR CREATE THIS TEMPLATE INSTEAD: ./src/templates/big-numbers/create_instances.md -->
<!-- LATEST UPDATE: https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="ç¤ºä¾‹-create_instances"><a class="header" href="#ç¤ºä¾‹-create_instances">ç¤ºä¾‹: <code>create_instances</code></a></h2>
<h3 id="ä¾‹å­"><a class="header" href="#ä¾‹å­">ä¾‹å­</a></h3>
<p>è¿è¡Œæ­¤ç¤ºä¾‹ï¼š</p>
<ul>
<li>å…‹éš† <a href="https://github.com/alloy-rs/examples">examples</a> ä»“åº“: <code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>è¿è¡Œ: <code>cargo run --example create_instances</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example of creating instances of `U256` from strings and numbers.

use alloy::primitives::{
    utils::{parse_units, ParseUnits},
    U256,
};
use eyre::Result;
use std::str::FromStr;

fn main() -&gt; Result&lt;()&gt; {
    // From strings
    let a = U256::from_str("42")?;
    assert_eq!(a.to_string(), "42");

    let amount = "42";
    let units = 4;
    let b: ParseUnits = parse_units(amount, units)?;
    assert_eq!(b.to_string(), "420000");

    // From numbers
    let c = U256::from(42_u8);
    assert_eq!(c.to_string(), "42");

    let d = U256::from(42_u16);
    assert_eq!(d.to_string(), "42");

    let e = U256::from(42_u32);
    assert_eq!(e.to_string(), "42");

    let f = U256::from(42_u64);
    assert_eq!(f.to_string(), "42");

    let g = U256::from(42_u128);
    assert_eq!(g.to_string(), "42");

    let h = U256::from(0x2a);
    assert_eq!(h.to_string(), "42");

    let i = U256::from(42);
    assert_eq!(i.to_string(), "42");

    Ok(())
}</code></pre>
<p>åœ¨ Github ä¸ŠæŸ¥çœ‹æºä»£ç  <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/big-numbers/examples/create_instances.rs">here</a>ã€‚</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="æ¯”è¾ƒä¸ç­‰ä»·"><a class="header" href="#æ¯”è¾ƒä¸ç­‰ä»·">æ¯”è¾ƒä¸ç­‰ä»·</a></h2>
<!-- è¯·ä¸è¦ç¼–è¾‘æ­¤æ–‡ä»¶ã€‚å®ƒæ˜¯é€šè¿‡è¿è¡Œ `./scripts/update.sh` ç”Ÿæˆçš„ -->
<!-- å¯¹æ­¤æ–‡ä»¶åšçš„ä»»ä½•æ›´æ”¹éƒ½ä¼šè¢«è¦†ç›– -->
<!-- è¯·æ”¹ç¼–è¾‘æˆ–åˆ›å»ºè¿™ä¸ªæ¨¡æ¿ï¼š./src/templates/big-numbers/comparison_equivalence.md -->
<!-- æœ€æ–°æ›´æ–°ï¼š https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="ç¤ºä¾‹comparison_equivalence"><a class="header" href="#ç¤ºä¾‹comparison_equivalence">ç¤ºä¾‹ï¼š<code>comparison_equivalence</code></a></h2>
<h3 id="ç¤ºä¾‹-6"><a class="header" href="#ç¤ºä¾‹-6">ç¤ºä¾‹</a></h3>
<p>è¦è¿è¡Œæ­¤ç¤ºä¾‹ï¼š</p>
<ul>
<li>å…‹éš† <a href="https://github.com/alloy-rs/examples">examples</a> ä»“åº“ï¼š<code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>è¿è¡Œï¼š<code>cargo run --example comparison_equivalence</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example of comparison and equivalence of `U256` instances.

use alloy::primitives::U256;

/// `U256` implements traits in `std::cmp`, that means `U256` instances
/// can be easily compared using standard Rust operators.
fn main() {
    // a == b
    let a = U256::from(100_u32);
    let b = U256::from(100_u32);
    assert!(a == b);

    // a &lt; b
    let a = U256::from(1_u32);
    let b = U256::from(100_u32);
    assert!(a &lt; b);

    // a &lt;= b
    let a = U256::from(100_u32);
    let b = U256::from(100_u32);
    assert!(a &lt;= b);

    // a &gt; b
    let a = U256::from(100_u32);
    let b = U256::from(1_u32);
    assert!(a &gt; b);

    // a &gt;= b
    let a = U256::from(100_u32);
    let b = U256::from(100_u32);
    assert!(a &gt;= b);

    // a == 0
    let a = U256::ZERO;
    assert!(a.is_zero());
}</code></pre>
<p>åœ¨ Github ä¸Šå¯ä»¥æ‰¾åˆ°æºç ï¼š<a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/big-numbers/examples/comparison_equivalence.rs">è¿™é‡Œ</a>ã€‚</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="è¿æ¥åŒºå—é“¾"><a class="header" href="#è¿æ¥åŒºå—é“¾">è¿æ¥åŒºå—é“¾</a></h1>
<ul>
<li><a href="building-with-alloy/connecting-to-a-blockchain/setting-up-a-provider.html">è®¾ç½® Provider</a></li>
<li><a href="building-with-alloy/connecting-to-a-blockchain/http-provider.html" title="" target="_blank">åˆ›å»º HTTP provider</a></li>
<li><a href="building-with-alloy/connecting-to-a-blockchain/ws-provider.html">åˆ›å»º WS provider</a></li>
<li><a href="building-with-alloy/connecting-to-a-blockchain/ipc-provider.html">åˆ›å»º IPC provider</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="è®¾ç½®-provider"><a class="header" href="#è®¾ç½®-provider">è®¾ç½® <code>Provider</code></a></h2>
<p>ä¸€ä¸ª <a href="https://docs.rs/alloy/latest/alloy/providers/trait.Provider.html" title="" target="_blank">
<code>Provider</code></a> æ˜¯å¯¹ Ethereum ç½‘ç»œè¿æ¥çš„æŠ½è±¡ï¼Œæä¾›ä¸€ä¸ªç®€æ´ã€ä¸€è‡´çš„æ¥å£æ¥ä½¿ç”¨æ ‡å‡†çš„ Ethereum èŠ‚ç‚¹åŠŸèƒ½ã€‚</p>
<h3 id="builder"><a class="header" href="#builder">Builder</a></h3>
<p>åˆ›å»º <a href="https://docs.rs/alloy/latest/alloy/providers/trait.Provider.html" title="" target="_blank">
<code>Provider</code></a> çš„æ­£ç¡®æ–¹å¼æ˜¯é€šè¿‡ <a href="https://docs.rs/alloy/latest/alloy/providers/struct.ProviderBuilder.html" title="" target="_blank">
<code>ProviderBuilder</code></a>ï¼Œè¿™æ˜¯ä¸€ä¸ª <a href="https://rust-unofficial.github.io/patterns/patterns/creational/builder.html" title="" target="_blank">builder</a>ã€‚</p>
<p>Alloy æä¾›äº†å…·ä½“çš„ä¼ è¾“å®ç°ï¼Œæ¯”å¦‚ <a href="building-with-alloy/connecting-to-a-blockchain/./http-provider.html"><code>HTTP</code></a>ã€<a href="building-with-alloy/connecting-to-a-blockchain/./ws-provider.html"><code>WS</code> (WebSockets)</a> å’Œ <a href="building-with-alloy/connecting-to-a-blockchain/./ipc-provider.html"><code>IPC</code> (è¿›ç¨‹é—´é€šä¿¡)</a>ï¼Œä»¥åŠå°è£…å•ä¸ªæˆ–å¤šä¸ªä¼ è¾“çš„é«˜çº§ä¼ è¾“æ–¹å¼ã€‚</p>
<pre><code class="language-rust ignore">//! ä½¿ç”¨ `on_http` æ–¹æ³•çš„ HTTP provider ç¤ºä¾‹ã€‚

use alloy::providers::{Provider, ProviderBuilder};
use eyre::Result;

#[tokio::main]
async fn main() -&gt; eyre::Result&lt;()&gt; {
    // è®¾ç½®ç”± RPC å®¢æˆ·ç«¯ä½¿ç”¨çš„ HTTP ä¼ è¾“ã€‚
    let rpc_url = "https://eth.merkle.io".parse()?;

    // ä½¿ç”¨ `reqwest` crate åˆ›å»ºä¸€ä¸ªå¸¦æœ‰ HTTP ä¼ è¾“çš„ providerã€‚
    let provider = ProviderBuilder::new().on_http(rpc_url);

    Ok(())
}</code></pre>
<p>æ¥ä¸‹æ¥ï¼Œè®©æˆ‘ä»¬çœ‹çœ‹ <a href="building-with-alloy/connecting-to-a-blockchain/./http-provider.html">HTTP Provider</a>ã€‚</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="http-provider"><a class="header" href="#http-provider">HTTP <code>Provider</code></a></h2>
<p><code>Http</code> æä¾›è€…å»ºç«‹ä¸èŠ‚ç‚¹çš„ HTTP è¿æ¥ï¼Œå…è®¸ä½ å‘é€ JSON-RPC è¯·æ±‚åˆ°èŠ‚ç‚¹ä»¥è·å–æ•°æ®ã€æ¨¡æ‹Ÿè°ƒç”¨ã€å‘é€äº¤æ˜“ç­‰ç­‰ã€‚</p>
<h3 id="åˆå§‹åŒ–-http-æä¾›è€…"><a class="header" href="#åˆå§‹åŒ–-http-æä¾›è€…">åˆå§‹åŒ– Http æä¾›è€…</a></h3>
<p>æ¨èçš„åˆå§‹åŒ– <code>Http</code> æä¾›è€…çš„æ–¹æ³•æ˜¯ä½¿ç”¨ <a href="https://docs.rs/alloy/latest/alloy/providers/struct.ProviderBuilder.html#method.on_http" title="" target="_blank">
<code>on_http</code></a> æ–¹æ³•åœ¨ <a href="https://docs.rs/alloy/latest/alloy/providers/struct.ProviderBuilder.html" title="" target="_blank">
<code>ProviderBuilder</code></a> ä¸Šã€‚</p>
<pre><code class="language-rust ignore">//! ä½¿ç”¨ `ProviderBuilder` ä¸Šçš„ `on_http` æ–¹æ³•åˆ›å»º HTTP æä¾›è€…çš„ç¤ºä¾‹ã€‚

use alloy::providers::{Provider, ProviderBuilder};
use eyre::Result;

#[tokio::main]
async fn main() -&gt; eyre::Result&lt;()&gt; {
    // è®¾ç½®ç”± RPC å®¢æˆ·ç«¯ä½¿ç”¨çš„ HTTP ä¼ è¾“ã€‚
    let rpc_url = "https://eth.merkle.io".parse()?;

    // ä½¿ç”¨ `reqwest` crate åˆ›å»ºä¸€ä¸ªå¸¦æœ‰ HTTP ä¼ è¾“çš„æä¾›è€…ã€‚
    let provider = ProviderBuilder::new().on_http(rpc_url);

    Ok(())
}</code></pre>
<p>å¦ä¸€ç§åˆå§‹åŒ–æ–¹æ³•æ˜¯ä½¿ç”¨ <a href="https://docs.rs/alloy/latest/alloy/providers/struct.ProviderBuilder.html#method.on_builtin" title="" target="_blank">
<code>on_builtin</code></a> æ–¹æ³•åœ¨ <a href="https://docs.rs/alloy/latest/alloy/providers/struct.ProviderBuilder.html" title="" target="_blank">
<code>ProviderBuilder</code></a> ä¸Šã€‚æ ¹æ® URL çš„æ ¼å¼ï¼Œè¯¥æ–¹æ³•ä¼šè‡ªåŠ¨ç¡®å®šè¿æ¥ç±»å‹ï¼ˆ<code>Http</code>ã€<code>Ws</code> æˆ– <code>Ipc</code>ï¼‰ã€‚å¦‚æœä½ éœ€è¦ä¸€ä¸ªè£…ç®±çš„ä¼ è¾“æ–¹æ³•ï¼Œè¯¥æ–¹æ³•ç‰¹åˆ«æœ‰ç”¨ã€‚</p>
<pre><code class="language-rust ignore">//! ä½¿ç”¨ `ProviderBuilder` ä¸Šçš„ `on_builtin` æ–¹æ³•åˆ›å»º HTTP æä¾›è€…çš„ç¤ºä¾‹ã€‚

use alloy::providers::{Provider, ProviderBuilder};
use eyre::Result;

#[tokio::main]
async fn main() -&gt; eyre::Result&lt;()&gt; {
    // ä½¿ç”¨ `reqwest` crate åˆ›å»ºä¸€ä¸ªå¸¦æœ‰ HTTP ä¼ è¾“çš„æä¾›è€…ã€‚
    let provider = ProviderBuilder::new().on_builtin("https://eth.merkle.io").await?;

    Ok(())
}</code></pre>
<!-- è¯·å‹¿ç¼–è¾‘æ­¤æ–‡ä»¶ã€‚å®ƒæ˜¯é€šè¿‡è¿è¡Œ `./scripts/update.sh` ç”Ÿæˆçš„ -->
<!-- å¯¹æ­¤æ–‡ä»¶çš„ä»»ä½•æ›´æ”¹éƒ½å°†è¢«è¦†ç›– -->
<!-- è¯·æ”¹ä¸ºç¼–è¾‘æˆ–åˆ›å»ºæ­¤æ¨¡æ¿: ./src/templates/providers/http.md -->
<!-- æœ€æ–°æ›´æ–°: https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="ç¤ºä¾‹-http"><a class="header" href="#ç¤ºä¾‹-http">ç¤ºä¾‹: <code>http</code></a></h2>
<h3 id="ç¤ºä¾‹-7"><a class="header" href="#ç¤ºä¾‹-7">ç¤ºä¾‹</a></h3>
<p>è¦è¿è¡Œæ­¤ç¤ºä¾‹ï¼š</p>
<ul>
<li>å…‹éš† <a href="https://github.com/alloy-rs/examples">examples</a> ä»“åº“: <code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>è¿è¡Œ: <code>cargo run --example http</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example of using the HTTP provider with the `reqwest` crate to get the latest block number.

use alloy::providers::{Provider, ProviderBuilder};
use eyre::Result;

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    // Set up the HTTP transport which is consumed by the RPC client.
    let rpc_url = "https://eth.merkle.io".parse()?;

    // Create a provider with the HTTP transport using the `reqwest` crate.
    let provider = ProviderBuilder::new().on_http(rpc_url);

    // Get latest block number.
    let latest_block = provider.get_block_number().await?;

    println!("Latest block number: {latest_block}");

    Ok(())
}</code></pre>
<p>åœ¨ Github ä¸Šæ‰¾åˆ°æºä»£ç  <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/providers/examples/http.rs">here</a>ã€‚</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="ws-provider"><a class="header" href="#ws-provider">WS <code>Provider</code></a></h2>
<p><code>Ws</code> æä¾›è€…ä¸èŠ‚ç‚¹å»ºç«‹ WebSocket è¿æ¥ï¼Œå…è®¸ä½ å‘é€ JSON-RPC è¯·æ±‚åˆ°èŠ‚ç‚¹ä»¥è·å–æ•°æ®ã€æ¨¡æ‹Ÿè°ƒç”¨ã€å‘é€äº¤æ˜“ç­‰åŠŸèƒ½ã€‚<code>Ws</code> æä¾›è€…å¯ä»¥ç”¨äºä»»ä½•æ”¯æŒ WebSocket è¿æ¥çš„ä»¥å¤ªåŠèŠ‚ç‚¹ã€‚è¿™ä½¿å¾—ç¨‹åºå¯ä»¥å®æ—¶ä¸ç½‘ç»œè¿›è¡Œäº¤äº’ï¼Œè€Œä¸éœ€è¦é€šè¿‡ HTTP è½®è¯¢æ¥è·å–è¯¸å¦‚æ–°åŒºå—å¤´å’Œè¿‡æ»¤æ—¥å¿—ä¹‹ç±»çš„ä¿¡æ¯ã€‚</p>
<h3 id="åˆå§‹åŒ–-ws-æä¾›è€…"><a class="header" href="#åˆå§‹åŒ–-ws-æä¾›è€…">åˆå§‹åŒ– <code>Ws</code> æä¾›è€…</a></h3>
<p>æ¨èçš„æ–¹æ³•æ˜¯ä½¿ç”¨ <a href="https://docs.rs/alloy/latest/alloy/providers/struct.ProviderBuilder.html" title="" target="_blank">
<code>ProviderBuilder</code></a> çš„ <a href="https://docs.rs/alloy/latest/alloy/providers/struct.ProviderBuilder.html#method.on_ws" title="" target="_blank">
<code>on_ws</code></a> æ–¹æ³•ä¸ <a href="https://docs.rs/alloy/latest/alloy/providers/struct.WsConnect.html" title="" target="_blank">
<code>WsConnect</code></a> é…ç½®æ¥åˆå§‹åŒ– <code>Ws</code> æä¾›è€…ã€‚</p>
<pre><code class="language-rust ignore">//! ä½¿ç”¨ `ProviderBuilder` çš„ `on_ws` æ–¹æ³•åˆ›å»ºä¸€ä¸ª WS æä¾›è€…çš„ç¤ºä¾‹ã€‚

use alloy::providers::{Provider, ProviderBuilder, WsConnect};
use eyre::Result;

#[tokio::main]
async fn main() -&gt; eyre::Result&lt;()&gt; {
    // è®¾ç½®ç”± RPC å®¢æˆ·ç«¯æ¶ˆè´¹çš„ WS ä¼ è¾“ã€‚
    let rpc_url = "wss://eth-mainnet.g.alchemy.com/v2/your-api-key";

    // åˆ›å»ºæä¾›è€…ã€‚
    let ws = WsConnect::new(rpc_url);
    let provider = ProviderBuilder::new().on_ws(ws).await?;

    Ok(())
}</code></pre>
<p>å¦ä¸€ç§åˆå§‹åŒ–æ–¹æ³•æ˜¯ä½¿ç”¨ <a href="https://docs.rs/alloy/latest/alloy/providers/struct.ProviderBuilder.html" title="" target="_blank">
<code>ProviderBuilder</code></a> çš„ <a href="https://docs.rs/alloy/latest/alloy/providers/struct.ProviderBuilder.html#method.on_builtin" title="" target="_blank">
<code>on_builtin</code></a> æ–¹æ³•ã€‚è¯¥æ–¹æ³•å°†æ ¹æ® URL çš„æ ¼å¼è‡ªåŠ¨ç¡®å®šè¿æ¥ç±»å‹ï¼ˆ<code>Http</code>ã€<code>Ws</code> æˆ– <code>Ipc</code>ï¼‰ã€‚å¦‚æœä½ éœ€è¦ä¸€ä¸ªå°è£…çš„ transportï¼Œè¿™ä¸ªæ–¹æ³•ç‰¹åˆ«æœ‰ç”¨ã€‚</p>
<pre><code class="language-rust ignore">//! ä½¿ç”¨ `ProviderBuilder` çš„ `on_builtin` æ–¹æ³•åˆ›å»ºä¸€ä¸ª WS æä¾›è€…çš„ç¤ºä¾‹ã€‚

use alloy::providers::{Provider, ProviderBuilder};
use eyre::Result;

#[tokio::main]
async fn main() -&gt; eyre::Result&lt;()&gt; {
    // ä½¿ç”¨ WS ä¼ è¾“åˆ›å»ºä¸€ä¸ªæä¾›è€…ã€‚
    let provider = ProviderBuilder::new().on_builtin("wss://eth-mainnet.g.alchemy.com/v2/your-api-key").await?;

    Ok(())
}</code></pre>
<p>ä¸å…¶ä»–æä¾›è€…ç±»ä¼¼ï¼Œä½ ä¹Ÿå¯ä»¥é€šè¿‡ WebSockets ä¸èŠ‚ç‚¹å»ºç«‹æˆæƒè¿æ¥ã€‚</p>
<!-- DO NOT EDIT THIS FILE. IT IS GENERATED BY RUNNING `./scripts/update.sh` -->
<!-- ANY CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN -->
<!-- EDIT OR CREATE THIS TEMPLATE INSTEAD: ./src/templates/providers/ws.md -->
<!-- LATEST UPDATE: https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="ç¤ºä¾‹-ws"><a class="header" href="#ç¤ºä¾‹-ws">ç¤ºä¾‹: <code>ws</code></a></h2>
<h3 id="ç¤ºä¾‹-8"><a class="header" href="#ç¤ºä¾‹-8">ç¤ºä¾‹</a></h3>
<p>è¦è¿è¡Œè¿™ä¸ªç¤ºä¾‹ï¼š</p>
<ul>
<li>å…‹éš† <a href="https://github.com/alloy-rs/examples">examples</a> ä»“åº“ï¼š<code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>è¿è¡Œï¼š<code>cargo run --example ws</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example of using the WS provider to subscribe to new blocks.

use alloy::providers::{Provider, ProviderBuilder, WsConnect};
use eyre::Result;
use futures_util::StreamExt;

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    // Set up the WS transport which is consumed by the RPC client.
    let rpc_url = "wss://eth-mainnet.g.alchemy.com/v2/your-api-key";

    // Create the provider.
    let ws = WsConnect::new(rpc_url);
    let provider = ProviderBuilder::new().on_ws(ws).await?;

    // Subscribe to new blocks.
    let sub = provider.subscribe_blocks().await?;

    // Wait and take the next 4 blocks.
    let mut stream = sub.into_stream().take(4);

    println!("Awaiting blocks...");

    // Take the stream and print the block number upon receiving a new block.
    let handle = tokio::spawn(async move {
        while let Some(block) = stream.next().await {
            println!(
                "Latest block number: {}",
                block.header.number.expect("Failed to get block number")
            );
        }
    });

    handle.await?;

    Ok(())
}</code></pre>
<p>åœ¨ Github ä¸Šæ‰¾åˆ°æºä»£ç  <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/providers/examples/ws.rs">è¿™é‡Œ</a>.</p>
<!-- DO NOT EDIT THIS FILE. IT IS GENERATED BY RUNNING `./scripts/update.sh` -->
<!-- ANY CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN -->
<!-- EDIT OR CREATE THIS TEMPLATE INSTEAD: ./src/templates/providers/ws_with_auth.md -->
<!-- LATEST UPDATE: https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="ç¤ºä¾‹ws_with_auth"><a class="header" href="#ç¤ºä¾‹ws_with_auth">ç¤ºä¾‹ï¼š<code>ws_with_auth</code></a></h2>
<h3 id="ç¤ºä¾‹-9"><a class="header" href="#ç¤ºä¾‹-9">ç¤ºä¾‹</a></h3>
<p>è¿è¡Œæ­¤ç¤ºä¾‹ï¼š</p>
<ul>
<li>å…‹éš† <a href="https://github.com/alloy-rs/examples">examples</a> ä»“åº“ï¼š<code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>è¿è¡Œï¼š<code>cargo run --example ws_with_auth</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example of using the WS provider with auth to subscribe to new blocks.

use alloy::{
    providers::{Provider, ProviderBuilder, WsConnect},
    transports::Authorization,
};
use eyre::Result;
use futures_util::StreamExt;

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    // Set up the WS transport which is consumed by the RPC client.
    let rpc_url = "wss://your-ws-endpoint.com/";

    // Create authorization methods.
    let auth = Authorization::basic("username", "password");
    let auth_bearer = Authorization::bearer("bearer-token");

    // Create the WS connection object with authentication.
    let ws_basic = WsConnect::with_auth(rpc_url, Some(auth));
    let ws_bearer = WsConnect::with_auth(rpc_url, Some(auth_bearer));

    // Create the provider.
    let provider_basic = ProviderBuilder::new().on_ws(ws_basic).await?;
    let provider_bearer = ProviderBuilder::new().on_ws(ws_bearer).await?;

    // Subscribe to new blocks.
    let sub_basic = provider_basic.subscribe_blocks();
    let sub_bearer = provider_bearer.subscribe_blocks();

    // Wait and take the next 4 blocks.
    let mut stream_basic = sub_basic.await?.into_stream().take(4);
    let mut stream_bearer = sub_bearer.await?.into_stream().take(4);

    println!("Awaiting blocks...");

    // Take the basic stream and print the block number upon receiving a new block.
    let basic_handle = tokio::spawn(async move {
        while let Some(block) = stream_basic.next().await {
            println!(
                "Latest block number (basic): {}",
                block.header.number.expect("Failed to get block number")
            );
        }
    });

    // Take the bearer stream and print the block number upon receiving a new block.
    let bearer_handle = tokio::spawn(async move {
        while let Some(block) = stream_bearer.next().await {
            println!(
                "Latest block number (bearer): {}",
                block.header.number.expect("Failed to get block number")
            );
        }
    });

    // Wait for both tasks to complete.
    let _ = tokio::try_join!(basic_handle, bearer_handle)?;

    Ok(())
}</code></pre>
<p>å¯ä»¥åœ¨ Github ä¸Šæ‰¾åˆ°æºç  <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/providers/examples/ws_with_auth.rs">here</a>ã€‚</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="ipc-provider"><a class="header" href="#ipc-provider">IPC <code>Provider</code></a></h2>
<p><a href="https://en.wikipedia.org/wiki/Inter-process_communication" title="" target="_blank">IPCï¼ˆè¿›ç¨‹é—´é€šä¿¡ï¼‰</a> ä¼ è¾“å…è®¸æˆ‘ä»¬çš„ç¨‹åºé€šè¿‡æœ¬åœ° <a href="https://en.wikipedia.org/wiki/Unix_domain_socket" title="" target="_blank">Unix åŸŸ socket</a> æˆ– <a href="https://learn.microsoft.com/en-us/windows/win32/ipc/named-pipes" title="" target="_blank">Windows å‘½åç®¡é“</a>ä¸ä¸€ä¸ªèŠ‚ç‚¹è¿›è¡Œé€šä¿¡ã€‚</p>
<p>ä½¿ç”¨ IPC ä¼ è¾“è®© ethers åº“å¯ä»¥å‘ Ethereum å®¢æˆ·ç«¯å‘é€ JSON-RPC è¯·æ±‚å¹¶æ¥æ”¶å“åº”ï¼Œè€Œæ— éœ€ç½‘ç»œè¿æ¥æˆ– HTTP æœåŠ¡å™¨ã€‚è¿™å¯¹äºä¸è¿è¡Œåœ¨åŒä¸€ç½‘ç»œä¸Šçš„æœ¬åœ° Ethereum èŠ‚ç‚¹è¿›è¡Œäº¤äº’éå¸¸æœ‰ç”¨ã€‚ä½¿ç”¨ IPC <a href="https://github.com/0xKitsune/geth-ipc-rpc-bench" title="" target="_blank">æ¯” RPC æ›´å¿«</a>ï¼Œä½†æ˜¯ä½ éœ€è¦èƒ½å¤Ÿè¿æ¥åˆ°ä¸€ä¸ªæœ¬åœ°èŠ‚ç‚¹ã€‚</p>
<h3 id="åˆå§‹åŒ–ä¸€ä¸ª-ipc-æä¾›è€…"><a class="header" href="#åˆå§‹åŒ–ä¸€ä¸ª-ipc-æä¾›è€…">åˆå§‹åŒ–ä¸€ä¸ª <code>Ipc</code> æä¾›è€…</a></h3>
<p>åˆå§‹åŒ– <code>Ipc</code> æä¾›è€…çš„æ¨èæ–¹å¼æ˜¯ä½¿ç”¨ <a href="https://docs.rs/alloy/latest/alloy/providers/struct.ProviderBuilder.html" title="" target="_blank">
<code>ProviderBuilder</code></a> ä¸Šçš„ <a href="https://docs.rs/alloy/latest/alloy/providers/struct.ProviderBuilder.html#method.on_ipc" title="" target="_blank">
<code>on_ipc</code></a> æ–¹æ³•ï¼Œå¹¶é…ç½® <a href="https://docs.rs/alloy/latest/alloy/providers/struct.IpcConnect.html" title="" target="_blank">
<code>IpcConnect</code></a>ã€‚</p>
<pre><code class="language-rust ignore">//! ä½¿ç”¨ `ProviderBuilder` ä¸Šçš„ `on_ipc` æ–¹æ³•åˆ›å»ºä¸€ä¸ª IPC æä¾›è€…çš„ç¤ºä¾‹ã€‚

use alloy::providers::{IpcConnect, Provider, ProviderBuilder};
use eyre::Result;

#[tokio::main]
async fn main() -&gt; eyre::Result&lt;()&gt; {
    // è®¾ç½®ç”± RPC å®¢æˆ·ç«¯ä½¿ç”¨çš„ IPC ä¼ è¾“ã€‚
    let ipc_path = "/tmp/reth.ipc";

    // åˆ›å»ºæä¾›è€…ã€‚
    let ipc = IpcConnect::new(ipc_path.to_string());
    let provider = ProviderBuilder::new().on_ipc(ipc).await?;

    Ok(())
}</code></pre>
<p>å¦ä¸€ç§åˆå§‹åŒ–æ–¹å¼æ˜¯ä½¿ç”¨ <a href="https://docs.rs/alloy/latest/alloy/providers/struct.ProviderBuilder.html" title="" target="_blank">
<code>ProviderBuilder</code></a> ä¸Šçš„ <a href="https://docs.rs/alloy/latest/alloy/providers/struct.ProviderBuilder.html#method.on_builtin" title="" target="_blank">
<code>on_builtin</code></a> æ–¹æ³•ã€‚æ­¤æ–¹æ³•ä¼šæ ¹æ® URL çš„æ ¼å¼è‡ªåŠ¨ç¡®å®šè¿æ¥ç±»å‹ï¼ˆ<code>Http</code>ã€<code>Ws</code> æˆ– <code>Ipc</code>ï¼‰ã€‚å¦‚æœä½ éœ€è¦ä¸€ä¸ªç›’è£…ä¼ è¾“ï¼Œæ­¤æ–¹æ³•ç‰¹åˆ«æœ‰ç”¨ã€‚</p>
<pre><code class="language-rust ignore">//! ä½¿ç”¨ `ProviderBuilder` ä¸Šçš„ `on_builtin` æ–¹æ³•åˆ›å»ºä¸€ä¸ª IPC æä¾›è€…çš„ç¤ºä¾‹ã€‚

use alloy::providers::{Provider, ProviderBuilder};
use eyre::Result;

#[tokio::main]
async fn main() -&gt; eyre::Result&lt;()&gt; {
    // ä½¿ç”¨ IPC ä¼ è¾“åˆ›å»ºæä¾›è€…ã€‚
    let provider = ProviderBuilder::new().on_builtin("/tmp/reth.ipc").await?;

    Ok(())
}</code></pre>
<!-- è¯·å‹¿ç¼–è¾‘æ­¤æ–‡ä»¶ã€‚å®ƒæ˜¯é€šè¿‡è¿è¡Œ `./scripts/update.sh` è‡ªåŠ¨ç”Ÿæˆçš„ -->
<!-- å¯¹è¯¥æ–‡ä»¶è¿›è¡Œçš„ä»»ä½•æ›´æ”¹éƒ½ä¼šè¢«è¦†ç›– -->
<!-- è¯·ç¼–è¾‘æˆ–åˆ›å»ºä»¥ä¸‹æ¨¡æ¿æ¥æ›¿ä»£ï¼š./src/templates/providers/ipc.md -->
<!-- æœ€æ–°æ›´æ–°ï¼š https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="ç¤ºä¾‹ipc"><a class="header" href="#ç¤ºä¾‹ipc">ç¤ºä¾‹ï¼š<code>ipc</code></a></h2>
<h3 id="ç¤ºä¾‹-10"><a class="header" href="#ç¤ºä¾‹-10">ç¤ºä¾‹</a></h3>
<p>è¿è¡Œæ­¤ç¤ºä¾‹ï¼š</p>
<ul>
<li>å…‹éš† <a href="https://github.com/alloy-rs/examples">examples</a> ä»“åº“: <code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>è¿è¡Œ: <code>cargo run --example ipc</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example of using the IPC provider to get the latest block number.

use alloy::providers::{IpcConnect, Provider, ProviderBuilder};
use eyre::Result;

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    // Set up the IPC transport which is consumed by the RPC client.
    let ipc_path = "/tmp/reth.ipc";

    // Create the provider.
    let ipc = IpcConnect::new(ipc_path.to_string());
    let provider = ProviderBuilder::new().on_ipc(ipc).await?;

    let latest_block = provider.get_block_number().await?;

    println!("Latest block: {latest_block}");

    Ok(())
}</code></pre>
<p>åœ¨ Github ä¸ŠæŸ¥çœ‹æºä»£ç  <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/providers/examples/ipc.rs">è¿™é‡Œ</a>ã€‚</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="ç†è§£-fillers"><a class="header" href="#ç†è§£-fillers">ç†è§£ <code>Fillers</code></a></h2>
<p><a href="https://docs.rs/alloy/latest/alloy/providers/fillers/index.html" title="" target="_blank">Fillers</a> è£…é¥°äº†ä¸€ä¸ª <a href="https://docs.rs/alloy/latest/alloy/providers/trait.Provider.html" title="" target="_blank">
<code>Provider</code></a>ï¼Œåœ¨äº¤æ˜“å‘é€åˆ°ç½‘ç»œä¹‹å‰å¡«å……äº¤æ˜“ç»†èŠ‚ã€‚Fillers ç”¨äºè®¾ç½® nonceã€gas ä»·æ ¼ã€gas é™åˆ¶å’Œå…¶ä»–äº¤æ˜“ç»†èŠ‚ï¼Œå®ƒä»¬åœ¨ä»»ä½•å…¶ä»–å±‚è°ƒç”¨ä¹‹å‰è¢«è°ƒç”¨ã€‚</p>
<!-- DO NOT EDIT THIS FILE. IT IS GENERATED BY RUNNING `./scripts/update.sh` -->
<!-- ANY CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN -->
<!-- EDIT OR CREATE THIS TEMPLATE INSTEAD: ./src/templates/fillers/recommended_fillers.md -->
<!-- LATEST UPDATE: https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="ç¤ºä¾‹-recommended_fillers"><a class="header" href="#ç¤ºä¾‹-recommended_fillers">ç¤ºä¾‹: <code>recommended_fillers</code></a></h2>
<h3 id="ç¤ºä¾‹-11"><a class="header" href="#ç¤ºä¾‹-11">ç¤ºä¾‹</a></h3>
<p>è¦è¿è¡Œè¿™ä¸ªç¤ºä¾‹:</p>
<ul>
<li>å…‹éš† <a href="https://github.com/alloy-rs/examples">examples</a> ä»“åº“: <code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>è¿è¡Œ: <code>cargo run --example recommended_fillers</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example of using the `.with_recommended_fillers()` method in the provider.

use alloy::{
    network::{EthereumWallet, TransactionBuilder},
    node_bindings::Anvil,
    primitives::{address, U256},
    providers::{Provider, ProviderBuilder},
    rpc::types::request::TransactionRequest,
    signers::local::PrivateKeySigner,
};
use eyre::Result;

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    // Spin up a local Anvil node.
    // Ensure `anvil` is available in $PATH.
    let anvil = Anvil::new().try_spawn()?;

    // Set up signer from the first default Anvil account (Alice).
    let signer: PrivateKeySigner = anvil.keys()[0].clone().into();
    let wallet = EthereumWallet::from(signer);

    // Create a provider with the wallet.
    let rpc_url = anvil.endpoint().parse()?;
    let provider = ProviderBuilder::new()
        // Adds the `ChainIdFiller`, `GasFiller` and the `NonceFiller` layers.
        .with_recommended_fillers()
        .wallet(wallet)
        .on_http(rpc_url);

    // Build an EIP-1559 type transaction to send 100 wei to Vitalik.
    // Notice that the `nonce` field is set by the `NonceFiller`.
    // Notice that the gas related fields are set by the `GasFiller`.
    // Notice that the `chain_id` field is set by the `ChainIdFiller`.
    let vitalik = address!("d8dA6BF26964aF9D7eEd9e03E53415D37aA96045");
    let tx = TransactionRequest::default().with_to(vitalik).with_value(U256::from(100));

    // Send the transaction, the nonce (0) is automatically managed by the provider.
    let builder = provider.send_transaction(tx.clone()).await?;
    let node_hash = *builder.tx_hash();
    let pending_tx =
        provider.get_transaction_by_hash(node_hash).await?.expect("Pending transaction not found");
    assert_eq!(pending_tx.nonce, 0);

    println!("Transaction sent with nonce: {}", pending_tx.nonce);

    // Send the transaction, the nonce (1) is automatically managed by the provider.
    let builder = provider.send_transaction(tx).await?;
    let node_hash = *builder.tx_hash();
    let pending_tx =
        provider.get_transaction_by_hash(node_hash).await?.expect("Pending transaction not found");
    assert_eq!(pending_tx.nonce, 1);

    println!("Transaction sent with nonce: {}", pending_tx.nonce);

    Ok(())
}</code></pre>
<p>åœ¨ Github ä¸Šæ‰¾åˆ°æºä»£ç  <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/fillers/examples/recommended_fillers.rs">here</a>.</p>
<!-- DO NOT EDIT THIS FILE. IT IS GENERATED BY RUNNING `./scripts/update.sh` -->
<!-- ANY CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN -->
<!-- EDIT OR CREATE THIS TEMPLATE INSTEAD: ./src/templates/fillers/gas_filler.md -->
<!-- LATEST UPDATE: https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="ç¤ºä¾‹gas_filler"><a class="header" href="#ç¤ºä¾‹gas_filler">ç¤ºä¾‹ï¼š<code>gas_filler</code></a></h2>
<h3 id="ç¤ºä¾‹-12"><a class="header" href="#ç¤ºä¾‹-12">ç¤ºä¾‹</a></h3>
<p>è¦è¿è¡Œæ­¤ç¤ºä¾‹ï¼š</p>
<ul>
<li>å…‹éš† <a href="https://github.com/alloy-rs/examples">examples</a> ä»“åº“ï¼š<code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>è¿è¡Œï¼š<code>cargo run --example gas_filler</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example of using the `GasFiller` in the provider.

use alloy::{
    network::{EthereumWallet, TransactionBuilder},
    node_bindings::Anvil,
    primitives::{address, U256},
    providers::{Provider, ProviderBuilder},
    rpc::types::request::TransactionRequest,
    signers::local::PrivateKeySigner,
};
use eyre::Result;

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    // Spin up a local Anvil node.
    // Ensure `anvil` is available in $PATH.
    let anvil = Anvil::new().try_spawn()?;

    // Set up signer from the first default Anvil account (Alice).
    let signer: PrivateKeySigner = anvil.keys()[0].clone().into();
    let wallet = EthereumWallet::from(signer);

    // Create a provider with the wallet.
    let rpc_url = anvil.endpoint().parse()?;
    let provider = ProviderBuilder::new()
        // Add the `GasFiller` to the provider.
        // It is generally recommended to use the `.with_recommended_fillers()` method, which
        // includes the `GasFiller`.
        .with_gas_estimation()
        .wallet(wallet)
        .on_http(rpc_url);

    // Build an EIP-1559 type transaction to send 100 wei to Vitalik.
    let vitalik = address!("d8dA6BF26964aF9D7eEd9e03E53415D37aA96045");
    let tx = TransactionRequest::default()
        .with_to(vitalik)
        .with_value(U256::from(100))
        // Notice that without the `NonceFiller`, you need to set `nonce` field.
        .with_nonce(0)
        // Notice that without the `ChainIdFiller`, you need to set the `chain_id` field.
        .with_chain_id(anvil.chain_id());

    // Send the transaction, the nonce (0) is automatically managed by the provider.
    let builder = provider.send_transaction(tx.clone()).await?;
    let node_hash = *builder.tx_hash();
    let pending_tx =
        provider.get_transaction_by_hash(node_hash).await?.expect("Pending transaction not found");
    assert_eq!(pending_tx.nonce, 0);

    println!("Transaction sent with nonce: {}", pending_tx.nonce);

    // Update the nonce and send the transaction again.
    let tx = tx.with_nonce(1);

    // Send the transaction, the nonce (1) is automatically managed by the provider.
    let builder = provider.send_transaction(tx).await?;
    let node_hash = *builder.tx_hash();
    let pending_tx =
        provider.get_transaction_by_hash(node_hash).await?.expect("Pending transaction not found");
    assert_eq!(pending_tx.nonce, 1);

    println!("Transaction sent with nonce: {}", pending_tx.nonce);

    Ok(())
}</code></pre>
<p>åœ¨ Github ä¸Šæ‰¾åˆ°æºä»£ç  <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/fillers/examples/gas_filler.rs">here</a>.</p>
<!-- DO NOT EDIT THIS FILE. IT IS GENERATED BY RUNNING `./scripts/update.sh` -->
<!-- ANY CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN -->
<!-- EDIT OR CREATE THIS TEMPLATE INSTEAD: ./src/templates/fillers/nonce_filler.md -->
<!-- LATEST UPDATE: https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="ç¤ºä¾‹-nonce_filler"><a class="header" href="#ç¤ºä¾‹-nonce_filler">ç¤ºä¾‹: <code>nonce_filler</code></a></h2>
<h3 id="ç¤ºä¾‹-13"><a class="header" href="#ç¤ºä¾‹-13">ç¤ºä¾‹</a></h3>
<p>è¿è¡Œæ­¤ç¤ºä¾‹:</p>
<ul>
<li>å…‹éš† <a href="https://github.com/alloy-rs/examples">examples</a> ä»“åº“: <code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>è¿è¡Œ: <code>cargo run --example nonce_filler</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example of using the `NonceFiller` in the provider.

use alloy::{
    network::{EthereumWallet, TransactionBuilder},
    node_bindings::Anvil,
    primitives::{address, U256},
    providers::{Provider, ProviderBuilder},
    rpc::types::request::TransactionRequest,
    signers::local::PrivateKeySigner,
};
use eyre::Result;

/// In Ethereum, the nonce of a transaction is a number that represents the number of transactions
/// that have been sent from a particular account. The nonce is used to ensure that transactions are
/// processed in the order they are intended, and to prevent the same transaction from being
/// processed multiple times.
///
/// The nonce manager in Alloy is a layer that helps you manage the nonce
/// of transactions by keeping track of the current nonce for a given account and automatically
/// incrementing it as needed. This can be useful if you want to ensure that transactions are sent
/// in the correct order, or if you want to avoid having to manually manage the nonce yourself.
#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    // Spin up a local Anvil node.
    // Ensure `anvil` is available in $PATH.
    let anvil = Anvil::new().try_spawn()?;

    // Set up signer from the first default Anvil account (Alice).
    let signer: PrivateKeySigner = anvil.keys()[0].clone().into();
    let wallet = EthereumWallet::from(signer);

    // Create a provider with the wallet.
    let rpc_url = anvil.endpoint().parse()?;
    let provider = ProviderBuilder::new()
        // Add the `NonceFiller` to the provider.
        // It is generally recommended to use the `.with_recommended_fillers()` method, which
        // includes the `NonceFiller`.
        .with_nonce_management()
        .wallet(wallet)
        .on_http(rpc_url);

    // Build an EIP-1559 type transaction to send 100 wei to Vitalik.
    let vitalik = address!("d8dA6BF26964aF9D7eEd9e03E53415D37aA96045");
    let tx = TransactionRequest::default()
        .with_to(vitalik)
        .with_value(U256::from(100))
        // Notice that without the `GasFiller`, you need to set the gas related fields.
        .with_gas_limit(21_000)
        .with_max_fee_per_gas(20_000_000_000)
        .with_max_priority_fee_per_gas(1_000_000_000)
        // Notice that without the `ChainIdFiller`, you need to set the `chain_id` field.
        .with_chain_id(anvil.chain_id());

    // Send the transaction, the nonce (0) is automatically managed by the provider.
    let builder = provider.send_transaction(tx.clone()).await?;
    let node_hash = *builder.tx_hash();
    let pending_tx =
        provider.get_transaction_by_hash(node_hash).await?.expect("Transaction not found");
    assert_eq!(pending_tx.nonce, 0);

    println!("Transaction sent with nonce: {}", pending_tx.nonce);

    // Send the transaction, the nonce (1) is automatically managed by the provider.
    let builder = provider.send_transaction(tx).await?;
    let node_hash = *builder.tx_hash();
    let pending_tx =
        provider.get_transaction_by_hash(node_hash).await?.expect("Transaction not found");
    assert_eq!(pending_tx.nonce, 1);

    println!("Transaction sent with nonce: {}", pending_tx.nonce);

    Ok(())
}</code></pre>
<p>åœ¨ Github ä¸ŠæŸ¥çœ‹æºä»£ç  <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/fillers/examples/nonce_filler.rs">æ­¤å¤„</a>.</p>
<!-- DO NOT EDIT THIS FILE. IT IS GENERATED BY RUNNING `./scripts/update.sh` -->
<!-- ANY CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN -->
<!-- EDIT OR CREATE THIS TEMPLATE INSTEAD: ./src/templates/fillers/wallet_filler.md -->
<!-- LATEST UPDATE: https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="ç¤ºä¾‹-wallet_filler"><a class="header" href="#ç¤ºä¾‹-wallet_filler">ç¤ºä¾‹: <code>wallet_filler</code></a></h2>
<h3 id="ç¤ºä¾‹-14"><a class="header" href="#ç¤ºä¾‹-14">ç¤ºä¾‹</a></h3>
<p>è¦è¿è¡Œæ­¤ç¤ºä¾‹ï¼š</p>
<ul>
<li>å…‹éš† <a href="https://github.com/alloy-rs/examples">examples</a> ä»“åº“ï¼š<code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>è¿è¡Œï¼š<code>cargo run --example wallet_filler</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example of using the `WalletFiller` in the provider.

use alloy::{
    network::{EthereumWallet, TransactionBuilder},
    node_bindings::Anvil,
    primitives::{address, b256, U256},
    providers::{Provider, ProviderBuilder},
    rpc::types::request::TransactionRequest,
    signers::local::PrivateKeySigner,
};
use eyre::Result;

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    // Spin up a local Anvil node.
    // Ensure `anvil` is available in $PATH.
    let anvil = Anvil::new().try_spawn()?;

    // Set up signer from the first default Anvil account (Alice).
    let signer: PrivateKeySigner = anvil.keys()[0].clone().into();
    let wallet = EthereumWallet::from(signer);

    // Create a provider with the wallet.
    let rpc_url = anvil.endpoint().parse()?;
    let provider = ProviderBuilder::new()
        // Add the `WalletFiller` to the provider
        .wallet(wallet)
        .on_http(rpc_url);

    // Build a legacy type transaction to send 100 wei to Vitalik.
    let vitalik = address!("d8dA6BF26964aF9D7eEd9e03E53415D37aA96045");
    let tx = TransactionRequest::default()
        .with_to(vitalik)
        .with_value(U256::from(100))
        // Notice that without the `NonceFiller`, you need to manually set the nonce field.
        .with_nonce(0)
        // Notice that without the `GasFiller`, you need to set the gas related fields.
        .with_gas_price(20_000_000_000)
        .with_gas_limit(21_000);

    let builder = provider.send_transaction(tx).await?;
    let node_hash = *builder.tx_hash();

    println!(
        "Node hash matches expected hash: {}",
        node_hash == b256!("eb56033eab0279c6e9b685a5ec55ea0ff8d06056b62b7f36974898d4fbb57e64")
    );

    // Send the transaction and wait for the broadcast.
    let pending_tx = builder.register().await?;

    println!("Pending transaction hash matches node hash: {}", *pending_tx.tx_hash() == node_hash);

    let tx_hash = pending_tx.await?;
    assert_eq!(tx_hash, node_hash);

    println!("Transaction hash matches node hash: {}", tx_hash == node_hash);

    // Wait for the transaction to be included and get the receipt.
    let receipt =
        provider.get_transaction_receipt(tx_hash).await?.expect("Transaction receipt not found");
    let receipt_hash = receipt.transaction_hash;
    assert_eq!(receipt_hash, node_hash);

    println!("Transaction receipt hash matches node hash: {}", receipt_hash == node_hash);

    Ok(())
}</code></pre>
<p>åœ¨ Github ä¸Šå¯ä»¥æ‰¾åˆ°æºä»£ç  <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/fillers/examples/wallet_filler.rs">here</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="æŸ¥è¯¢"><a class="header" href="#æŸ¥è¯¢">æŸ¥è¯¢</a></h2>
<!-- è¯·å‹¿ç¼–è¾‘æ­¤æ–‡ä»¶ã€‚å®ƒæ˜¯é€šè¿‡è¿è¡Œ `./scripts/update.sh` ç”Ÿæˆçš„ -->
<!-- å¯¹æ­¤æ–‡ä»¶æ‰€åšçš„ä»»ä½•æ›´æ”¹éƒ½å°†è¢«è¦†ç›– -->
<!-- è¯·ç¼–è¾‘æˆ–åˆ›å»ºè¿™ä¸ªæ¨¡æ¿: ./src/templates/queries/query_contract_storage.md -->
<!-- æœ€æ–°æ›´æ–°: https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="ç¤ºä¾‹query_contract_storage"><a class="header" href="#ç¤ºä¾‹query_contract_storage">ç¤ºä¾‹ï¼š<code>query_contract_storage</code></a></h2>
<h3 id="ç¤ºä¾‹-15"><a class="header" href="#ç¤ºä¾‹-15">ç¤ºä¾‹</a></h3>
<p>è¦è¿è¡Œæ­¤ç¤ºä¾‹ï¼š</p>
<ul>
<li>å…‹éš† <a href="https://github.com/alloy-rs/examples">examples</a> ä»“åº“: <code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>è¿è¡Œ: <code>cargo run --example query_contract_storage</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example of querying contract storage from the Ethereum network.

use alloy::{
    primitives::{address, U256},
    providers::{Provider, ProviderBuilder},
};
use eyre::Result;

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    // Create a provider.
    let rpc_url = "https://eth.merkle.io".parse()?;
    let provider = ProviderBuilder::new().on_http(rpc_url);

    // Get storage slot 0 from the Uniswap V3 USDC-ETH pool on Ethereum mainnet.
    let pool_address = address!("88e6A0c2dDD26FEEb64F039a2c41296FcB3f5640");
    let storage_slot = U256::from(0);
    // The provider calls the RPC at the latest block by default. A block can exlpicitly be set
    // using `.block()`.
    let storage = provider.get_storage_at(pool_address, storage_slot).await?;

    println!("Slot 0: {storage:?}");

    Ok(())
}</code></pre>
<p>åœ¨ Github ä¸ŠæŸ¥çœ‹æºä»£ç  <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/queries/examples/query_contract_storage.rs">æ­¤å¤„</a>.</p>
<!-- DO NOT EDIT THIS FILE. IT IS GENERATED BY RUNNING `./scripts/update.sh` -->
<!-- ANY CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN -->
<!-- EDIT OR CREATE THIS TEMPLATE INSTEAD: ./src/templates/queries/query_deployed_bytecode.md -->
<!-- LATEST UPDATE: https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="ç¤ºä¾‹query_deployed_bytecode"><a class="header" href="#ç¤ºä¾‹query_deployed_bytecode">ç¤ºä¾‹ï¼š<code>query_deployed_bytecode</code></a></h2>
<h3 id="ç¤ºä¾‹-16"><a class="header" href="#ç¤ºä¾‹-16">ç¤ºä¾‹</a></h3>
<p>è¿è¡Œæ­¤ç¤ºä¾‹:</p>
<ul>
<li>å…‹éš† <a href="https://github.com/alloy-rs/examples">examples</a> ä»“åº“: <code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>è¿è¡Œ: <code>cargo run --example query_deployed_bytecode</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example of querying deployed bytecode of a contract on the Ethereum network.

use alloy::{
    primitives::address,
    providers::{Provider, ProviderBuilder},
};
use eyre::Result;

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    // Create a provider.
    let rpc_url = "https://eth.merkle.io".parse()?;
    let provider = ProviderBuilder::new().on_http(rpc_url);

    // Get the bytecode of the Uniswap V3 USDC-ETH pool on Ethereum mainnet.
    let pool_address = address!("88e6A0c2dDD26FEEb64F039a2c41296FcB3f5640");
    let bytecode = provider.get_code_at(pool_address).await?;

    println!("Bytecode: {bytecode:?}");

    Ok(())
}</code></pre>
<p>åœ¨ Github ä¸Šæ‰¾åˆ°æºä»£ç  <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/queries/examples/query_deployed_bytecode.rs">here</a>.</p>
<!-- DO NOT EDIT THIS FILE. IT IS GENERATED BY RUNNING `./scripts/update.sh` -->
<!-- ANY CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN -->
<!-- EDIT OR CREATE THIS TEMPLATE INSTEAD: ./src/templates/queries/query_logs.md -->
<!-- LATEST UPDATE: https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="ç¤ºä¾‹-query_logs"><a class="header" href="#ç¤ºä¾‹-query_logs">ç¤ºä¾‹: <code>query_logs</code></a></h2>
<h3 id="ç¤ºä¾‹-17"><a class="header" href="#ç¤ºä¾‹-17">ç¤ºä¾‹</a></h3>
<p>è¦è¿è¡Œæ­¤ç¤ºä¾‹ï¼š</p>
<ul>
<li>å…‹éš† <a href="https://github.com/alloy-rs/examples">examples</a> ä»“åº“: <code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>è¿è¡Œ: <code>cargo run --example query_logs</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example of querying logs from the Ethereum network.

use alloy::{
    primitives::{address, b256},
    providers::{Provider, ProviderBuilder},
    rpc::types::Filter,
};
use eyre::Result;

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    // Create a provider.
    let rpc_url = "https://eth.merkle.io".parse()?;
    let provider = ProviderBuilder::new().on_http(rpc_url);

    // Get logs from the latest block
    let latest_block = provider.get_block_number().await?;

    // Create a filter to get all logs from the latest block.
    let filter = Filter::new().from_block(latest_block);

    // Get all logs from the latest block that match the filter.
    let logs = provider.get_logs(&amp;filter).await?;

    for log in logs {
        println!("{log:?}");
    }

    // Get all logs from the latest block that match the transfer event signature/topic.
    let transfer_event_signature =
        b256!("ddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef");
    let filter = Filter::new().event_signature(transfer_event_signature).from_block(latest_block);
    // You could also use the event name instead of the event signature like so:
    // .event("Transfer(address,address,uint256)")

    // Get all logs from the latest block that match the filter.
    let logs = provider.get_logs(&amp;filter).await?;

    for log in logs {
        println!("Transfer event: {log:?}");
    }

    // Get all logs from the latest block emitted by the UNI token address.
    let uniswap_token_address = address!("1f9840a85d5aF5bf1D1762F925BDADdC4201F984");
    let filter = Filter::new().address(uniswap_token_address).from_block(latest_block);

    // Get all logs from the latest block that match the filter.
    let logs = provider.get_logs(&amp;filter).await?;

    for log in logs {
        println!("Uniswap token logs: {log:?}");
    }

    Ok(())
}</code></pre>
<p>åœ¨ Github ä¸ŠæŸ¥çœ‹æºä»£ç  <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/queries/examples/query_logs.rs">here</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="äº¤æ˜“"><a class="header" href="#äº¤æ˜“">äº¤æ˜“</a></h1>
<ul>
<li><a href="building-with-alloy/transactions/using-the-transaction-builder.html">ä½¿ç”¨äº¤æ˜“æ„å»ºå™¨</a></li>
<li><a href="building-with-alloy/transactions/sending-an-EIP-1559-transaction.html">å‘é€ EIP-1559 äº¤æ˜“</a></li>
<li><a href="building-with-alloy/transactions/sending-a-legacy-transaction.html">å‘é€ä¼ ç»Ÿäº¤æ˜“</a></li>
<li><a href="building-with-alloy/transactions/sending-an-EIP-4844-transaction.html">å‘é€ EIP-4844 äº¤æ˜“</a></li>
<li><a href="building-with-alloy/transactions/using-access-lists.html">ä½¿ç”¨è®¿é—®åˆ—è¡¨</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="ä½¿ç”¨-transactionbuilder"><a class="header" href="#ä½¿ç”¨-transactionbuilder">ä½¿ç”¨ <code>TransactionBuilder</code></a></h2>
<a href="https://docs.rs/alloy/latest/alloy/network/trait.TransactionBuilder.html" title="" target="_blank">
`TransactionBuilder`</a> æ˜¯ä¸€ä¸ªç”¨äºç‰¹å®šç½‘ç»œçš„äº¤æ˜“æ„å»ºå™¨ï¼Œå¯é€šè¿‡ `.with_*` æ–¹æ³•è¿›è¡Œé…ç½®ã€‚
<p>å¸¸è§çš„å¯é…ç½®å­—æ®µåŒ…æ‹¬ï¼š</p>
<ul>
<li><a href="https://docs.rs/alloy/latest/alloy/network/trait.TransactionBuilder.html#method.with_from" title="" target="_blank">with_from</a></li>
<li><a href="https://docs.rs/alloy/latest/alloy/network/trait.TransactionBuilder.html#method.with_to" title="" target="_blank">with_to</a></li>
<li><a href="https://docs.rs/alloy/latest/alloy/network/trait.TransactionBuilder.html#method.with_nonce" title="" target="_blank">with_nonce</a></li>
<li><a href="https://docs.rs/alloy/latest/alloy/network/trait.TransactionBuilder.html#method.with_chain_id" title="" target="_blank">with_chain_id</a></li>
<li><a href="https://docs.rs/alloy/latest/alloy/network/trait.TransactionBuilder.html#method.with_value" title="" target="_blank">with_value</a></li>
<li><a href="https://docs.rs.alloy/latest/alloy/network/trait.TransactionBuilder.html#method.with_gas_limit" title="" target="_blank">with_gas_limit</a></li>
<li><a href="https://docs.rs/alloy/latest/alloy/network/trait.TransactionBuilder.html#method.with_max_priority_fee_per_gas" title="" target="_blank">with_max_priority_fee_per_gas</a></li>
<li><a href="https://docs.rs/alloy/latest/alloy/network/trait.TransactionBuilder.html#method.with_max_fee_per_blob_gas" title="" target="_blank">with_max_fee_per_gas</a></li>
</ul>
<p>é€šå¸¸æ¨èä½¿ç”¨æ„å»ºè€…æ¨¡å¼ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼Œè€Œä¸æ˜¯ç›´æ¥è®¾ç½®å€¼ï¼ˆç›¸æ¯”äº <code>set_to</code>ï¼Œä½¿ç”¨ <code>with_to</code>ï¼‰ã€‚</p>
<pre><code class="language-rust ignore">//! å±•ç¤ºå¦‚ä½•ä½¿ç”¨ `TransactionBuilder` æ„å»ºäº¤æ˜“çš„ç¤ºä¾‹

use alloy::{
    network::TransactionBuilder,
    node_bindings::Anvil,
    primitives::U256,
    providers::{Provider, ProviderBuilder},
    rpc::types::TransactionRequest,
};
use eyre::Result;

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    // Spin up a local Anvil node.
    // Ensure `anvil` is available in $PATH.
    let anvil = Anvil::new().try_spawn()?;

    // Create a provider.
    let rpc_url = anvil.endpoint().parse()?;
    let provider = ProviderBuilder::new().on_http(rpc_url);

    // Create two users, Alice and Bob.
    let alice = anvil.addresses()[0];
    let bob = anvil.addresses()[1];

    // Build a transaction to send 100 wei from Alice to Bob.
    // The `from` field is automatically filled to the first signer's address (Alice).
    let tx = TransactionRequest::default()
        .with_to(bob)
        .with_nonce(0)
        .with_chain_id(anvil.chain_id())
        .with_value(U256::from(100))
        .with_gas_limit(21_000)
        .with_max_priority_fee_per_gas(1_000_000_000)
        .with_max_fee_per_gas(20_000_000_000);

    // Send the transaction and wait for the broadcast.
    let pending_tx = provider.send_transaction(tx).await?;

    println!("Pending transaction... {}", pending_tx.tx_hash());

    // Wait for the transaction to be included and get the receipt.
    let receipt = pending_tx.get_receipt().await?;

    println!(
        "Transaction included in block {}",
        receipt.block_number.expect("Failed to get block number")
    );

    assert_eq!(receipt.from, alice);
    assert_eq!(receipt.to, Some(bob));

    Ok(())
}</code></pre>
<p>å»ºè®®åœ¨ <a href="building-with-alloy/transactions/../connecting-to-a-blockchain/setting-up-a-provider.html">ProviderBuilder</a> ä¸Šä½¿ç”¨ <code>.with_recommended_fillers()</code> æ–¹æ³•ï¼Œè¯¥æ–¹æ³•ä¼šè‡ªåŠ¨ä¸ºä½ <a href="building-with-alloy/transactions/../understanding-fillers.html">å¡«å……å­—æ®µ</a>ã€‚</p>
<!-- DO NOT EDIT THIS FILE. IT IS GENERATED BY RUNNING `./scripts/update.sh` -->
<!-- ANY CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN -->
<!-- EDIT OR CREATE THIS TEMPLATE INSTEAD: ./src/templates/fillers/recommended_fillers.md -->
<!-- LATEST UPDATE: https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="ç¤ºä¾‹-recommended_fillers-1"><a class="header" href="#ç¤ºä¾‹-recommended_fillers-1">ç¤ºä¾‹: <code>recommended_fillers</code></a></h2>
<h3 id="ç¤ºä¾‹-18"><a class="header" href="#ç¤ºä¾‹-18">ç¤ºä¾‹</a></h3>
<p>è¦è¿è¡Œè¿™ä¸ªç¤ºä¾‹:</p>
<ul>
<li>å…‹éš† <a href="https://github.com/alloy-rs/examples">examples</a> ä»“åº“: <code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>è¿è¡Œ: <code>cargo run --example recommended_fillers</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example of using the `.with_recommended_fillers()` method in the provider.

use alloy::{
    network::{EthereumWallet, TransactionBuilder},
    node_bindings::Anvil,
    primitives::{address, U256},
    providers::{Provider, ProviderBuilder},
    rpc::types::request::TransactionRequest,
    signers::local::PrivateKeySigner,
};
use eyre::Result;

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    // Spin up a local Anvil node.
    // Ensure `anvil` is available in $PATH.
    let anvil = Anvil::new().try_spawn()?;

    // Set up signer from the first default Anvil account (Alice).
    let signer: PrivateKeySigner = anvil.keys()[0].clone().into();
    let wallet = EthereumWallet::from(signer);

    // Create a provider with the wallet.
    let rpc_url = anvil.endpoint().parse()?;
    let provider = ProviderBuilder::new()
        // Adds the `ChainIdFiller`, `GasFiller` and the `NonceFiller` layers.
        .with_recommended_fillers()
        .wallet(wallet)
        .on_http(rpc_url);

    // Build an EIP-1559 type transaction to send 100 wei to Vitalik.
    // Notice that the `nonce` field is set by the `NonceFiller`.
    // Notice that the gas related fields are set by the `GasFiller`.
    // Notice that the `chain_id` field is set by the `ChainIdFiller`.
    let vitalik = address!("d8dA6BF26964aF9D7eEd9e03E53415D37aA96045");
    let tx = TransactionRequest::default().with_to(vitalik).with_value(U256::from(100));

    // Send the transaction, the nonce (0) is automatically managed by the provider.
    let builder = provider.send_transaction(tx.clone()).await?;
    let node_hash = *builder.tx_hash();
    let pending_tx =
        provider.get_transaction_by_hash(node_hash).await?.expect("Pending transaction not found");
    assert_eq!(pending_tx.nonce, 0);

    println!("Transaction sent with nonce: {}", pending_tx.nonce);

    // Send the transaction, the nonce (1) is automatically managed by the provider.
    let builder = provider.send_transaction(tx).await?;
    let node_hash = *builder.tx_hash();
    let pending_tx =
        provider.get_transaction_by_hash(node_hash).await?.expect("Pending transaction not found");
    assert_eq!(pending_tx.nonce, 1);

    println!("Transaction sent with nonce: {}", pending_tx.nonce);

    Ok(())
}</code></pre>
<p>åœ¨ Github ä¸Šæ‰¾åˆ°æºä»£ç  <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/fillers/examples/recommended_fillers.rs">here</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="å‘é€-eip-1559-äº¤æ˜“"><a class="header" href="#å‘é€-eip-1559-äº¤æ˜“">å‘é€ EIP-1559 äº¤æ˜“</a></h2>
<!-- DO NOT EDIT THIS FILE. IT IS GENERATED BY RUNNING `./scripts/update.sh` -->
<!-- ANY CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN -->
<!-- EDIT OR CREATE THIS TEMPLATE INSTEAD: ./src/templates/transactions/send_eip1559_transaction.md -->
<!-- LATEST UPDATE: https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="ç¤ºä¾‹-send_eip1559_transaction"><a class="header" href="#ç¤ºä¾‹-send_eip1559_transaction">ç¤ºä¾‹: <code>send_eip1559_transaction</code></a></h2>
<h3 id="ç¤ºä¾‹-19"><a class="header" href="#ç¤ºä¾‹-19">ç¤ºä¾‹</a></h3>
<p>è¦è¿è¡Œè¿™ä¸ªç¤ºä¾‹ï¼š</p>
<ul>
<li>å…‹éš† <a href="https://github.com/alloy-rs/examples">examples</a> ä»“åº“ï¼š<code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>è¿è¡Œï¼š<code>cargo run --example send_eip1559_transaction</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example showing how to send an [EIP-1559](https://eips.ethereum.org/EIPS/eip-1559) transaction.

use alloy::{
    network::TransactionBuilder,
    node_bindings::Anvil,
    primitives::U256,
    providers::{Provider, ProviderBuilder},
    rpc::types::TransactionRequest,
};
use eyre::Result;

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    // Spin up a local Anvil node.
    // Ensure `anvil` is available in $PATH.
    let anvil = Anvil::new().try_spawn()?;

    // Create a provider.
    let rpc_url = anvil.endpoint().parse()?;
    let provider = ProviderBuilder::new().on_http(rpc_url);

    // Create two users, Alice and Bob.
    let alice = anvil.addresses()[0];
    let bob = anvil.addresses()[1];

    // Build a transaction to send 100 wei from Alice to Bob.
    // The `from` field is automatically filled to the first signer's address (Alice).
    let tx = TransactionRequest::default()
        .with_to(bob)
        .with_nonce(0)
        .with_chain_id(anvil.chain_id())
        .with_value(U256::from(100))
        .with_gas_limit(21_000)
        .with_max_priority_fee_per_gas(1_000_000_000)
        .with_max_fee_per_gas(20_000_000_000);

    // Send the transaction and wait for the broadcast.
    let pending_tx = provider.send_transaction(tx).await?;

    println!("Pending transaction... {}", pending_tx.tx_hash());

    // Wait for the transaction to be included and get the receipt.
    let receipt = pending_tx.get_receipt().await?;

    println!(
        "Transaction included in block {}",
        receipt.block_number.expect("Failed to get block number")
    );

    assert_eq!(receipt.from, alice);
    assert_eq!(receipt.to, Some(bob));

    Ok(())
}</code></pre>
<p>åœ¨ Github ä¸Šå¯ä»¥æ‰¾åˆ°æºä»£ç  <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/transactions/examples/send_eip1559_transaction.rs">è¿™é‡Œ</a>ã€‚</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="å‘é€ä¼ ç»Ÿäº¤æ˜“"><a class="header" href="#å‘é€ä¼ ç»Ÿäº¤æ˜“">å‘é€ä¼ ç»Ÿäº¤æ˜“</a></h2>
<!-- DO NOT EDIT THIS FILE. IT IS GENERATED BY RUNNING `./scripts/update.sh` -->
<!-- ANY CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN -->
<!-- EDIT OR CREATE THIS TEMPLATE INSTEAD: ./src/templates/transactions/send_legacy_transaction.md -->
<!-- LATEST UPDATE: https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="ç¤ºä¾‹-send_legacy_transaction"><a class="header" href="#ç¤ºä¾‹-send_legacy_transaction">ç¤ºä¾‹: <code>send_legacy_transaction</code></a></h2>
<h3 id="ç¤ºä¾‹-20"><a class="header" href="#ç¤ºä¾‹-20">ç¤ºä¾‹</a></h3>
<p>è¦è¿è¡Œæ­¤ç¤ºä¾‹ï¼š</p>
<ul>
<li>å…‹éš† <a href="https://github.com/alloy-rs/examples">examples</a> ä»“åº“: <code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>è¿è¡Œ: <code>cargo run --example send_legacy_transaction</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example showing how to send a legacy transaction.

use alloy::{
    network::TransactionBuilder,
    node_bindings::Anvil,
    primitives::U256,
    providers::{Provider, ProviderBuilder},
    rpc::types::TransactionRequest,
};
use eyre::Result;

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    // Spin up a local Anvil node.
    // Ensure `anvil` is available in $PATH.
    let anvil = Anvil::new().try_spawn()?;

    // Create a provider.
    let rpc_url = anvil.endpoint().parse()?;
    let provider = ProviderBuilder::new().on_http(rpc_url);

    // Create two users, Alice and Bob.
    let alice = anvil.addresses()[0];
    let bob = anvil.addresses()[1];

    // Build a transaction to send 100 wei from Alice to Bob.
    // The `from` field is automatically filled to the first signer's address (Alice).
    let tx = TransactionRequest::default()
        .with_to(bob)
        .with_nonce(0)
        .with_value(U256::from(100))
        .with_gas_price(20_000_000_000)
        .with_gas_limit(21_000);

    // Send the transaction and wait for the broadcast.
    let pending_tx = provider.send_transaction(tx).await?;

    println!("Pending transaction... {}", pending_tx.tx_hash());

    // Wait for the transaction to be included and get the receipt.
    let receipt = pending_tx.get_receipt().await?;

    println!(
        "Transaction included in block {}",
        receipt.block_number.expect("Failed to get block number")
    );

    assert_eq!(receipt.from, alice);
    assert_eq!(receipt.to, Some(bob));

    Ok(())
}</code></pre>
<p>åœ¨ Github ä¸ŠæŸ¥çœ‹æºä»£ç  <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/transactions/examples/send_legacy_transaction.rs">è¿™é‡Œ</a>ã€‚</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="å‘é€-eip-4844-äº¤æ˜“"><a class="header" href="#å‘é€-eip-4844-äº¤æ˜“">å‘é€ EIP-4844 äº¤æ˜“</a></h2>
<!-- DO NOT EDIT THIS FILE. IT IS GENERATED BY RUNNING `./scripts/update.sh` -->
<!-- ANY CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN -->
<!-- EDIT OR CREATE THIS TEMPLATE INSTEAD: ./src/templates/transactions/send_eip4844_transaction.md -->
<!-- LATEST UPDATE: https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="ç¤ºä¾‹-send_eip4844_transaction"><a class="header" href="#ç¤ºä¾‹-send_eip4844_transaction">ç¤ºä¾‹: <code>send_eip4844_transaction</code></a></h2>
<h3 id="ç¤ºä¾‹-21"><a class="header" href="#ç¤ºä¾‹-21">ç¤ºä¾‹</a></h3>
<p>è¿è¡Œæ­¤ç¤ºä¾‹:</p>
<ul>
<li>å…‹éš† <a href="https://github.com/alloy-rs/examples">examples</a> ä»“åº“: <code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>è¿è¡Œ: <code>cargo run --example send_eip4844_transaction</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example showing how to send an [EIP-4844](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-4844.md) transaction.

use alloy::{
    consensus::{SidecarBuilder, SimpleCoder},
    eips::eip4844::DATA_GAS_PER_BLOB,
    network::TransactionBuilder,
    node_bindings::Anvil,
    providers::{Provider, ProviderBuilder},
    rpc::types::TransactionRequest,
};
use eyre::Result;

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    // Spin up a local Anvil node with the Cancun hardfork enabled.
    // Ensure `anvil` is available in $PATH.
    let anvil = Anvil::new().args(["--hardfork", "cancun"]).try_spawn()?;

    // Create a provider.
    let provider = ProviderBuilder::new().on_builtin(&amp;anvil.endpoint()).await?;

    // Create two users, Alice and Bob.
    let alice = anvil.addresses()[0];
    let bob = anvil.addresses()[1];

    // Create a sidecar with some data.
    let sidecar: SidecarBuilder&lt;SimpleCoder&gt; = SidecarBuilder::from_slice(b"Blobs are fun!");
    let sidecar = sidecar.build()?;

    // Build a transaction to send the sidecar from Alice to Bob.
    // The `from` field is automatically filled to the first signer's address (Alice).
    let gas_price = provider.get_gas_price().await?;
    let eip1559_est = provider.estimate_eip1559_fees(None).await?;
    let tx = TransactionRequest::default()
        .with_to(bob)
        .with_nonce(0)
        .with_max_fee_per_blob_gas(gas_price)
        .with_max_fee_per_gas(eip1559_est.max_fee_per_gas)
        .with_max_priority_fee_per_gas(eip1559_est.max_priority_fee_per_gas)
        .with_blob_sidecar(sidecar);

    // Send the transaction and wait for the broadcast.
    let pending_tx = provider.send_transaction(tx).await?;

    println!("Pending transaction... {}", pending_tx.tx_hash());

    // Wait for the transaction to be included and get the receipt.
    let receipt = pending_tx.get_receipt().await?;

    println!(
        "Transaction included in block {}",
        receipt.block_number.expect("Failed to get block number")
    );

    assert_eq!(receipt.from, alice);
    assert_eq!(receipt.to, Some(bob));
    assert_eq!(
        receipt.blob_gas_used.expect("Expected to be EIP-4844 transaction"),
        DATA_GAS_PER_BLOB as u128
    );

    Ok(())
}</code></pre>
<p>åœ¨ Github ä¸Šå¯ä»¥æ‰¾åˆ°æºç  <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/transactions/examples/send_eip4844_transaction.rs">è¿™é‡Œ</a>ã€‚</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="ä½¿ç”¨è®¿é—®åˆ—è¡¨"><a class="header" href="#ä½¿ç”¨è®¿é—®åˆ—è¡¨">ä½¿ç”¨è®¿é—®åˆ—è¡¨</a></h2>
<!-- DO NOT EDIT THIS FILE. IT IS GENERATED BY RUNNING `./scripts/update.sh` -->
<!-- ANY CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN -->
<!-- EDIT OR CREATE THIS TEMPLATE INSTEAD: ./src/templates/transactions/with_access_list.md -->
<!-- LATEST UPDATE: https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="ç¤ºä¾‹-with_access_list"><a class="header" href="#ç¤ºä¾‹-with_access_list">ç¤ºä¾‹: <code>with_access_list</code></a></h2>
<h3 id="ç¤ºä¾‹-22"><a class="header" href="#ç¤ºä¾‹-22">ç¤ºä¾‹</a></h3>
<p>è¿è¡Œæœ¬ç¤ºä¾‹ï¼š</p>
<ul>
<li>å…‹éš† <a href="https://github.com/alloy-rs/examples">examples</a> ä»“åº“: <code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>è¿è¡Œ: <code>cargo run --example with_access_list</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example of sending a EIP-1559 transaction with access list.

use alloy::{
    node_bindings::Anvil,
    providers::{Provider, ProviderBuilder},
    rpc::types::TransactionRequest,
    sol,
};
use eyre::Result;

// Codegen from artifact.
sol!(
    #[allow(missing_docs)]
    #[sol(rpc)]
    SimpleStorage,
    "examples/artifacts/SimpleStorage.json"
);

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    // Spin up a local Anvil node.
    // Ensure `anvil` is available in $PATH.
    let anvil = Anvil::new().try_spawn()?;

    // Create a provider.
    let provider =
        ProviderBuilder::new().with_recommended_fillers().on_builtin(&amp;anvil.endpoint()).await?;

    // Deploy the `SimpleStorage` contract.
    let alice = anvil.addresses()[0];
    let contract_address = SimpleStorage::deploy_builder(provider.clone(), "initial".to_string())
        .from(alice)
        .deploy()
        .await?;
    let contract = SimpleStorage::new(contract_address, provider.clone());

    // Build a transaction to set the values of the contract.
    // The `from` field is automatically filled to the first signer's address (Alice).
    let set_value_call = contract.setValues("hello".to_string(), "world".to_string());
    let calldata = set_value_call.calldata().to_owned();
    let bob = anvil.addresses()[1];
    let tx = TransactionRequest::default().from(bob).to(contract_address).input(calldata.into());

    // Create an access list for the transaction.
    let access_list_with_gas_used = provider.create_access_list(&amp;tx).await?;

    // Add the access list to the transaction.
    let tx_with_access_list = tx.access_list(access_list_with_gas_used.access_list);

    // Send the transaction with the access list.
    let tx_hash = provider.send_transaction(tx_with_access_list).await?.watch().await?;

    println!("Transaction hash: {tx_hash}");

    // Check the value of the contract.
    let value = contract.getValue().call().await?;

    assert_eq!(value._0, "hello".to_string());

    Ok(())
}</code></pre>
<p>åœ¨ Github ä¸ŠæŸ¥çœ‹æºç  <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/transactions/examples/with_access_list.rs">here</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="sol-è¿‡ç¨‹å®"><a class="header" href="#sol-è¿‡ç¨‹å®"><code>sol!</code> è¿‡ç¨‹å®</a></h2>
<p><code>sol!</code> è¿‡ç¨‹å®è§£æ Solidity è¯­æ³•ä»¥ç”Ÿæˆå®ç°äº† <a href="https://github.com/alloy-rs/core/tree/main/crates/sol-types" title="" target="_blank">alloy-sol-types</a> ç‰¹æ€§çš„ç±»å‹ã€‚å®ƒä½¿ç”¨ <a href="https://github.com/alloy-rs/core/tree/main/crates/syn-solidity" title="" target="_blank">
<code>syn-solidity</code></a>ï¼Œä¸€ä¸ªåŸºäº <a href="https://github.com/dtolnay/syn" title="" target="_blank">syn</a> çš„ Solidity è§£æå™¨ã€‚å®ƒæ—¨åœ¨æ¨¡ä»¿å®˜æ–¹ Solidity ç¼–è¯‘å™¨ (<code>solc</code>) åœ¨è§£ææœ‰æ•ˆ Solidity ä»£ç æ—¶çš„è¡Œä¸ºã€‚è¿™æ„å‘³ç€æ‰€æœ‰ <code>solc</code> <code>0.5.0</code> åŠä»¥ä¸Šç‰ˆæœ¬è®¤å¯çš„æœ‰æ•ˆ Solidity ä»£ç éƒ½è¢«æ”¯æŒã€‚</p>
<p>åœ¨æœ€åŸºæœ¬çš„å½¢å¼ä¸‹ï¼Œ<code>sol!</code> æ˜¯è¿™æ ·ä½¿ç”¨çš„ï¼š</p>
<pre><code class="language-rust ignore">use alloy::{primitives::U256, sol};

// ç”¨æ ‡å‡† Solidity å£°æ˜ä¸€ä¸ª Solidity ç±»å‹
sol! {
    struct Foo {
        uint256 bar;
        bool baz;
    }
}

// ä¸€ä¸ªå¯¹åº”çš„ Rust ç»“æ„ä½“è¢«ç”Ÿæˆäº†ï¼

// pub struct Foo {
//     pub bar: Uint&lt;256, 4&gt;,
//     pub baz: bool,
// }

let foo = Foo { bar: U256::from(42), baz: true };</code></pre>
<h3 id="ä½¿ç”¨æ–¹æ³•"><a class="header" href="#ä½¿ç”¨æ–¹æ³•">ä½¿ç”¨æ–¹æ³•</a></h3>
<p>æœ‰å¤šç§ä½¿ç”¨ <code>sol!</code> å®çš„æ–¹æ³•ã€‚</p>
<p>ä½ å¯ä»¥ç›´æ¥ç¼–å†™ Solidity ä»£ç ï¼š</p>
<pre><code class="language-rust ignore">sol! {
    contract Counter {
        uint256 public number;

        function setNumber(uint256 newNumber) public {
            number = newNumber;
        }

        function increment() public {
            number++;
        }
    }
}</code></pre>
<p>æˆ–è€…æä¾›ä¸€ä¸ª Solidity æ–‡ä»¶çš„è·¯å¾„ï¼š</p>
<pre><code class="language-rust ignore">sol!(
    #[sol(rpc)]
    Counter,
    "artifacts/Counter.json"
);</code></pre>
<p>å¦å¤–ï¼Œå¦‚æœä½ å¯ç”¨äº† <code>json</code> ç‰¹æ€§æ ‡å¿—ï¼Œä½ å¯ä»¥æä¾›ä¸€ä¸ª ABIï¼Œæˆ–è€…æ˜¯ä¸€ä¸ª JSON æ ¼å¼çš„è·¯å¾„ï¼š</p>
<pre><code class="language-rust ignore">sol!(
   ICounter,
   r#"[
        {
            "type": "function",
            "name": "increment",
            "inputs": [],
            "outputs": [],
            "stateMutability": "nonpayable"
        },
        {
            "type": "function",
            "name": "number",
            "inputs": [],
            "outputs": [
                {
                    "name": "",
                    "type": "uint256",
                    "internalType": "uint256"
                }
            ],
            "stateMutability": "view"
        },
        {
            "type": "function",
            "name": "setNumber",
            "inputs": [
                {
                    "name": "newNumber",
                    "type": "uint256",
                    "internalType": "uint256"
                }
            ],
            "outputs": [],
            "stateMutability": "nonpayable"
        }
   ]"#
);</code></pre>
<p>è¿™ä¸ä»¥ä¸‹å†…å®¹ç›¸åŒï¼š</p>
<pre><code class="language-rust ignore">sol! {
    interface ICounter {
        uint256 public number;

        function setNumber(uint256 newNumber);

        function increment();
    }
}</code></pre>
<p>å¦å¤–ï¼Œä½ ä¹Ÿå¯ä»¥é€šè¿‡æ–‡ä»¶åŠ è½½ä¸€ä¸ª ABIï¼š</p>
<pre><code class="language-rust ignore">sol!(
    ICounter,
    "abi/Counter.json"
);</code></pre>
<p>ä½ ä¹Ÿå¯ä»¥ç›´æ¥ä½¿ç”¨å‡½æ•°ï¼š</p>
<pre><code class="language-rust ignore">sol!(
    function swapExactTokensForTokens(
        uint256 amountIn,
        uint256 amountOutMin,
        address[] calldata path,
        address to,
        uint256 deadline
      ) external returns (uint256[] memory amounts);
);

println!("è§£ç  https://etherscan.io/tx/0xd1b449d8b1552156957309bffb988924569de34fbf21b51e7af31070cc80fe9a");

let input = hex::decode("0x38ed173900000000000000000000000000000000000000000001a717cc0a3e4f84c00000000000000000000000000000000000000000000000000000000000000283568400000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000201f129111c60401630932d9f9811bd5b5fff34e000000000000000000000000000000000000000000000000000000006227723d000000000000000000000000000000000000000000000000000000000000000200000000000000000000000095ad61b0a150d79219dcf64e1e6cc01f0b64c4ce000000000000000000000000dac17f958d2ee523a2206206994597c13d831ec7")?;

// ä½¿ç”¨ç”Ÿæˆçš„ `swapExactTokensForTokens` ç»‘å®šè§£ç è¾“å…¥ã€‚
let decoded = swapExactTokensForTokensCall::abi_decode(&amp;input, false);</code></pre>
<h3 id="å±æ€§"><a class="header" href="#å±æ€§">å±æ€§</a></h3>
<p>ç»“åˆ <code>sol!</code> å®çš„ <code>#[sol(rpc)]</code> å±æ€§ï¼Œ<a href="https://docs.rs/alloy/latest/alloy/contract/struct.CallBuilder.html" title="" target="_blank">
<code>CallBuilder</code></a> å¯ä»¥ç”¨æ¥ä¸é“¾ä¸Šåˆçº¦è¿›è¡Œäº¤äº’ã€‚<code>#[sol(rpc)]</code> å±æ€§ä¸ºåˆçº¦ä¸­çš„æ¯ä¸ªå‡½æ•°ç”Ÿæˆä¸€ä¸ªæ–¹æ³•ï¼Œè¯¥æ–¹æ³•è¿”å›è¯¥å‡½æ•°çš„ <code>CallBuilder</code>ã€‚</p>
<p>å¦‚æœæä¾›äº† <code>#[sol(bytecode = "0x...")]</code>ï¼Œåˆçº¦å¯ä»¥é€šè¿‡ <code>Counter::deploy</code> éƒ¨ç½²ï¼Œå¹¶ä¼šåˆ›å»ºä¸€ä¸ªæ–°å®ä¾‹ã€‚</p>
<pre><code class="language-rust ignore">//! ç¤ºä¾‹å±•ç¤ºå¦‚ä½•ä½¿ç”¨ `#[sol(rpc)]` å’Œ #[sol(bytecode = "0x...")] å±æ€§
//! interacting with it.

use alloy::{
    network::EthereumWallet, node_bindings::Anvil, primitives::U256, providers::ProviderBuilder,
    signers::local::PrivateKeySigner, sol,
};
use eyre::Result;

// Codegen from embedded Solidity code and precompiled bytecode.
sol! {
    #[allow(missing_docs)]
    // solc v0.8.26; solc Counter.sol --via-ir --optimize --bin
    #[sol(rpc, bytecode="6080806040523460135760df908160198239f35b600080fdfe6080806040526004361015601257600080fd5b60003560e01c9081633fb5c1cb1460925781638381f58a146079575063d09de08a14603c57600080fd5b3460745760003660031901126074576000546000198114605e57600101600055005b634e487b7160e01b600052601160045260246000fd5b600080fd5b3460745760003660031901126074576020906000548152f35b34607457602036600319011260745760043560005500fea2646970667358221220e978270883b7baed10810c4079c941512e93a7ba1cd1108c781d4bc738d9090564736f6c634300081a0033")]
    contract Counter {
        uint256 public number;

        function setNumber(uint256 newNumber) public {
            number = newNumber;
        }

        function increment() public {
            number++;
        }
    }
}

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    // Spin up a local Anvil node.
    // Ensure `anvil` is available in $PATH.
    let anvil = Anvil::new().try_spawn()?;

    // Set up signer from the first default Anvil account (Alice).
    let signer: PrivateKeySigner = anvil.keys()[0].clone().into();
    let wallet = EthereumWallet::from(signer);

    // Create a provider with the wallet.
    let rpc_url = anvil.endpoint().parse()?;
    let provider =
        ProviderBuilder::new().with_recommended_fillers().wallet(wallet).on_http(rpc_url);

    println!("Anvil running at `{}`", anvil.endpoint());

    // Deploy the `Counter` contract.
    let contract = Counter::deploy(&amp;provider).await?;

    println!("Deployed contract at address: {}", contract.address());

    let builder = contract.setNumber(U256::from(42));
    let tx_hash = builder.send().await?.watch().await?;

    println!("Set number to 42: {tx_hash}");

    // Increment the number to 43.
    let builder = contract.increment();
    let tx_hash = builder.send().await?.watch().await?;

    println!("Incremented number: {tx_hash}");

    // Retrieve the number, which should be 43.
    let builder = contract.number();
    let number = builder.call().await?.number.to_string();

    println!("Retrieved number: {number}");

    Ok(())
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="äº¤æ˜“ç”Ÿå‘½å‘¨æœŸ"><a class="header" href="#äº¤æ˜“ç”Ÿå‘½å‘¨æœŸ">äº¤æ˜“ç”Ÿå‘½å‘¨æœŸ</a></h2>
<p>æœ¬æ–‡å°†å¸¦ä½ äº†è§£å°† <code>100 wei</code> ä» <code>Alice</code> å‘é€åˆ° <code>Bob</code> çš„äº¤æ˜“å®šä¹‰è¿‡ç¨‹ï¼Œç­¾ç½²äº¤æ˜“å¹¶å¹¿æ’­å·²ç­¾ç½²çš„äº¤æ˜“åˆ°ä»¥å¤ªåŠç½‘ç»œã€‚</p>
<p>è®©æˆ‘ä»¬ä»¥<a href="https://docs.rs/alloy/latest/alloy/rpc/types/eth/struct.TransactionRequest.html" title="" target="_blank">
<code>TransactionRequest</code></a>çš„å½¢å¼è¡¨è¾¾æˆ‘ä»¬çš„æ„å›¾:</p>
<pre><code class="language-rust ignore">// æ„å»ºä¸€ä¸ªä» Alice å‘é€ 100 wei åˆ° Bob çš„äº¤æ˜“ã€‚
let tx = TransactionRequest::default()
    .with_from(alice)
    .with_to(bob)
    .with_nonce(nonce)
    .with_chain_id(chain_id)
    .with_value(U256::from(100))
    .with_gas_price(gas_price)
    .with_gas_limit(gas_limit);</code></pre>
<h3 id="è®¾ç½®"><a class="header" href="#è®¾ç½®">è®¾ç½®</a></h3>
<p>é¦–å…ˆæˆ‘ä»¬å°†è®¾ç½®æˆ‘ä»¬çš„ç¯å¢ƒ:</p>
<p>æˆ‘ä»¬å…ˆå®šä¹‰æœ¬åœ°ä»¥å¤ªåŠèŠ‚ç‚¹ <a href="https://github.com/foundry-rs/foundry/tree/master/crates/anvil" title="" target="_blank">Anvil</a> çš„ RPC URLã€‚
å¦‚æœä½ æ²¡æœ‰å®‰è£… <code>Anvil</code>ï¼Œè¯·å‚é˜… <a href="https://github.com/foundry-rs/foundry" title="" target="_blank">Foundry</a> çš„ <a href="https://book.getfoundry.sh/getting-started/installation" title="" target="_blank">å®‰è£…æŒ‡å—</a>ã€‚</p>
<pre><code class="language-rust ignore">// å¯åŠ¨ä¸€ä¸ªæœ¬åœ° Anvil èŠ‚ç‚¹ã€‚
// ç¡®ä¿ `anvil` åœ¨ $PATH ä¸­å¯ç”¨ã€‚
let anvil = Anvil::new().try_spawn()?;

// è·å– RPC URLã€‚
let rpc_url = anvil.endpoint().parse()?;</code></pre>
<pre><code class="language-rust ignore">// æˆ–è€…ä½ ä¹Ÿå¯ä»¥ä½¿ç”¨ https://chainlist.org/ ä¸Šçš„ä»»ä½•æœ‰æ•ˆ RPC URLã€‚
let rpc_url = "https://eth.merkle.io".parse()?;</code></pre>
<p>æ¥ä¸‹æ¥è®©æˆ‘ä»¬ä¸º Alice å®šä¹‰ä¸€ä¸ª <code>signer</code>ã€‚é»˜è®¤æƒ…å†µä¸‹ï¼Œ<code>Anvil</code> å®šä¹‰äº†ä¸€ä¸ªåŠ©è®°è¯ï¼šâ€œtest test test test test test test test test test test junkâ€ã€‚ç¡®ä¿ä¸è¦åœ¨æµ‹è¯•ç¯å¢ƒå¤–ä½¿ç”¨è¿™ä¸ªåŠ©è®°è¯ã€‚æˆ‘ä»¬å°†åœ¨ <a href="https://docs.rs/alloy/latest/alloy/network/struct.EthereumWallet.html" title="" target="_blank">
<code>EthereumWallet</code></a> ä¸­æ³¨å†Œè¿™ä¸ª signerï¼Œä»¥ä¾¿åœ¨ <code>Provider</code> ä¸­ç­¾ç½²æˆ‘ä»¬æœªæ¥çš„äº¤æ˜“ã€‚</p>
<p>æ´¾ç”Ÿè¿™ä¸ªåŠ©è®°è¯çš„ç¬¬ä¸€ä¸ªå¯†é’¥ç»™ Aliceï¼š</p>
<pre><code class="language-rust ignore">// è®¾ç½® signer æ¥è‡ª Anvil çš„ç¬¬ä¸€ä¸ªé»˜è®¤è´¦æˆ·ï¼ˆAliceï¼‰ã€‚
let signer: PrivateKeySigner = anvil.keys()[0].clone().into();
let wallet = EthereumWallet::from(signer);</code></pre>
<p>æ¥ä¸‹æ¥è®©æˆ‘ä»¬è·å–ç”¨æˆ· <code>Alice</code> å’Œ <code>Bob</code> çš„åœ°å€ï¼š</p>
<pre><code class="language-rust ignore">// åˆ›å»ºä¸¤ä¸ªç”¨æˆ·ï¼ŒAlice å’Œ Bobã€‚
let alice = anvil.addresses()[0];
let bob = anvil.addresses()[1];</code></pre>
<p>æ¥ä¸‹æ¥æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ <a href="https://docs.rs/alloy/latest/alloy/providers/struct.ProviderBuilder.html" title="" target="_blank">
<code>ProviderBuilder</code></a> æ¥æ„å»º <a href="https://docs.rs/alloy/latest/alloy/providers/trait.Provider.html" title="" target="_blank">
<code>Provider</code></a>ã€‚</p>
<pre><code class="language-rust ignore">// ä½¿ç”¨é’±åŒ…åˆ›å»ºä¸€ä¸ª providerã€‚
let provider = ProviderBuilder::new()
    .with_recommended_fillers()
    .wallet(wallet)
    .on_http(rpc_url);</code></pre>
<p>æ³¨æ„æˆ‘ä»¬åœ¨ <a href="highlights/../building-with-alloy/connecting-to-a-blockchain/setting-up-a-provider.html">ProviderBuilder</a> ä¸Šä½¿ç”¨äº† <code>.with_recommended_fillers()</code> æ–¹æ³•æ¥è‡ªåŠ¨<a href="highlights/../building-with-alloy/understanding-fillers.html">å¡«å……å­—æ®µ</a>ã€‚</p>
<p>è®©æˆ‘ä»¬ä¿®æ”¹åŸæ¥çš„ <code>TransactionRequest</code>ï¼Œä»¥ä¾¿ä½¿ç”¨å®‰è£…åœ¨ <code>Provider</code> ä¸Šçš„ <a href="https://docs.rs/alloy/latest/alloy/providers/fillers/type.RecommendedFiller.html" title="" target="_blank">RecommendedFiller</a> è‡ªåŠ¨å¡«å†™äº¤æ˜“è¯¦æƒ…ã€‚</p>
<p><code>RecommendedFillers</code> åŒ…æ‹¬ä»¥ä¸‹å¡«å……å™¨ï¼š</p>
<ul>
<li><a href="https://docs.rs/alloy/latest/alloy/providers/fillers/struct.GasFiller.html" title="" target="_blank">GasFiller</a></li>
<li><a href="https://docs.rs/alloy/latest/alloy/providers/fillers/struct.NonceFiller.html" title="" target="_blank">NonceFiller</a></li>
<li><a href="https://docs.rs/alloy/latest/alloy/providers/fillers/struct.ChainIdFiller.html" title="" target="_blank">ChainIdFiller</a></li>
</ul>
<p>å› ä¸ºæˆ‘ä»¬ä½¿ç”¨äº† <code>RecommendedFillers</code>ï¼Œæˆ‘ä»¬çš„ <code>TransactionRequest</code> åªéœ€è¦ä½¿ç”¨åŸå­—æ®µçš„å­é›†ï¼š</p>
<pre><code class="language-diff">// æ„å»ºä¸€ä¸ªä» Alice å‘é€ 100 wei åˆ° Bob çš„äº¤æ˜“ã€‚
let tx = TransactionRequest::default()
-   .with_from(alice)
    .with_to(bob)
-   .with_nonce(nonce)
-   .with_chain_id(chain_id)
    .with_value(U256::from(100))
-   .with_gas_price(gas_price)
-   .with_gas_limit(gas_limit);
</code></pre>
<p>å˜ä¸ºï¼š</p>
<pre><code class="language-rust ignore">// æ„å»ºä¸€ä¸ªä» Alice å‘é€ 100 wei åˆ° Bob çš„äº¤æ˜“ã€‚
// `from` å­—æ®µè‡ªåŠ¨å¡«å……ä¸ºç¬¬ä¸€ä¸ª signer's åœ°å€ï¼ˆAliceï¼‰ã€‚
let tx = TransactionRequest::default()
    .with_to(bob)
    .with_value(U256::from(100));</code></pre>
<p>å¥½å¤šå•¦ï¼</p>
<h3 id="ç­¾ç½²å¹¶å¹¿æ’­äº¤æ˜“"><a class="header" href="#ç­¾ç½²å¹¶å¹¿æ’­äº¤æ˜“">ç­¾ç½²å¹¶å¹¿æ’­äº¤æ˜“</a></h3>
<p>é‰´äºæˆ‘ä»¬åœ¨ <code>Provider</code> ä¸Šé…ç½®äº†ä¸€ä¸ª signerï¼Œæˆ‘ä»¬å¯ä»¥åœ¨æœ¬åœ°ç­¾ç½²äº¤æ˜“å¹¶åœ¨ä¸€è¡Œä¸­å¹¿æ’­ï¼š</p>
<p>å¹¿æ’­äº¤æ˜“åæœ‰ä¸‰ç§æ–¹æ³•ç›‘å¬äº¤æ˜“çš„åŒ…å«ï¼Œå…·ä½“å–å†³äºä½ çš„éœ€æ±‚ï¼š</p>
<pre><code class="language-rust ignore">// å‘é€äº¤æ˜“å¹¶ç›‘å¬äº¤æ˜“è¢«å¹¿æ’­ã€‚
let pending_tx = provider.send_transaction(tx).await?.register().await?;</code></pre>
<pre><code class="language-rust ignore">// å‘é€äº¤æ˜“å¹¶ç›‘å¬äº¤æ˜“è¢«åŒ…å«ã€‚
let tx_hash = provider.send_transaction(tx).await?.watch().await?;</code></pre>
<pre><code class="language-rust ignore">// å‘é€äº¤æ˜“å¹¶åœ¨äº¤æ˜“è¢«åŒ…å«åè·å–æ”¶æ®ã€‚
let tx_receipt = provider.send_transaction(tx).await?.get_receipt().await?;</code></pre>
<p>è®©æˆ‘ä»¬æ·±å…¥äº†è§£æˆ‘ä»¬åˆšåˆšåšçš„äº‹æƒ…ã€‚</p>
<p>é€šè¿‡è°ƒç”¨ï¼š</p>
<pre><code class="language-rust ignore">let tx_builder = provider.send_transaction(tx).await?;</code></pre>
<a href="https://docs.rs/alloy/latest/alloy/providers/trait.Provider.html#method.send_transaction" title="" target="_blank">
`Provider::send_transaction`</a> æ–¹æ³•è¿”å›ä¸€ä¸ªç”¨äºé…ç½®ç­‰å¾…äº¤æ˜“çš„ <a href="https://docs.rs/alloy/latest/alloy/providers/struct.PendingTransactionBuilder.html" title="" target="_blank">
`PendingTransactionBuilder`</a>ã€‚
<p>æˆ‘ä»¬å¯ä»¥åœ¨å®ƒä¸Šé¢ï¼Œä¾‹å¦‚ï¼Œè®¾ç½® <a href="https://docs.rs.alloy/latest/alloy/providers/struct.PendingTransactionBuilder.html#method.set_required_confirmations" title="" target="_blank">
<code>required_confirmations</code></a> æˆ–è€…è®¾ç½® <a href="https://docs.rs/alloy/latest/alloy/providers/struct.PendingTransactionBuilder.html#method.set_timeout" title="" target="_blank">
<code>timeout</code></a>ï¼š</p>
<pre><code class="language-rust ignore">// é…ç½®ç­‰å¾…äº¤æ˜“ã€‚
let pending_tx_builder = provider.send_transaction(tx)
    .await?
    .with_required_confirmations(2)
    .with_timeout(Some(std::time::Duration::from_secs(60)));</code></pre>
<p>é€šè¿‡ä¼ é€’ <code>TransactionRequest</code>ï¼Œæˆ‘ä»¬å¡«å……ä»»ä½•ç¼ºå¤±çš„å­—æ®µã€‚è¿™æ¶‰åŠå¡«å†™ç»†èŠ‚å¦‚ nonceã€é“¾ IDã€gas ä»·æ ¼å’Œ gas é™åˆ¶ï¼š</p>
<pre><code class="language-diff">// æ„å»ºä¸€ä¸ªä» Alice å‘é€ 100 wei åˆ° Bob çš„äº¤æ˜“ã€‚
let tx = TransactionRequest::default()
+   .with_from(alice)
    .with_to(bob)
+   .with_nonce(nonce)
+   .with_chain_id(chain_id)
    .with_value(U256::from(100))
+   .with_gas_price(gas_price)
+   .with_gas_limit(gas_limit);
</code></pre>
<p>ä½œä¸º <code>Provider</code> ä¸Šæ³¨å†Œçš„ <a href="https://docs.rs/alloy/latest/alloy/providers/fillers/trait.TxFiller.html#tymethod.fill" title="" target="_blank">é’±åŒ…çš„ <code>fill</code> æ–¹æ³•</a> çš„ä¸€éƒ¨åˆ†ï¼Œæˆ‘ä»¬ä½¿ç”¨ Alice çš„ç­¾åå™¨ä»å¡«å……çš„ <code>TransactionRequest</code> ä¸­æ„å»ºä¸€ä¸ªå·²ç­¾åçš„äº¤æ˜“ã€‚</p>
<p>æ­¤æ—¶ï¼Œ<code>TransactionRequest</code> å˜æˆä¸€ä¸ª <code>TransactionEnvelope</code>ï¼Œå‡†å¤‡å‘é€åˆ°ç½‘ç»œã€‚é€šè¿‡è°ƒç”¨ <a href="https://docs.rs/alloy/latest/alloy/providers/struct.PendingTransactionBuilder.html#method.register" title="" target="_blank">
<code>register</code></a>, <a href="https://docs.rs/alloy/latest/alloy/providers/struct.PendingTransactionBuilder.html#method.watch" title="" target="_blank">
<code>watch</code></a> æˆ– <a href="https://docs.rs/alloy/latest/alloy/providers/struct.PendingTransactionBuilder.html#method.get_receipt" title="" target="_blank">
<code>get_receipt</code></a>ï¼Œæˆ‘ä»¬å¯ä»¥å¹¿æ’­äº¤æ˜“å¹¶è·Ÿè¸ªäº¤æ˜“çŠ¶æ€ã€‚</p>
<p>ä¾‹å¦‚ï¼š</p>
<pre><code class="language-rust ignore">// å‘é€äº¤æ˜“å¹¶åœ¨äº¤æ˜“è¢«åŒ…å«åè·å–æ”¶æ®ã€‚
let tx_receipt = provider.send_transaction(tx).await?.get_receipt().await?;</code></pre>
<a href="https://docs.rs/alloy/latest/alloy/rpc/types/struct.TransactionReceipt.html" title="" target="_blank">
`TransactionReceipt`</a> æä¾›äº†äº¤æ˜“çš„å®Œæ•´è®°å½•å’Œç»“æœï¼ŒåŒ…æ‹¬äº¤æ˜“å“ˆå¸Œã€åŒºå—è¯¦æƒ…ã€ä½¿ç”¨çš„ gas ä»¥åŠæ¶‰åŠçš„åœ°å€ã€‚
<pre><code class="language-rust ignore">pub struct TransactionReceipt {
    // ...

    /// äº¤æ˜“å“ˆå¸Œã€‚
    pub transaction_hash: TxHash,

    /// åœ¨åŒºå—ä¸­çš„ç´¢å¼•ã€‚
    pub transaction_index: Option&lt;TxIndex&gt;,

    /// åŒ…å«æ­¤äº¤æ˜“çš„åŒºå—å“ˆå¸Œã€‚
    pub block_hash: Option&lt;BlockHash&gt;,

    /// åŒ…å«æ­¤äº¤æ˜“çš„åŒºå—å·ã€‚
    pub block_number: Option&lt;BlockNumber&gt;,

    /// ä»…æ­¤äº¤æ˜“ä½¿ç”¨çš„ gasã€‚
    pub gas_used: u128,

    /// å‘é€è€…åœ°å€ã€‚
    pub from: Address,

    /// æ¥æ”¶è€…åœ°å€ã€‚å¦‚æœæ˜¯åˆçº¦åˆ›å»ºäº¤æ˜“åˆ™ä¸º Noneã€‚
    pub to: Option&lt;Address&gt;,

    /// åˆ›å»ºçš„åˆçº¦åœ°å€ï¼Œè‹¥ä¸æ˜¯éƒ¨ç½²åˆ™ä¸º Noneã€‚
    pub contract_address: Option&lt;Address&gt;,

    // ...
}</code></pre>
<p>è¿™å°±å®Œæˆäº†å¹¿æ’­å·²ç­¾ç½²äº¤æ˜“çš„æ—…ç¨‹ã€‚ä¸€æ—¦äº¤æ˜“è¢«åŒ…å«åœ¨åŒºå—ä¸­ï¼Œå®ƒå°±æˆä¸ºä»¥å¤ªåŠåŒºå—é“¾çš„ä¸€ä¸ªä¸å¯æ”¹å˜çš„éƒ¨åˆ†ï¼Œç¡®ä¿ <code>100 wei</code> ä» <code>Alice</code> è½¬ç§»åˆ° <code>Bob</code> çš„è®°å½•æ°¸ä¹…å­˜åœ¨ã€‚</p>
<h2 id="ç»¼åˆèµ·æ¥"><a class="header" href="#ç»¼åˆèµ·æ¥">ç»¼åˆèµ·æ¥</a></h2>
<pre><code class="language-rust ignore">//! Example of how to transfer ETH from one account to another.

use alloy::{
    network::{EthereumWallet, TransactionBuilder},
    node_bindings::Anvil,
    primitives::U256,
    providers::{Provider, ProviderBuilder},
    rpc::types::TransactionRequest,
    signers::local::PrivateKeySigner,
};
use eyre::Result;

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    // Spin up a local Anvil node.
    // Ensure `anvil` is available in $PATH.
    let anvil = Anvil::new().try_spawn()?;

    // Get the RPC URL.
    let rpc_url = anvil.endpoint().parse()?;

    // Set up signer from the first default Anvil account (Alice).
    let signer: PrivateKeySigner = anvil.keys()[0].clone().into();
    let wallet = EthereumWallet::from(signer);

    // Create a provider with the wallet.
    let provider =
        ProviderBuilder::new().with_recommended_fillers().wallet(wallet).on_http(rpc_url);

    // Build a transaction to send 100 wei from Alice to Bob.
    // The `from` field is automatically filled to the first signer's address (Alice).
    let bob = anvil.addresses()[1];
    let tx = TransactionRequest::default().with_to(bob).with_value(U256::from(100));

    // Send the transaction and listen for the transaction to be included.
    let tx_hash = provider.send_transaction(tx).await?.watch().await?;

    println!("Sent transaction: {tx_hash}");

    Ok(())
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="anvil"><a class="header" href="#anvil">Anvil</a></h2>
<ul>
<li><a href="examples/anvil/deploy_contract_anvil.html">éƒ¨ç½²åˆçº¦</a></li>
<li><a href="examples/anvil/fork_anvil.html">åˆ†å‰</a></li>
<li><a href="examples/anvil/local_anvil.html">æœ¬åœ°</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><!-- DO NOT EDIT THIS FILE. IT IS GENERATED BY RUNNING `./scripts/update.sh` -->
<!-- ANY CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN -->
<!-- EDIT OR CREATE THIS TEMPLATE INSTEAD: ./src/templates/anvil/deploy_contract_anvil.md -->
<!-- LATEST UPDATE: https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="ç¤ºä¾‹-deploy_contract_anvil"><a class="header" href="#ç¤ºä¾‹-deploy_contract_anvil">ç¤ºä¾‹: <code>deploy_contract_anvil</code></a></h2>
<h3 id="ç¤ºä¾‹-23"><a class="header" href="#ç¤ºä¾‹-23">ç¤ºä¾‹</a></h3>
<p>è¦è¿è¡Œè¿™ä¸ªç¤ºä¾‹:</p>
<ul>
<li>å…‹éš† <a href="https://github.com/alloy-rs/examples" title="" target="_blank">examples</a> ä»“åº“: <code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>è¿è¡Œ: <code>cargo run --example deploy_contract_anvil</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example of deploying a contract to Anvil and interacting with it.

use alloy::{
    network::EthereumWallet, node_bindings::Anvil, primitives::U256, providers::ProviderBuilder,
    signers::local::PrivateKeySigner, sol,
};
use eyre::Result;

// Codegen from embedded Solidity code and precompiled bytecode.
sol! {
    #[allow(missing_docs)]
    // solc v0.8.26; solc Counter.sol --via-ir --optimize --bin
    #[sol(rpc, bytecode="6080806040523460135760df908160198239f35b600080fdfe6080806040526004361015601257600080fd5b60003560e01c9081633fb5c1cb1460925781638381f58a146079575063d09de08a14603c57600080fd5b3460745760003660031901126074576000546000198114605e57600101600055005b634e487b7160e01b600052601160045260246000fd5b600080fd5b3460745760003660031901126074576020906000548152f35b34607457602036600319011260745760043560005500fea2646970667358221220e978270883b7baed10810c4079c941512e93a7ba1cd1108c781d4bc738d9090564736f6c634300081a0033")]
    contract Counter {
        uint256 public number;

        function setNumber(uint256 newNumber) public {
            number = newNumber;
        }

        function increment() public {
            number++;
        }
    }
}

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    // Spin up a local Anvil node.
    // Ensure `anvil` is available in $PATH.
    let anvil = Anvil::new().try_spawn()?;

    // Set up signer from the first default Anvil account (Alice).
    let signer: PrivateKeySigner = anvil.keys()[0].clone().into();
    let wallet = EthereumWallet::from(signer);

    // Create a provider with the wallet.
    let rpc_url = anvil.endpoint().parse()?;
    let provider =
        ProviderBuilder::new().with_recommended_fillers().wallet(wallet).on_http(rpc_url);

    println!("Anvil running at `{}`", anvil.endpoint());

    // Deploy the `Counter` contract.
    let contract = Counter::deploy(&amp;provider).await?;

    println!("Deployed contract at address: {}", contract.address());

    // Set the number to 42.
    let builder = contract.setNumber(U256::from(42));
    let tx_hash = builder.send().await?.watch().await?;

    println!("Set number to 42: {tx_hash}");

    // Increment the number to 43.
    let builder = contract.increment();
    let tx_hash = builder.send().await?.watch().await?;

    println!("Incremented number: {tx_hash}");

    // Retrieve the number, which should be 43.
    let builder = contract.number();
    let number = builder.call().await?.number.to_string();

    println!("Retrieved number: {number}");

    Ok(())
}</code></pre>
<p>å¯ä»¥åœ¨ Github ä¸Šçš„<a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/anvil/examples/deploy_contract_anvil.rs" title="" target="_blank">è¿™é‡Œ</a>æ‰¾åˆ°æºç ã€‚</p>
<div style="break-before: page; page-break-before: always;"></div><!-- DO NOT EDIT THIS FILE. IT IS GENERATED BY RUNNING `./scripts/update.sh` -->
<!-- ANY CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN -->
<!-- EDIT OR CREATE THIS TEMPLATE INSTEAD: ./src/templates/anvil/fork_anvil.md -->
<!-- LATEST UPDATE: https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="ç¤ºä¾‹-fork_anvil"><a class="header" href="#ç¤ºä¾‹-fork_anvil">ç¤ºä¾‹: <code>fork_anvil</code></a></h2>
<h3 id="ç¤ºä¾‹-24"><a class="header" href="#ç¤ºä¾‹-24">ç¤ºä¾‹</a></h3>
<p>è¦è¿è¡Œæ­¤ç¤ºä¾‹ï¼š</p>
<ul>
<li>å…‹éš†<a href="https://github.com/alloy-rs/examples" title="" target="_blank">examples</a> ä»“åº“: <code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>è¿è¡Œ: <code>cargo run --example fork_anvil</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example of spinning up a forked Anvil node.

use alloy::node_bindings::Anvil;
use eyre::Result;

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    // Spin up a forked Anvil node.
    // Ensure `anvil` is available in $PATH.
    let anvil = Anvil::new().fork("https://eth.merkle.io").try_spawn()?;

    println!("Anvil running at `{}`", anvil.endpoint());

    Ok(())
}</code></pre>
<p>åœ¨ Github ä¸ŠæŸ¥çœ‹æºä»£ç <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/anvil/examples/fork_anvil.rs" title="" target="_blank">è¿™é‡Œ</a>ã€‚</p>
<div style="break-before: page; page-break-before: always;"></div><!-- DO NOT EDIT THIS FILE. IT IS GENERATED BY RUNNING `./scripts/update.sh` -->
<!-- ANY CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN -->
<!-- EDIT OR CREATE THIS TEMPLATE INSTEAD: ./src/templates/anvil/local_anvil.md -->
<!-- LATEST UPDATE: https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="ç¤ºä¾‹-local_anvil"><a class="header" href="#ç¤ºä¾‹-local_anvil">ç¤ºä¾‹: <code>local_anvil</code></a></h2>
<h3 id="ç¤ºä¾‹-25"><a class="header" href="#ç¤ºä¾‹-25">ç¤ºä¾‹</a></h3>
<p>è¦è¿è¡Œæ­¤ç¤ºä¾‹:</p>
<ul>
<li>å…‹éš† <a href="https://github.com/alloy-rs/examples" title="" target="_blank">examples</a> ä»“åº“: <code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>è¿è¡Œ: <code>cargo run --example local_anvil</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example of spinning up a local Anvil node.

use alloy::node_bindings::Anvil;
use eyre::Result;

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    // Spin up a local Anvil node.
    // Ensure `anvil` is available in $PATH.
    let anvil = Anvil::new().block_time(1).chain_id(1337).try_spawn()?;

    println!("Anvil running at `{}`", anvil.endpoint());

    Ok(())
}</code></pre>
<p>åœ¨ Github ä¸Šå¯ä»¥æ‰¾åˆ°æºç  <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/anvil/examples/local_anvil.rs" title="" target="_blank">here</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="å¤§æ•°"><a class="header" href="#å¤§æ•°">å¤§æ•°</a></h2>
<ul>
<li><a href="examples/big-numbers/comparison_equivalence.html">æ¯”è¾ƒå’Œç­‰ä»·</a></li>
<li><a href="examples/big-numbers/conversion.html">ç±»å‹è½¬æ¢</a></li>
<li><a href="examples/big-numbers/create_instances.html">å®ä¾‹åˆ›å»º</a></li>
<li><a href="examples/big-numbers/math_operations.html">æ•°å­¦è¿ç®—</a></li>
<li><a href="examples/big-numbers/math_utilities.html">æ•°å­¦å·¥å…·</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><!-- è¯·ä¸è¦ç¼–è¾‘æ­¤æ–‡ä»¶ã€‚å®ƒæ˜¯é€šè¿‡è¿è¡Œ `./scripts/update.sh` ç”Ÿæˆçš„ -->
<!-- å¯¹æ­¤æ–‡ä»¶åšçš„ä»»ä½•æ›´æ”¹éƒ½ä¼šè¢«è¦†ç›– -->
<!-- è¯·æ”¹ç¼–è¾‘æˆ–åˆ›å»ºè¿™ä¸ªæ¨¡æ¿ï¼š./src/templates/big-numbers/comparison_equivalence.md -->
<!-- æœ€æ–°æ›´æ–°ï¼š https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="ç¤ºä¾‹comparison_equivalence-1"><a class="header" href="#ç¤ºä¾‹comparison_equivalence-1">ç¤ºä¾‹ï¼š<code>comparison_equivalence</code></a></h2>
<h3 id="ç¤ºä¾‹-26"><a class="header" href="#ç¤ºä¾‹-26">ç¤ºä¾‹</a></h3>
<p>è¦è¿è¡Œæ­¤ç¤ºä¾‹ï¼š</p>
<ul>
<li>å…‹éš† <a href="https://github.com/alloy-rs/examples" title="" target="_blank">examples</a> ä»“åº“ï¼š<code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>è¿è¡Œï¼š<code>cargo run --example comparison_equivalence</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example of comparison and equivalence of `U256` instances.

use alloy::primitives::U256;

/// `U256` implements traits in `std::cmp`, that means `U256` instances
/// can be easily compared using standard Rust operators.
fn main() {
    // a == b
    let a = U256::from(100_u32);
    let b = U256::from(100_u32);
    assert!(a == b);

    // a &lt; b
    let a = U256::from(1_u32);
    let b = U256::from(100_u32);
    assert!(a &lt; b);

    // a &lt;= b
    let a = U256::from(100_u32);
    let b = U256::from(100_u32);
    assert!(a &lt;= b);

    // a &gt; b
    let a = U256::from(100_u32);
    let b = U256::from(1_u32);
    assert!(a &gt; b);

    // a &gt;= b
    let a = U256::from(100_u32);
    let b = U256::from(100_u32);
    assert!(a &gt;= b);

    // a == 0
    let a = U256::ZERO;
    assert!(a.is_zero());
}</code></pre>
<p>åœ¨ Github ä¸Šå¯ä»¥æ‰¾åˆ°æºç ï¼š<a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/big-numbers/examples/comparison_equivalence.rs" title="" target="_blank">è¿™é‡Œ</a>ã€‚</p>
<div style="break-before: page; page-break-before: always;"></div><!-- DO NOT EDIT THIS FILE. IT IS GENERATED BY RUNNING `./scripts/update.sh` -->
<!-- ANY CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN -->
<!-- EDIT OR CREATE THIS TEMPLATE INSTEAD: ./src/templates/big-numbers/conversion.md -->
<!-- LATEST UPDATE: https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="ç¤ºä¾‹-conversion-1"><a class="header" href="#ç¤ºä¾‹-conversion-1">ç¤ºä¾‹: <code>conversion</code></a></h2>
<h3 id="ç¤ºä¾‹-27"><a class="header" href="#ç¤ºä¾‹-27">ç¤ºä¾‹</a></h3>
<p>è¿è¡Œè¿™ä¸ªç¤ºä¾‹:</p>
<ul>
<li>å…‹éš† <a href="https://github.com/alloy-rs/examples" title="" target="_blank">examples</a> ä»“åº“: <code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>è¿è¡Œ: <code>cargo run --example conversion</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example of converting `U256` to native Rust types.

use alloy::primitives::{utils::format_units, U256};
use eyre::Result;

/// `U256` provides useful conversion functions to enable transformation into native Rust types.
///
/// It is important to note that converting a big-number to a floating point type (such as a `f32`
/// or `f64`) can result in a loss of precision, since you cannot fit 256 bits of information into
/// 64 bits.
///
/// However, there may be cases where you want to perform conversions for presentation purposes.
/// For example, you may want to display a large number to the user in a more readable format.
fn main() -&gt; Result&lt;()&gt; {
    let num = U256::from(42_u8);

    let a: u128 = num.to::&lt;u128&gt;();
    assert_eq!(a, 42);

    let b: u64 = num.to::&lt;u64&gt;();
    assert_eq!(b, 42);

    let c: u32 = num.to::&lt;u32&gt;();
    assert_eq!(c, 42);

    let d: usize = num.to::&lt;usize&gt;();
    assert_eq!(d, 42);

    let e: String = num.to_string();
    assert_eq!(e, "42");

    let f: String = format_units(num, 4)?;
    assert_eq!(f, "0.0042");

    Ok(())
}</code></pre>
<p>åœ¨ Github ä¸Šæ‰¾åˆ°æºä»£ç  <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/big-numbers/examples/conversion.rs" title="" target="_blank">here</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><!-- DO NOT EDIT THIS FILE. IT IS GENERATED BY RUNNING `./scripts/update.sh` -->
<!-- ANY CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN -->
<!-- EDIT OR CREATE THIS TEMPLATE INSTEAD: ./src/templates/big-numbers/create_instances.md -->
<!-- LATEST UPDATE: https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="ç¤ºä¾‹-create_instances-1"><a class="header" href="#ç¤ºä¾‹-create_instances-1">ç¤ºä¾‹: <code>create_instances</code></a></h2>
<h3 id="ä¾‹å­-1"><a class="header" href="#ä¾‹å­-1">ä¾‹å­</a></h3>
<p>è¿è¡Œæ­¤ç¤ºä¾‹ï¼š</p>
<ul>
<li>å…‹éš† <a href="https://github.com/alloy-rs/examples" title="" target="_blank">examples</a> ä»“åº“: <code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>è¿è¡Œ: <code>cargo run --example create_instances</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example of creating instances of `U256` from strings and numbers.

use alloy::primitives::{
    utils::{parse_units, ParseUnits},
    U256,
};
use eyre::Result;
use std::str::FromStr;

fn main() -&gt; Result&lt;()&gt; {
    // From strings
    let a = U256::from_str("42")?;
    assert_eq!(a.to_string(), "42");

    let amount = "42";
    let units = 4;
    let b: ParseUnits = parse_units(amount, units)?;
    assert_eq!(b.to_string(), "420000");

    // From numbers
    let c = U256::from(42_u8);
    assert_eq!(c.to_string(), "42");

    let d = U256::from(42_u16);
    assert_eq!(d.to_string(), "42");

    let e = U256::from(42_u32);
    assert_eq!(e.to_string(), "42");

    let f = U256::from(42_u64);
    assert_eq!(f.to_string(), "42");

    let g = U256::from(42_u128);
    assert_eq!(g.to_string(), "42");

    let h = U256::from(0x2a);
    assert_eq!(h.to_string(), "42");

    let i = U256::from(42);
    assert_eq!(i.to_string(), "42");

    Ok(())
}</code></pre>
<p>åœ¨ Github ä¸ŠæŸ¥çœ‹æºä»£ç  <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/big-numbers/examples/create_instances.rs" title="" target="_blank">here</a>ã€‚</p>
<div style="break-before: page; page-break-before: always;"></div><!-- DO NOT EDIT THIS FILE. IT IS GENERATED BY RUNNING `./scripts/update.sh` -->
<!-- ANY CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN -->
<!-- EDIT OR CREATE THIS TEMPLATE INSTEAD: ./src/templates/big-numbers/math_operations.md -->
<!-- LATEST UPDATE: https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="ç¤ºä¾‹-math_operationsæ•°å­¦è¿ç®—-1"><a class="header" href="#ç¤ºä¾‹-math_operationsæ•°å­¦è¿ç®—-1">ç¤ºä¾‹: <code>math_operations</code>ï¼ˆæ•°å­¦è¿ç®—ï¼‰</a></h2>
<h3 id="ç¤ºä¾‹-28"><a class="header" href="#ç¤ºä¾‹-28">ç¤ºä¾‹</a></h3>
<p>è¦è¿è¡Œæ­¤ç¤ºä¾‹ï¼š</p>
<ul>
<li>å…‹éš† <a href="https://github.com/alloy-rs/examples" title="" target="_blank">examples</a> ä»“åº“: <code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>è¿è¡Œ: <code>cargo run --example math_operations</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example of performing arithmetic operations with `U256`.

use alloy::primitives::{utils::format_units, U256};
use eyre::Result;
use std::ops::{Div, Mul};

/// `U256` implements traits in `std::ops`, that means it supports arithmetic operations
/// using standard Rust operators `+`, `-`. `*`, `/`, `%`, along with additional utilities to
/// perform common mathematical tasks.
fn main() -&gt; Result&lt;()&gt; {
    let a = U256::from(10);
    let b = U256::from(2);

    // addition
    let sum = a + b;
    assert_eq!(sum, U256::from(12));

    // subtraction
    let difference = a - b;
    assert_eq!(difference, U256::from(8));

    // multiplication
    let product = a * b;
    assert_eq!(product, U256::from(20));

    // division
    let quotient = a / b;
    assert_eq!(quotient, U256::from(5));

    // modulo
    let remainder = a % b;
    assert_eq!(remainder, U256::ZERO); // equivalent to `U256::from(0)`

    // exponentiation
    let power = a.pow(b);
    assert_eq!(power, U256::from(100));

    // Multiply two 'ether' numbers:
    // Big numbers are integers, that can represent fixed point numbers.
    // For instance, 1 ether has 18 fixed
    // decimal places (1.000000000000000000), and its big number
    // representation is 10^18 = 1000000000000000000.
    // When we multiply such numbers we are summing up their exponents.
    // So if we multiply 10^18 * 10^18 we get 10^36, that is obviously incorrect.
    // In order to get the correct result we need to divide by 10^18.
    let eth1 = U256::from(10_000000000000000000_u128); // 10 ether
    let eth2 = U256::from(20_000000000000000000_u128); // 20 ether
    let base = U256::from(10).pow(U256::from(18));
    let mul = eth1.mul(eth2).div(base); // We also divide by 10^18
    let s: String = format_units(mul, "ether")?;
    assert_eq!(s, "200.000000000000000000"); // 200

    Ok(())
}</code></pre>
<p>åœ¨ Github ä¸Šæ‰¾åˆ°æºç  <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/big-numbers/examples/math_operations.rs" title="" target="_blank">here</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><!-- DO NOT EDIT THIS FILE. IT IS GENERATED BY RUNNING `./scripts/update.sh` -->
<!-- ANY CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN -->
<!-- EDIT OR CREATE THIS TEMPLATE INSTEAD: ./src/templates/big-numbers/math_utilities.md -->
<!-- LATEST UPDATE: https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="ç¤ºä¾‹math_utilities-1"><a class="header" href="#ç¤ºä¾‹math_utilities-1">ç¤ºä¾‹ï¼š<code>math_utilities</code></a></h2>
<h3 id="ç¤ºä¾‹-29"><a class="header" href="#ç¤ºä¾‹-29">ç¤ºä¾‹</a></h3>
<p>è¿è¡Œæ­¤ç¤ºä¾‹ï¼š</p>
<ul>
<li>å…‹éš† <a href="https://github.com/alloy-rs/examples" title="" target="_blank">examples</a> ä»“åº“ï¼š<code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>è¿è¡Œï¼š<code>cargo run --example math_utilities</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example of using math utilities to handle big numbers in 'wei' units.

use alloy::primitives::{
    utils::{format_units, parse_units},
    U256,
};
use eyre::Result;

fn main() -&gt; Result&lt;()&gt; {
    parse_units_example()?;
    format_units_example()?;

    Ok(())
}

/// dApps business logics handle big numbers in 'wei' units (i.e. sending transactions, on-chain
/// math, etc.). We provide convenient methods to map user inputs (usually in 'ether' or 'gwei')
/// into 'wei' format.
fn parse_units_example() -&gt; Result&lt;()&gt; {
    let pu = parse_units("1.0", "wei")?;
    let num: U256 = pu.into();
    assert_eq!(num, U256::from(1));

    let pu = parse_units("1.0", "kwei")?;
    let num: U256 = pu.into();
    assert_eq!(num, U256::from(1000));

    let pu = parse_units("1.0", "mwei")?;
    let num: U256 = pu.into();
    assert_eq!(num, U256::from(1000000));

    let pu = parse_units("1.0", "gwei")?;
    let num: U256 = pu.into();
    assert_eq!(num, U256::from(1000000000));

    let pu = parse_units("1.0", "szabo")?;
    let num: U256 = pu.into();
    assert_eq!(num, U256::from(1000000000000_u128));

    let pu = parse_units("1.0", "finney")?;
    let num: U256 = pu.into();
    assert_eq!(num, U256::from(1000000000000000_u128));

    let pu = parse_units("1.0", "ether")?;
    let num: U256 = pu.into();
    assert_eq!(num, U256::from(1000000000000000000_u128));

    let pu = parse_units("1.0", 18)?;
    let num: U256 = pu.into();
    assert_eq!(num, U256::from(1000000000000000000_u128));

    Ok(())
}

/// dApps business logics handle big numbers in 'wei' units (i.e. sending transactions, on-chain
/// math, etc.). On the other hand it is useful to convert big numbers into user readable formats
/// when displaying on a UI. Generally dApps display numbers in 'ether' and 'gwei' units,
/// respectively for displaying amounts and gas. The `format_units` function will format a big
/// number into a user readable string.
fn format_units_example() -&gt; Result&lt;()&gt; {
    // 1 ETHER = 10^18 WEI
    let one_ether = U256::from(1000000000000000000_u128);

    let num: String = format_units(one_ether, "wei")?;
    assert_eq!(num, "1000000000000000000.0");

    let num: String = format_units(one_ether, "gwei")?;
    assert_eq!(num, "1000000000.000000000");

    let num: String = format_units(one_ether, "ether")?;
    assert_eq!(num, "1.000000000000000000");

    // 1 GWEI = 10^9 WEI
    let one_gwei = U256::from(1000000000_u128);

    let num: String = format_units(one_gwei, 0)?;
    assert_eq!(num, "1000000000.0");

    let num: String = format_units(one_gwei, "wei")?;
    assert_eq!(num, "1000000000.0");

    let num: String = format_units(one_gwei, "kwei")?;
    assert_eq!(num, "1000000.000");

    let num: String = format_units(one_gwei, "mwei")?;
    assert_eq!(num, "1000.000000");

    let num: String = format_units(one_gwei, "gwei")?;
    assert_eq!(num, "1.000000000");

    let num: String = format_units(one_gwei, "szabo")?;
    assert_eq!(num, "0.001000000000");

    let num: String = format_units(one_gwei, "finney")?;
    assert_eq!(num, "0.000001000000000");

    let num: String = format_units(one_gwei, "ether")?;
    assert_eq!(num, "0.000000001000000000");

    Ok(())
}</code></pre>
<p>åœ¨ Github ä¸Šæ‰¾åˆ°æºä»£ç  <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/big-numbers/examples/math_utilities.rs" title="" target="_blank">here</a>ã€‚</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="åˆçº¦"><a class="header" href="#åˆçº¦">åˆçº¦</a></h2>
<ul>
<li><a href="examples/contracts/deploy_from_artifact.html">ä» artifact éƒ¨ç½²</a></li>
<li><a href="examples/contracts/deploy_from_bytecode.html">ä»å­—èŠ‚ç éƒ¨ç½²</a></li>
<li><a href="examples/contracts/deploy_from_contract.html">ä»åˆçº¦éƒ¨ç½²</a></li>
<li><a href="examples/contracts/interact_with_abi.html">ä¸ ABI äº¤äº’</a></li>
<li><a href="examples/contracts/interact_with_contract_instance.html">ä¸åˆçº¦å®ä¾‹äº¤äº’</a></li>
<li><a href="examples/contracts/unknown_return_types.html">å¤„ç†æœªçŸ¥è¿”å›ç±»å‹</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><!-- DO NOT EDIT THIS FILE. IT IS GENERATED BY RUNNING `./scripts/update.sh` -->
<!-- ANY CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN -->
<!-- EDIT OR CREATE THIS TEMPLATE INSTEAD: ./src/templates/contracts/deploy_from_artifact.md -->
<!-- LATEST UPDATE: https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="ç¤ºä¾‹-deploy_from_artifact"><a class="header" href="#ç¤ºä¾‹-deploy_from_artifact">ç¤ºä¾‹: <code>deploy_from_artifact</code></a></h2>
<h3 id="ç¤ºä¾‹-30"><a class="header" href="#ç¤ºä¾‹-30">ç¤ºä¾‹</a></h3>
<p>è¿è¡Œæ­¤ç¤ºä¾‹:</p>
<ul>
<li>å…‹éš† <a href="https://github.com/alloy-rs/examples" title="" target="_blank">examples</a> ä»“åº“: <code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>è¿è¡Œ: <code>cargo run --example deploy_from_artifact</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example of deploying a contract from an artifact using the `sol!` macro to Anvil and interacting
//! with it.

use alloy::{
    network::EthereumWallet, node_bindings::Anvil, primitives::U256, providers::ProviderBuilder,
    signers::local::PrivateKeySigner, sol,
};
use eyre::Result;

// Codegen from artifact.
sol!(
    #[allow(missing_docs)]
    #[sol(rpc)]
    Counter,
    "examples/artifacts/Counter.json"
);

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    // Spin up a local Anvil node.
    // Ensure `anvil` is available in $PATH.
    let anvil = Anvil::new().try_spawn()?;

    // Set up signer from the first default Anvil account (Alice).
    let signer: PrivateKeySigner = anvil.keys()[0].clone().into();
    let wallet = EthereumWallet::from(signer);

    // Create a provider with the wallet.
    let rpc_url = anvil.endpoint().parse()?;
    let provider =
        ProviderBuilder::new().with_recommended_fillers().wallet(wallet).on_http(rpc_url);

    println!("Anvil running at `{}`", anvil.endpoint());

    // Deploy the `Counter` contract.
    let contract = Counter::deploy(&amp;provider).await?;

    println!("Deployed contract at address: {}", contract.address());

    // Set the number to 42.
    let builder = contract.setNumber(U256::from(42));
    let tx_hash = builder.send().await?.watch().await?;

    println!("Set number to 42: {tx_hash}");

    // Increment the number to 43.
    let builder = contract.increment();
    let tx_hash = builder.send().await?.watch().await?;

    println!("Incremented number: {tx_hash}");

    // Retrieve the number, which should be 43.
    let builder = contract.number();

    // Note: because the artifact generated by `solc` does not include named return values it is
    // not possible to derive the return value name `number` from the artifact. This means that the
    // return value must be accessed by index - as if it is an unnamed value.
    // If you prefer to use named return values, it is recommended to embed the Solidity code
    // directly in the `sol!` macro as shown in `deploy_from_contract.rs`.
    let number = builder.call().await?._0;

    println!("Retrieved number: {number}");

    Ok(())
}</code></pre>
<p>åœ¨ Github ä¸ŠæŸ¥æ‰¾æºä»£ç  <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/contracts/examples/deploy_from_artifact.rs" title="" target="_blank">è¿™é‡Œ</a>ã€‚</p>
<div style="break-before: page; page-break-before: always;"></div><!-- DO NOT EDIT THIS FILE. IT IS GENERATED BY RUNNING `./scripts/update.sh` -->
<!-- ANY CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN -->
<!-- EDIT OR CREATE THIS TEMPLATE INSTEAD: ./src/templates/contracts/deploy_from_bytecode.md -->
<!-- LATEST UPDATE: https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="ç¤ºä¾‹-deploy_from_bytecode"><a class="header" href="#ç¤ºä¾‹-deploy_from_bytecode">ç¤ºä¾‹: <code>deploy_from_bytecode</code></a></h2>
<h3 id="ç¤ºä¾‹-31"><a class="header" href="#ç¤ºä¾‹-31">ç¤ºä¾‹</a></h3>
<p>è¿è¡Œè¿™ä¸ªç¤ºä¾‹:</p>
<ul>
<li>å…‹éš†è¿™ä¸ª <a href="https://github.com/alloy-rs/examples" title="" target="_blank">ç¤ºä¾‹</a> ä»“åº“: <code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>è¿è¡Œ: <code>cargo run --example deploy_from_bytecode</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example of deploying a contract at runtime from Solidity bytecode to Anvil and interacting with
//! it.

use alloy::{
    hex,
    network::{EthereumWallet, ReceiptResponse, TransactionBuilder},
    node_bindings::Anvil,
    primitives::U256,
    providers::{Provider, ProviderBuilder},
    rpc::types::TransactionRequest,
    signers::local::PrivateKeySigner,
    sol,
};
use eyre::Result;

// If you have the bytecode known at build time, use the `deploy_from_contract` example.
// This method benefits from using bytecode at runtime, e.g., from newly deployed contracts, to
// analyze the behavior.
sol! {
    #[allow(missing_docs)]
    #[sol(rpc)]
    contract Counter {
        uint256 public number;

        function setNumber(uint256 newNumber) public {
            number = newNumber;
        }

        function increment() public {
            number++;
        }
    }
}

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    // Spin up a local Anvil node.
    // Ensure `anvil` is available in $PATH.
    let anvil = Anvil::new().try_spawn()?;

    // Set up signer from the first default Anvil account (Alice).
    let signer: PrivateKeySigner = anvil.keys()[0].clone().into();
    let wallet = EthereumWallet::from(signer);

    println!("Anvil running at `{}`", anvil.endpoint());

    // Create a provider with the wallet.
    let rpc_url = anvil.endpoint().parse()?;
    let provider =
        ProviderBuilder::new().with_recommended_fillers().wallet(wallet).on_http(rpc_url);

    // Deploy the `Counter` contract from bytecode at runtime.
    let bytecode = hex::decode(
        // solc v0.8.26; solc Counter.sol --via-ir --optimize --bin
        "6080806040523460135760df908160198239f35b600080fdfe6080806040526004361015601257600080fd5b60003560e01c9081633fb5c1cb1460925781638381f58a146079575063d09de08a14603c57600080fd5b3460745760003660031901126074576000546000198114605e57600101600055005b634e487b7160e01b600052601160045260246000fd5b600080fd5b3460745760003660031901126074576020906000548152f35b34607457602036600319011260745760043560005500fea2646970667358221220e978270883b7baed10810c4079c941512e93a7ba1cd1108c781d4bc738d9090564736f6c634300081a0033"
    )?;
    let tx = TransactionRequest::default().with_deploy_code(bytecode);

    // Deploy the contract.
    let receipt = provider.send_transaction(tx).await?.get_receipt().await?;

    let contract_address = receipt.contract_address().expect("Failed to get contract address");
    let contract = Counter::new(contract_address, &amp;provider);
    println!("Deployed contract at address: {}", contract.address());

    // Set number
    let builder = contract.setNumber(U256::from(42));
    let tx_hash = builder.send().await?.watch().await?;

    println!("Set number to 42: {tx_hash}");

    // Increment the number to 43.
    let builder = contract.increment();
    let tx_hash = builder.send().await?.watch().await?;

    println!("Incremented number: {tx_hash}");

    // Retrieve the number, which should be 43.
    let builder = contract.number();
    let number = builder.call().await?.number.to_string();

    println!("Retrieved number: {number}");

    Ok(())
}</code></pre>
<p>åœ¨ Github ä¸ŠæŸ¥æ‰¾æºä»£ç  <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/contracts/examples/deploy_from_bytecode.rs" title="" target="_blank">è¿™é‡Œ</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><!-- è¯·å‹¿ç¼–è¾‘æ­¤æ–‡ä»¶ã€‚å®ƒæ˜¯é€šè¿‡è¿è¡Œ `./scripts/update.sh` è‡ªåŠ¨ç”Ÿæˆçš„ -->
<!-- å¯¹è¯¥æ–‡ä»¶çš„ä»»ä½•æ›´æ”¹éƒ½å°†è¢«è¦†ç›– -->
<!-- è¯·ç¼–è¾‘æˆ–åˆ›å»ºè¯¥æ¨¡æ¿ï¼š./src/templates/contracts/deploy_from_contract.md -->
<!-- æœ€æ–°æ›´æ–°ï¼šhttps://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="ç¤ºä¾‹-deploy_from_contract"><a class="header" href="#ç¤ºä¾‹-deploy_from_contract">ç¤ºä¾‹: <code>deploy_from_contract</code></a></h2>
<h3 id="ç¤ºä¾‹-32"><a class="header" href="#ç¤ºä¾‹-32">ç¤ºä¾‹</a></h3>
<p>è¦è¿è¡Œæ­¤ç¤ºä¾‹ï¼š</p>
<ul>
<li>å…‹éš† <a href="https://github.com/alloy-rs/examples" title="" target="_blank">examples</a> ä»“åº“: <code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>è¿è¡Œ: <code>cargo run --example deploy_from_contract</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example of deploying a contract from Solidity code using the `sol!` macro to Anvil and
//! interacting with it.

use alloy::{
    network::EthereumWallet, node_bindings::Anvil, primitives::U256, providers::ProviderBuilder,
    signers::local::PrivateKeySigner, sol,
};
use eyre::Result;

// Codegen from embedded Solidity code and precompiled bytecode.
sol! {
    #[allow(missing_docs)]
    // solc v0.8.26; solc Counter.sol --via-ir --optimize --bin
    #[sol(rpc, bytecode="6080806040523460135760df908160198239f35b600080fdfe6080806040526004361015601257600080fd5b60003560e01c9081633fb5c1cb1460925781638381f58a146079575063d09de08a14603c57600080fd5b3460745760003660031901126074576000546000198114605e57600101600055005b634e487b7160e01b600052601160045260246000fd5b600080fd5b3460745760003660031901126074576020906000548152f35b34607457602036600319011260745760043560005500fea2646970667358221220e978270883b7baed10810c4079c941512e93a7ba1cd1108c781d4bc738d9090564736f6c634300081a0033")]
    contract Counter {
        uint256 public number;

        function setNumber(uint256 newNumber) public {
            number = newNumber;
        }

        function increment() public {
            number++;
        }
    }
}

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    // Spin up a local Anvil node.
    // Ensure `anvil` is available in $PATH.
    let anvil = Anvil::new().try_spawn()?;

    // Set up signer from the first default Anvil account (Alice).
    let signer: PrivateKeySigner = anvil.keys()[0].clone().into();
    let wallet = EthereumWallet::from(signer);

    // Create a provider with the wallet.
    let rpc_url = anvil.endpoint().parse()?;
    let provider =
        ProviderBuilder::new().with_recommended_fillers().wallet(wallet).on_http(rpc_url);

    println!("Anvil running at `{}`", anvil.endpoint());

    // Deploy the `Counter` contract.
    let contract = Counter::deploy(&amp;provider).await?;

    println!("Deployed contract at address: {}", contract.address());

    let builder = contract.setNumber(U256::from(42));
    let tx_hash = builder.send().await?.watch().await?;

    println!("Set number to 42: {tx_hash}");

    // Increment the number to 43.
    let builder = contract.increment();
    let tx_hash = builder.send().await?.watch().await?;

    println!("Incremented number: {tx_hash}");

    // Retrieve the number, which should be 43.
    let builder = contract.number();
    let number = builder.call().await?.number.to_string();

    println!("Retrieved number: {number}");

    Ok(())
}</code></pre>
<p>åœ¨ Github ä¸Šå¯ä»¥æ‰¾åˆ°æºä»£ç  <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/contracts/examples/deploy_from_contract.rs" title="" target="_blank">here</a>ã€‚</p>
<div style="break-before: page; page-break-before: always;"></div><!-- DO NOT EDIT THIS FILE. IT IS GENERATED BY RUNNING `./scripts/update.sh` -->
<!-- ANY CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN -->
<!-- EDIT OR CREATE THIS TEMPLATE INSTEAD: ./src/templates/contracts/interact_with_abi.md -->
<!-- LATEST UPDATE: https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="ç¤ºä¾‹-interact_with_abi"><a class="header" href="#ç¤ºä¾‹-interact_with_abi">ç¤ºä¾‹: <code>interact_with_abi</code></a></h2>
<h3 id="ç¤ºä¾‹-33"><a class="header" href="#ç¤ºä¾‹-33">ç¤ºä¾‹</a></h3>
<p>è¦è¿è¡Œè¿™ä¸ªç¤ºä¾‹:</p>
<ul>
<li>å…‹éš† <a href="https://github.com/alloy-rs/examples" title="" target="_blank">examples</a> ä»“åº“: <code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>è¿è¡Œ: <code>cargo run --example interact_with_abi</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example of generating code from ABI file using the `sol!` macro to interact with the contract.

use alloy::{node_bindings::Anvil, providers::ProviderBuilder, sol};
use eyre::Result;

// Codegen from ABI file to interact with the contract.
sol!(
    #[allow(missing_docs)]
    #[sol(rpc)]
    IWETH9,
    "examples/abi/IWETH9.json"
);

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    // Spin up a forked Anvil node.
    // Ensure `anvil` is available in $PATH.
    let anvil = Anvil::new().fork("https://eth.merkle.io").try_spawn()?;

    // Create a provider.
    let rpc_url = anvil.endpoint().parse()?;
    let provider = ProviderBuilder::new().on_http(rpc_url);

    // Create a contract instance.
    let contract = IWETH9::new("0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2".parse()?, provider);

    // Call the contract, retrieve the total supply.
    let IWETH9::totalSupplyReturn { _0 } = contract.totalSupply().call().await?;

    println!("WETH total supply is {_0}");

    Ok(())
}</code></pre>
<p>åœ¨ Github ä¸Šæ‰¾åˆ°æºä»£ç  <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/contracts/examples/interact_with_abi.rs" title="" target="_blank">here</a>ã€‚</p>
<div style="break-before: page; page-break-before: always;"></div><!-- DO NOT EDIT THIS FILE. IT IS GENERATED BY RUNNING `./scripts/update.sh` -->
<!-- ANY CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN -->
<!-- EDIT OR CREATE THIS TEMPLATE INSTEAD: ./src/templates/contracts/interact_with_contract_instance.md -->
<!-- LATEST UPDATE: https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="ç¤ºä¾‹-interact_with_contract_instance"><a class="header" href="#ç¤ºä¾‹-interact_with_contract_instance">ç¤ºä¾‹: <code>interact_with_contract_instance</code></a></h2>
<h3 id="ç¤ºä¾‹-34"><a class="header" href="#ç¤ºä¾‹-34">ç¤ºä¾‹</a></h3>
<p>è¦è¿è¡Œè¿™ä¸ªç¤ºä¾‹ï¼š</p>
<ul>
<li>å…‹éš† <a href="https://github.com/alloy-rs/examples" title="" target="_blank">examples</a> ä»£ç åº“: <code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>è¿è¡Œ: <code>cargo run --example interact_with_contract_instance</code></li>
</ul>
<pre><code class="language-rust ignore">//! This example demonstrates how to interact with a contract that is already deployed onchain using
//! the `ContractInstance` interface.

use alloy::{
    contract::{ContractInstance, Interface},
    dyn_abi::DynSolValue,
    network::{Ethereum, TransactionBuilder},
    primitives::{hex, U256},
    providers::{Provider, ProviderBuilder},
    rpc::types::TransactionRequest,
    transports::http::{Client, Http},
};
use eyre::Result;

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    let provider = ProviderBuilder::new().with_recommended_fillers().on_anvil_with_wallet();

    // Deploy the `Counter` contract from bytecode at runtime.
    let bytecode = hex::decode(
        // solc v0.8.26; solc Counter.sol --via-ir --optimize --bin
        //
        // contract Counter {
        //     uint256 public number;
        //
        //     function setNumber(uint256 newNumber) public {
        //         number = newNumber;
        //     }
        //
        //     function increment() public {
        //         number++;
        //     }
        // }
        "6080806040523460135760df908160198239f35b600080fdfe6080806040526004361015601257600080fd5b60003560e01c9081633fb5c1cb1460925781638381f58a146079575063d09de08a14603c57600080fd5b3460745760003660031901126074576000546000198114605e57600101600055005b634e487b7160e01b600052601160045260246000fd5b600080fd5b3460745760003660031901126074576020906000548152f35b34607457602036600319011260745760043560005500fea2646970667358221220e978270883b7baed10810c4079c941512e93a7ba1cd1108c781d4bc738d9090564736f6c634300081a0033"
    )?;
    let tx = TransactionRequest::default().with_deploy_code(bytecode);

    let contract_address = provider
        .send_transaction(tx)
        .await?
        .get_receipt()
        .await?
        .contract_address
        .expect("Failed to get contract address");

    // Get the contract ABI.
    let path = std::env::current_dir()?.join("examples/contracts/examples/artifacts/Counter.json");

    // Read the artifact which contains `abi`, `bytecode`, `deployedBytecode` and `metadata`.
    let artifact = std::fs::read(path).expect("Failed to read artifact");
    let json: serde_json::Value = serde_json::from_slice(&amp;artifact)?;

    // Get `abi` from the artifact.
    let abi_value = json.get("abi").expect("Failed to get ABI from artifact");
    let abi = serde_json::from_str(&amp;abi_value.to_string())?;

    // Create a new `ContractInstance` of the `Counter` contract from the abi
    let contract: ContractInstance&lt;Http&lt;Client&gt;, _, Ethereum&gt; =
        ContractInstance::new(contract_address, provider.clone(), Interface::new(abi));

    // Set the number to 42.
    let number_value = DynSolValue::from(U256::from(42));
    let tx_hash = contract.function("setNumber", &amp;[number_value])?.send().await?.watch().await?;

    println!("Set number to 42: {tx_hash}");

    // Increment the number to 43.
    let tx_hash = contract.function("increment", &amp;[])?.send().await?.watch().await?;

    println!("Incremented number: {tx_hash}");

    // Retrieve the number, which should be 43.
    let number_value = contract.function("number", &amp;[])?.call().await?;
    let number = number_value.first().unwrap().as_uint().unwrap().0;
    assert_eq!(U256::from(43), number);

    println!("Retrieved number: {number}");

    // Try calling a function that does not exist
    let unknown_function = contract.function("decrement", &amp;[]).unwrap_err();
    assert!(unknown_function.to_string().contains("function decrement does not exist"));

    Ok(())
}</code></pre>
<p>åœ¨ Github ä¸ŠæŸ¥çœ‹æºä»£ç  <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/contracts/examples/interact_with_contract_instance.rs" title="" target="_blank">è¿™é‡Œ</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><!-- DO NOT EDIT THIS FILE. IT IS GENERATED BY RUNNING `./scripts/update.sh` -->
<!-- ANY CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN -->
<!-- EDIT OR CREATE THIS TEMPLATE INSTEAD: ./src/templates/contracts/unknown_return_types.md -->
<!-- LATEST UPDATE: https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="ç¤ºä¾‹unknown_return_types"><a class="header" href="#ç¤ºä¾‹unknown_return_types">ç¤ºä¾‹ï¼š<code>unknown_return_types</code></a></h2>
<h3 id="ç¤ºä¾‹-35"><a class="header" href="#ç¤ºä¾‹-35">ç¤ºä¾‹</a></h3>
<p>è¿è¡Œæ­¤ç¤ºä¾‹ï¼š</p>
<ul>
<li>å…‹éš† <a href="https://github.com/alloy-rs/examples" title="" target="_blank">examples</a> ä»“åº“ï¼š<code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>è¿è¡Œï¼š<code>cargo run --example unknown_return_types</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example demonstrating how one can handle unknown / complex return types using `DynSol`.

use alloy::{
    contract::{ContractInstance, Interface},
    dyn_abi::DynSolValue,
    json_abi::JsonAbi,
    network::{Ethereum, TransactionBuilder},
    primitives::{hex, U256},
    providers::{Provider, ProviderBuilder},
    rpc::types::TransactionRequest,
    transports::http::{Client, Http},
};
use eyre::Result;

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    let provider = ProviderBuilder::new().with_recommended_fillers().on_anvil_with_wallet();

    let from = provider.get_accounts().await?[0];

    let bytecode = hex::decode(
        // contract Colors {
        //     struct Color {
        //         uint8 r;
        //         uint8 g;
        //         uint8 b;
        //     }
        //
        //     mapping(address =&gt; Color) public colors;
        //
        //     function setColor(uint8 r, uint8 g, uint8 b) public {
        //         colors[msg.sender] = Color(r, g, b);
        //     }
        //
        //     function getColor(address user) public view returns (Color memory) {
        //         return colors[user];
        //     }
        //
        //     function getColorAsTuple(
        //         address user
        //     ) public view returns (uint8, uint8, uint8) {
        //         return (colors[user].r, colors[user].g, colors[user].b);
        //     }
        // }
        "6080604052348015600f57600080fd5b506105fb8061001f6000396000f3fe608060405234801561001057600080fd5b506004361061004c5760003560e01c8063610c76f01461005157806384b5e5961461006d57806399efff171461009d578063befdb4f6146100cf575b600080fd5b61006b60048036038101906100669190610435565b610101565b005b610087600480360381019061008291906104e6565b6101ce565b6040516100949190610564565b60405180910390f35b6100b760048036038101906100b291906104e6565b61027d565b6040516100c69392919061058e565b60405180910390f35b6100e960048036038101906100e491906104e6565b61037c565b6040516100f89392919061058e565b60405180910390f35b60405180606001604052808460ff1681526020018360ff1681526020018260ff168152506000803373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008201518160000160006101000a81548160ff021916908360ff16021790555060208201518160000160016101000a81548160ff021916908360ff16021790555060408201518160000160026101000a81548160ff021916908360ff160217905550905050505050565b6101d66103cd565b6000808373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206040518060600160405290816000820160009054906101000a900460ff1660ff1660ff1681526020016000820160019054906101000a900460ff1660ff1660ff1681526020016000820160029054906101000a900460ff1660ff1660ff16815250509050919050565b60008060008060008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060000160009054906101000a900460ff166000808673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060000160019054906101000a900460ff166000808773ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060000160029054906101000a900460ff169250925092509193909250565b60006020528060005260406000206000915090508060000160009054906101000a900460ff16908060000160019054906101000a900460ff16908060000160029054906101000a900460ff16905083565b6040518060600160405280600060ff168152602001600060ff168152602001600060ff1681525090565b600080fd5b600060ff82169050919050565b610412816103fc565b811461041d57600080fd5b50565b60008135905061042f81610409565b92915050565b60008060006060848603121561044e5761044d6103f7565b5b600061045c86828701610420565b935050602061046d86828701610420565b925050604061047e86828701610420565b9150509250925092565b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b60006104b382610488565b9050919050565b6104c3816104a8565b81146104ce57600080fd5b50565b6000813590506104e0816104ba565b92915050565b6000602082840312156104fc576104fb6103f7565b5b600061050a848285016104d1565b91505092915050565b61051c816103fc565b82525050565b6060820160008201516105386000850182610513565b50602082015161054b6020850182610513565b50604082015161055e6040850182610513565b50505050565b60006060820190506105796000830184610522565b92915050565b610588816103fc565b82525050565b60006060820190506105a3600083018661057f565b6105b0602083018561057f565b6105bd604083018461057f565b94935050505056fea2646970667358221220ce426adf2fbf80a861f23a5eb1e99a281bb07e427b9beed059e09c285f16db6c64736f6c634300081a0033"
    )?;
    let deploy_tx = TransactionRequest::default().from(from).with_deploy_code(bytecode);

    let contract_address = provider
        .send_transaction(deploy_tx)
        .await?
        .get_receipt()
        .await?
        .contract_address
        .expect("Failed to get contract address");

    // Get the contract abi.
    let path = std::env::current_dir()?.join("examples/contracts/examples/abi/Colors.json");
    let contents = std::fs::read(path)?;
    let abi: JsonAbi = serde_json::from_slice(&amp;contents)?;

    // Create a new `ContractInstance` of the Counter contract from the abi.
    let counter_instance: ContractInstance&lt;Http&lt;Client&gt;, _, Ethereum&gt; =
        ContractInstance::new(contract_address, provider.clone(), Interface::new(abi));

    // Interact with the contract.
    assert_eq!(counter_instance.abi().functions().count(), 4);

    // Set color to white.
    let r = DynSolValue::Uint(U256::from(255), 8); // uint8
    let g = DynSolValue::Uint(U256::from(255), 8); // uint8
    let b = DynSolValue::Uint(U256::from(255), 8); // uint8
    let set_color_func = counter_instance.function("setColor", &amp;[r, g, b])?;
    let set_color_receipt = set_color_func.send().await?.get_receipt().await?;
    assert!(set_color_receipt.status());

    // Get the color.
    let get_color_func = counter_instance.function("getColor", &amp;[DynSolValue::Address(from)])?;
    let get_color_result = get_color_func.call().await?;

    // The `r`, `g`, `b` values in the `Color` struct get converted to a `DynSolValue::Tuple`.
    assert!(get_color_result.len() == 1);
    for value in get_color_result {
        if let DynSolValue::Tuple(struct_as_tuple) = value {
            println!("{struct_as_tuple:?}");
        }
    }

    // Get the color as tuple.
    let get_color_tuple =
        counter_instance.function("getColorAsTuple", &amp;[DynSolValue::Address(from)])?;
    let get_color_tuple_result = get_color_tuple.call().await?;

    // The `r`, `g`, `b` are returned as a solidity tuple and hence represented as individual
    // `DynSolValue::Uint`.
    assert!(get_color_tuple_result.len() == 3);
    for value in get_color_tuple_result {
        println!("{value:?}");
    }

    Ok(())
}</code></pre>
<p>åœ¨ Github ä¸Šæ‰¾åˆ°æºç  <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/contracts/examples/unknown_return_types.rs" title="" target="_blank">here</a>ã€‚</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="å¡«å……ç¨‹åº"><a class="header" href="#å¡«å……ç¨‹åº">å¡«å……ç¨‹åº</a></h2>
<ul>
<li><a href="examples/fillers/gas_filler.html">Gas ä¼°ç®—å¡«å……ç¨‹åº</a></li>
<li><a href="examples/fillers/nonce_filler.html">Nonce ç®¡ç†å¡«å……ç¨‹åº</a></li>
<li><a href="examples/fillers/recommended_fillers.html">æ¨èçš„å¡«å……ç¨‹åº</a></li>
<li><a href="examples/fillers/wallet_filler.html">é’±åŒ…ç®¡ç†å¡«å……ç¨‹åº</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><!-- DO NOT EDIT THIS FILE. IT IS GENERATED BY RUNNING `./scripts/update.sh` -->
<!-- ANY CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN -->
<!-- EDIT OR CREATE THIS TEMPLATE INSTEAD: ./src/templates/fillers/gas_filler.md -->
<!-- LATEST UPDATE: https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="ç¤ºä¾‹gas_filler-1"><a class="header" href="#ç¤ºä¾‹gas_filler-1">ç¤ºä¾‹ï¼š<code>gas_filler</code></a></h2>
<h3 id="ç¤ºä¾‹-36"><a class="header" href="#ç¤ºä¾‹-36">ç¤ºä¾‹</a></h3>
<p>è¦è¿è¡Œæ­¤ç¤ºä¾‹ï¼š</p>
<ul>
<li>å…‹éš† <a href="https://github.com/alloy-rs/examples" title="" target="_blank">examples</a> ä»“åº“ï¼š<code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>è¿è¡Œï¼š<code>cargo run --example gas_filler</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example of using the `GasFiller` in the provider.

use alloy::{
    network::{EthereumWallet, TransactionBuilder},
    node_bindings::Anvil,
    primitives::{address, U256},
    providers::{Provider, ProviderBuilder},
    rpc::types::request::TransactionRequest,
    signers::local::PrivateKeySigner,
};
use eyre::Result;

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    // Spin up a local Anvil node.
    // Ensure `anvil` is available in $PATH.
    let anvil = Anvil::new().try_spawn()?;

    // Set up signer from the first default Anvil account (Alice).
    let signer: PrivateKeySigner = anvil.keys()[0].clone().into();
    let wallet = EthereumWallet::from(signer);

    // Create a provider with the wallet.
    let rpc_url = anvil.endpoint().parse()?;
    let provider = ProviderBuilder::new()
        // Add the `GasFiller` to the provider.
        // It is generally recommended to use the `.with_recommended_fillers()` method, which
        // includes the `GasFiller`.
        .with_gas_estimation()
        .wallet(wallet)
        .on_http(rpc_url);

    // Build an EIP-1559 type transaction to send 100 wei to Vitalik.
    let vitalik = address!("d8dA6BF26964aF9D7eEd9e03E53415D37aA96045");
    let tx = TransactionRequest::default()
        .with_to(vitalik)
        .with_value(U256::from(100))
        // Notice that without the `NonceFiller`, you need to set `nonce` field.
        .with_nonce(0)
        // Notice that without the `ChainIdFiller`, you need to set the `chain_id` field.
        .with_chain_id(anvil.chain_id());

    // Send the transaction, the nonce (0) is automatically managed by the provider.
    let builder = provider.send_transaction(tx.clone()).await?;
    let node_hash = *builder.tx_hash();
    let pending_tx =
        provider.get_transaction_by_hash(node_hash).await?.expect("Pending transaction not found");
    assert_eq!(pending_tx.nonce, 0);

    println!("Transaction sent with nonce: {}", pending_tx.nonce);

    // Update the nonce and send the transaction again.
    let tx = tx.with_nonce(1);

    // Send the transaction, the nonce (1) is automatically managed by the provider.
    let builder = provider.send_transaction(tx).await?;
    let node_hash = *builder.tx_hash();
    let pending_tx =
        provider.get_transaction_by_hash(node_hash).await?.expect("Pending transaction not found");
    assert_eq!(pending_tx.nonce, 1);

    println!("Transaction sent with nonce: {}", pending_tx.nonce);

    Ok(())
}</code></pre>
<p>åœ¨ Github ä¸Šæ‰¾åˆ°æºä»£ç  <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/fillers/examples/gas_filler.rs" title="" target="_blank">here</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><!-- DO NOT EDIT THIS FILE. IT IS GENERATED BY RUNNING `./scripts/update.sh` -->
<!-- ANY CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN -->
<!-- EDIT OR CREATE THIS TEMPLATE INSTEAD: ./src/templates/fillers/nonce_filler.md -->
<!-- LATEST UPDATE: https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="ç¤ºä¾‹-nonce_filler-1"><a class="header" href="#ç¤ºä¾‹-nonce_filler-1">ç¤ºä¾‹: <code>nonce_filler</code></a></h2>
<h3 id="ç¤ºä¾‹-37"><a class="header" href="#ç¤ºä¾‹-37">ç¤ºä¾‹</a></h3>
<p>è¿è¡Œæ­¤ç¤ºä¾‹:</p>
<ul>
<li>å…‹éš† <a href="https://github.com/alloy-rs/examples" title="" target="_blank">examples</a> ä»“åº“: <code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>è¿è¡Œ: <code>cargo run --example nonce_filler</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example of using the `NonceFiller` in the provider.

use alloy::{
    network::{EthereumWallet, TransactionBuilder},
    node_bindings::Anvil,
    primitives::{address, U256},
    providers::{Provider, ProviderBuilder},
    rpc::types::request::TransactionRequest,
    signers::local::PrivateKeySigner,
};
use eyre::Result;

/// In Ethereum, the nonce of a transaction is a number that represents the number of transactions
/// that have been sent from a particular account. The nonce is used to ensure that transactions are
/// processed in the order they are intended, and to prevent the same transaction from being
/// processed multiple times.
///
/// The nonce manager in Alloy is a layer that helps you manage the nonce
/// of transactions by keeping track of the current nonce for a given account and automatically
/// incrementing it as needed. This can be useful if you want to ensure that transactions are sent
/// in the correct order, or if you want to avoid having to manually manage the nonce yourself.
#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    // Spin up a local Anvil node.
    // Ensure `anvil` is available in $PATH.
    let anvil = Anvil::new().try_spawn()?;

    // Set up signer from the first default Anvil account (Alice).
    let signer: PrivateKeySigner = anvil.keys()[0].clone().into();
    let wallet = EthereumWallet::from(signer);

    // Create a provider with the wallet.
    let rpc_url = anvil.endpoint().parse()?;
    let provider = ProviderBuilder::new()
        // Add the `NonceFiller` to the provider.
        // It is generally recommended to use the `.with_recommended_fillers()` method, which
        // includes the `NonceFiller`.
        .with_nonce_management()
        .wallet(wallet)
        .on_http(rpc_url);

    // Build an EIP-1559 type transaction to send 100 wei to Vitalik.
    let vitalik = address!("d8dA6BF26964aF9D7eEd9e03E53415D37aA96045");
    let tx = TransactionRequest::default()
        .with_to(vitalik)
        .with_value(U256::from(100))
        // Notice that without the `GasFiller`, you need to set the gas related fields.
        .with_gas_limit(21_000)
        .with_max_fee_per_gas(20_000_000_000)
        .with_max_priority_fee_per_gas(1_000_000_000)
        // Notice that without the `ChainIdFiller`, you need to set the `chain_id` field.
        .with_chain_id(anvil.chain_id());

    // Send the transaction, the nonce (0) is automatically managed by the provider.
    let builder = provider.send_transaction(tx.clone()).await?;
    let node_hash = *builder.tx_hash();
    let pending_tx =
        provider.get_transaction_by_hash(node_hash).await?.expect("Transaction not found");
    assert_eq!(pending_tx.nonce, 0);

    println!("Transaction sent with nonce: {}", pending_tx.nonce);

    // Send the transaction, the nonce (1) is automatically managed by the provider.
    let builder = provider.send_transaction(tx).await?;
    let node_hash = *builder.tx_hash();
    let pending_tx =
        provider.get_transaction_by_hash(node_hash).await?.expect("Transaction not found");
    assert_eq!(pending_tx.nonce, 1);

    println!("Transaction sent with nonce: {}", pending_tx.nonce);

    Ok(())
}</code></pre>
<p>åœ¨ Github ä¸ŠæŸ¥çœ‹æºä»£ç  <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/fillers/examples/nonce_filler.rs" title="" target="_blank">æ­¤å¤„</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><!-- DO NOT EDIT THIS FILE. IT IS GENERATED BY RUNNING `./scripts/update.sh` -->
<!-- ANY CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN -->
<!-- EDIT OR CREATE THIS TEMPLATE INSTEAD: ./src/templates/fillers/recommended_fillers.md -->
<!-- LATEST UPDATE: https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="ç¤ºä¾‹-recommended_fillers-2"><a class="header" href="#ç¤ºä¾‹-recommended_fillers-2">ç¤ºä¾‹: <code>recommended_fillers</code></a></h2>
<h3 id="ç¤ºä¾‹-38"><a class="header" href="#ç¤ºä¾‹-38">ç¤ºä¾‹</a></h3>
<p>è¦è¿è¡Œè¿™ä¸ªç¤ºä¾‹:</p>
<ul>
<li>å…‹éš† <a href="https://github.com/alloy-rs/examples" title="" target="_blank">examples</a> ä»“åº“: <code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>è¿è¡Œ: <code>cargo run --example recommended_fillers</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example of using the `.with_recommended_fillers()` method in the provider.

use alloy::{
    network::{EthereumWallet, TransactionBuilder},
    node_bindings::Anvil,
    primitives::{address, U256},
    providers::{Provider, ProviderBuilder},
    rpc::types::request::TransactionRequest,
    signers::local::PrivateKeySigner,
};
use eyre::Result;

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    // Spin up a local Anvil node.
    // Ensure `anvil` is available in $PATH.
    let anvil = Anvil::new().try_spawn()?;

    // Set up signer from the first default Anvil account (Alice).
    let signer: PrivateKeySigner = anvil.keys()[0].clone().into();
    let wallet = EthereumWallet::from(signer);

    // Create a provider with the wallet.
    let rpc_url = anvil.endpoint().parse()?;
    let provider = ProviderBuilder::new()
        // Adds the `ChainIdFiller`, `GasFiller` and the `NonceFiller` layers.
        .with_recommended_fillers()
        .wallet(wallet)
        .on_http(rpc_url);

    // Build an EIP-1559 type transaction to send 100 wei to Vitalik.
    // Notice that the `nonce` field is set by the `NonceFiller`.
    // Notice that the gas related fields are set by the `GasFiller`.
    // Notice that the `chain_id` field is set by the `ChainIdFiller`.
    let vitalik = address!("d8dA6BF26964aF9D7eEd9e03E53415D37aA96045");
    let tx = TransactionRequest::default().with_to(vitalik).with_value(U256::from(100));

    // Send the transaction, the nonce (0) is automatically managed by the provider.
    let builder = provider.send_transaction(tx.clone()).await?;
    let node_hash = *builder.tx_hash();
    let pending_tx =
        provider.get_transaction_by_hash(node_hash).await?.expect("Pending transaction not found");
    assert_eq!(pending_tx.nonce, 0);

    println!("Transaction sent with nonce: {}", pending_tx.nonce);

    // Send the transaction, the nonce (1) is automatically managed by the provider.
    let builder = provider.send_transaction(tx).await?;
    let node_hash = *builder.tx_hash();
    let pending_tx =
        provider.get_transaction_by_hash(node_hash).await?.expect("Pending transaction not found");
    assert_eq!(pending_tx.nonce, 1);

    println!("Transaction sent with nonce: {}", pending_tx.nonce);

    Ok(())
}</code></pre>
<p>åœ¨ Github ä¸Šæ‰¾åˆ°æºä»£ç  <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/fillers/examples/recommended_fillers.rs" title="" target="_blank">here</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><!-- DO NOT EDIT THIS FILE. IT IS GENERATED BY RUNNING `./scripts/update.sh` -->
<!-- ANY CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN -->
<!-- EDIT OR CREATE THIS TEMPLATE INSTEAD: ./src/templates/fillers/wallet_filler.md -->
<!-- LATEST UPDATE: https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="ç¤ºä¾‹-wallet_filler-1"><a class="header" href="#ç¤ºä¾‹-wallet_filler-1">ç¤ºä¾‹: <code>wallet_filler</code></a></h2>
<h3 id="ç¤ºä¾‹-39"><a class="header" href="#ç¤ºä¾‹-39">ç¤ºä¾‹</a></h3>
<p>è¦è¿è¡Œæ­¤ç¤ºä¾‹ï¼š</p>
<ul>
<li>å…‹éš† <a href="https://github.com/alloy-rs/examples" title="" target="_blank">examples</a> ä»“åº“ï¼š<code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>è¿è¡Œï¼š<code>cargo run --example wallet_filler</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example of using the `WalletFiller` in the provider.

use alloy::{
    network::{EthereumWallet, TransactionBuilder},
    node_bindings::Anvil,
    primitives::{address, b256, U256},
    providers::{Provider, ProviderBuilder},
    rpc::types::request::TransactionRequest,
    signers::local::PrivateKeySigner,
};
use eyre::Result;

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    // Spin up a local Anvil node.
    // Ensure `anvil` is available in $PATH.
    let anvil = Anvil::new().try_spawn()?;

    // Set up signer from the first default Anvil account (Alice).
    let signer: PrivateKeySigner = anvil.keys()[0].clone().into();
    let wallet = EthereumWallet::from(signer);

    // Create a provider with the wallet.
    let rpc_url = anvil.endpoint().parse()?;
    let provider = ProviderBuilder::new()
        // Add the `WalletFiller` to the provider
        .wallet(wallet)
        .on_http(rpc_url);

    // Build a legacy type transaction to send 100 wei to Vitalik.
    let vitalik = address!("d8dA6BF26964aF9D7eEd9e03E53415D37aA96045");
    let tx = TransactionRequest::default()
        .with_to(vitalik)
        .with_value(U256::from(100))
        // Notice that without the `NonceFiller`, you need to manually set the nonce field.
        .with_nonce(0)
        // Notice that without the `GasFiller`, you need to set the gas related fields.
        .with_gas_price(20_000_000_000)
        .with_gas_limit(21_000);

    let builder = provider.send_transaction(tx).await?;
    let node_hash = *builder.tx_hash();

    println!(
        "Node hash matches expected hash: {}",
        node_hash == b256!("eb56033eab0279c6e9b685a5ec55ea0ff8d06056b62b7f36974898d4fbb57e64")
    );

    // Send the transaction and wait for the broadcast.
    let pending_tx = builder.register().await?;

    println!("Pending transaction hash matches node hash: {}", *pending_tx.tx_hash() == node_hash);

    let tx_hash = pending_tx.await?;
    assert_eq!(tx_hash, node_hash);

    println!("Transaction hash matches node hash: {}", tx_hash == node_hash);

    // Wait for the transaction to be included and get the receipt.
    let receipt =
        provider.get_transaction_receipt(tx_hash).await?.expect("Transaction receipt not found");
    let receipt_hash = receipt.transaction_hash;
    assert_eq!(receipt_hash, node_hash);

    println!("Transaction receipt hash matches node hash: {}", receipt_hash == node_hash);

    Ok(())
}</code></pre>
<p>åœ¨ Github ä¸Šå¯ä»¥æ‰¾åˆ°æºä»£ç  <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/fillers/examples/wallet_filler.rs" title="" target="_blank">here</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="å±‚"><a class="header" href="#å±‚">å±‚</a></h2>
<ul>
<li><a href="examples/layers/logging_layer.html">æ—¥å¿—å±‚</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><!-- DO NOT EDIT THIS FILE. IT IS GENERATED BY RUNNING `./scripts/update.sh` -->
<!-- ANY CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN -->
<!-- EDIT OR CREATE THIS TEMPLATE INSTEAD: ./src/templates/layers/logging_layer.md -->
<!-- LATEST UPDATE: https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="ç¤ºä¾‹-logging_layer"><a class="header" href="#ç¤ºä¾‹-logging_layer">ç¤ºä¾‹: <code>logging_layer</code></a></h2>
<h3 id="ç¤ºä¾‹-40"><a class="header" href="#ç¤ºä¾‹-40">ç¤ºä¾‹</a></h3>
<p>è¿è¡Œè¿™ä¸ªä¾‹å­:</p>
<ul>
<li>å…‹éš† <a href="https://github.com/alloy-rs/examples" title="" target="_blank">examples</a> ä»“åº“: <code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>è¿è¡Œ: <code>cargo run --example logging_layer</code></li>
</ul>
<pre><code class="language-rust ignore">//! This examples demonstrates how to implement your own custom transport layer.
//! As a demonstration we implement a simple request / response logging layer.

use alloy::{
    node_bindings::Anvil,
    providers::{Provider, ProviderBuilder},
    rpc::{
        client::ClientBuilder,
        json_rpc::{RequestPacket, ResponsePacket},
    },
    transports::TransportError,
};
use eyre::Result;
use std::{
    fmt::Debug,
    future::{Future, IntoFuture},
    pin::Pin,
    task::{Context, Poll},
};
use tower::{Layer, Service};

struct LoggingLayer;

// Implement tower::Layer for LoggingLayer.
impl&lt;S&gt; Layer&lt;S&gt; for LoggingLayer {
    type Service = LoggingService&lt;S&gt;;

    fn layer(&amp;self, inner: S) -&gt; Self::Service {
        LoggingService { inner }
    }
}

// A logging service that wraps an inner service.
#[derive(Debug, Clone)]
struct LoggingService&lt;S&gt; {
    inner: S,
}

// Implement tower::Service for LoggingService.
impl&lt;S&gt; Service&lt;RequestPacket&gt; for LoggingService&lt;S&gt;
where
    // Constraints on the service.
    S: Service&lt;RequestPacket, Response = ResponsePacket, Error = TransportError&gt;,
    S::Future: Send + 'static,
    S::Response: Send + 'static + Debug,
    S::Error: Send + 'static + Debug,
{
    type Response = S::Response;
    type Error = S::Error;
    type Future = Pin&lt;Box&lt;dyn Future&lt;Output = Result&lt;Self::Response, Self::Error&gt;&gt; + Send&gt;&gt;;

    fn poll_ready(&amp;mut self, cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;Result&lt;(), Self::Error&gt;&gt; {
        self.inner.poll_ready(cx)
    }

    fn call(&amp;mut self, req: RequestPacket) -&gt; Self::Future {
        println!("Request: {req:?}");

        let fut = self.inner.call(req);

        Box::pin(async move {
            let res = fut.await;

            println!("Response: {res:?}");

            res
        })
    }
}

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    let anvil = Anvil::new().spawn();
    let client = ClientBuilder::default().layer(LoggingLayer).http(anvil.endpoint_url());

    let provider = ProviderBuilder::new().on_client(client);

    for _ in 0..10 {
        let _block_number = provider.get_block_number().into_future().await?;
    }

    Ok(())
}</code></pre>
<p>åœ¨ Github ä¸Šå¯ä»¥æ‰¾åˆ°æºç  <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/layers/examples/logging_layer.rs" title="" target="_blank">here</a>ã€‚</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="åŸå§‹æ•°æ®ç±»å‹"><a class="header" href="#åŸå§‹æ•°æ®ç±»å‹">åŸå§‹æ•°æ®ç±»å‹</a></h2>
<ul>
<li><a href="examples/primitives/bytes_and_address_types.html">å­—èŠ‚å’Œåœ°å€ç±»å‹</a></li>
<li><a href="examples/primitives/hashing_functions.html">å“ˆå¸Œå‡½æ•°</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><!-- DO NOT EDIT THIS FILE. IT IS GENERATED BY RUNNING `./scripts/update.sh` -->
<!-- ANY CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN -->
<!-- EDIT OR CREATE THIS TEMPLATE INSTEAD: ./src/templates/primitives/bytes_and_address_types.md -->
<!-- LATEST UPDATE: https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="ç¤ºä¾‹-bytes_and_address_types-1"><a class="header" href="#ç¤ºä¾‹-bytes_and_address_types-1">ç¤ºä¾‹: <code>bytes_and_address_types</code></a></h2>
<h3 id="ç¤ºä¾‹-41"><a class="header" href="#ç¤ºä¾‹-41">ç¤ºä¾‹</a></h3>
<p>è¦è¿è¡Œæ­¤ç¤ºä¾‹ï¼š</p>
<ul>
<li>å…‹éš† <a href="https://github.com/alloy-rs/examples" title="" target="_blank">examples</a> ä»“åº“ï¼š<code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>è¿è¡Œï¼š<code>cargo run --example bytes_and_address_types</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example of basic usage of bytes and address types and macros.

use alloy::primitives::{
    address, b128, b256, b512, b64, bytes, fixed_bytes, Address, Bytes, FixedBytes,
};
use eyre::Result;

fn main() -&gt; Result&lt;()&gt; {
    // Bytes type
    let a = bytes!("0123abcd");
    assert_eq!(a, Bytes::from(&amp;[0x01, 0x23, 0xab, 0xcd]));
    assert_eq!(a.len(), 4);

    // Address type
    let b = address!("f39Fd6e51aad88F6F4ce6aB8827279cffFb92266");
    assert_eq!(
        b,
        Address::from(&amp;[
            0xf3, 0x9f, 0xd6, 0xe5, 0x1a, 0xad, 0x88, 0xf6, 0xf4, 0xce, 0x6a, 0xb8, 0x82, 0x72,
            0x79, 0xcf, 0xff, 0xb9, 0x22, 0x66
        ])
    );
    assert_eq!(b.len(), 20);

    // FixedBytes&lt;8&gt; type
    let c = b64!("0102030405060708");
    assert_eq!(c, FixedBytes::from(&amp;[0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08]));
    assert_eq!(c.len(), 8);

    // FixedBytes&lt;16&gt; type
    let d = b128!("0102030405060708090a0b0c0d0e0f10");
    assert_eq!(
        d,
        FixedBytes::from(&amp;[
            0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e,
            0x0f, 0x10,
        ])
    );
    assert_eq!(d.len(), 16);

    // FixedBytes&lt;32&gt; type
    let e = b256!("0102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f20");
    assert_eq!(
        e,
        FixedBytes::from(&amp;[
            0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e,
            0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c,
            0x1d, 0x1e, 0x1f, 0x20,
        ]),
    );
    assert_eq!(e.len(), 32);

    // FixedBytes&lt;64&gt; type
    let f = b512!("0102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f202122232425262728292a2b2c2d2e2f303132333435363738393a3b3c3d3e3f40");
    assert_eq!(
        f,
        FixedBytes::from(&amp;[
            0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e,
            0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c,
            0x1d, 0x1e, 0x1f, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a,
            0x2b, 0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38,
            0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f, 0x40,
        ]),
    );
    assert_eq!(f.len(), 64);

    // FixedBytes&lt;20&gt; type, determined by the length of the input
    let g = fixed_bytes!("0102030405060708090a0b0c0d0e0f1011121314");
    assert_eq!(
        g,
        FixedBytes::from(&amp;[
            0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e,
            0x0f, 0x10, 0x11, 0x12, 0x13, 0x14,
        ]),
    );
    assert_eq!(g.len(), 20);

    Ok(())
}</code></pre>
<p>åœ¨ Github ä¸Šå¯ä»¥æ‰¾åˆ°æºç  <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/primitives/examples/bytes_and_address_types.rs" title="" target="_blank">here</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><!-- DO NOT EDIT THIS FILE. IT IS GENERATED BY RUNNING `./scripts/update.sh` -->
<!-- ANY CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN -->
<!-- EDIT OR CREATE THIS TEMPLATE INSTEAD: ./src/templates/primitives/hashing_functions.md -->
<!-- LATEST UPDATE: https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="ç¤ºä¾‹-hashing_functions-å“ˆå¸Œå‡½æ•°-1"><a class="header" href="#ç¤ºä¾‹-hashing_functions-å“ˆå¸Œå‡½æ•°-1">ç¤ºä¾‹: <code>hashing_functions</code> å“ˆå¸Œå‡½æ•°</a></h2>
<h3 id="ç¤ºä¾‹-42"><a class="header" href="#ç¤ºä¾‹-42">ç¤ºä¾‹</a></h3>
<p>è¦è¿è¡Œè¿™ä¸ªç¤ºä¾‹ï¼š</p>
<ul>
<li>å…‹éš† <a href="https://github.com/alloy-rs/examples" title="" target="_blank">examples</a> ä»£ç åº“: <code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>è¿è¡Œ: <code>cargo run --example hashing_functions</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example of basic usage of hashing functions.

use alloy::primitives::{eip191_hash_message, keccak256};
use eyre::{Ok, Result};

fn main() -&gt; Result&lt;()&gt; {
    // [`Keccak-256`]: https://en.wikipedia.org/wiki/SHA-3
    let hash = keccak256(b"hello world");
    assert_eq!(
        hash.to_string(),
        "0x47173285a8d7341e5e972fc677286384f802f8ef42a5ec5f03bbfa254cb01fad"
    );
    assert_eq!(hash.len(), 32);

    // Hash a message according to [EIP-191] (version `0x01`).
    //
    // The final message is a UTF-8 string, encoded as follows:
    // `"\x19Ethereum Signed Message:\n" + message.length + message`
    //
    // This message is then hashed using [`Keccak-256`]: https://en.wikipedia.org/wiki/SHA-3.
    //
    // [EIP-191]: https://eips.ethereum.org/EIPS/eip-191
    let eip191_hash = eip191_hash_message(b"hello_world");
    assert_eq!(
        eip191_hash.to_string(),
        "0xd52de6e039c023a7c77752126e4d9d99e2a7dacea3d19e97e9c2ebcb3ecf1c00"
    );
    assert_eq!(eip191_hash.len(), 32);

    Ok(())
}</code></pre>
<p>åœ¨ Github ä¸Šæ‰¾åˆ°æºç  <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/primitives/examples/hashing_functions.rs" title="" target="_blank">è¿™é‡Œ</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="providers"><a class="header" href="#providers">Providers</a></h2>
<ul>
<li><a href="examples/providers/builder.html">Builder</a></li>
<li><a href="examples/providers/builtin.html">Builtin</a></li>
<li><a href="examples/providers/http.html" title="" target="_blank">HTTP</a></li>
<li><a href="examples/providers/ws.html">WS</a></li>
<li><a href="examples/providers/ws_with_auth.html">WS with authentication</a></li>
<li><a href="examples/providers/ipc.html">IPC</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><!-- DO NOT EDIT THIS FILE. IT IS GENERATED BY RUNNING `./scripts/update.sh` -->
<!-- ANY CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN -->
<!-- EDIT OR CREATE THIS TEMPLATE INSTEAD: ./src/templates/providers/builder.md -->
<!-- LATEST UPDATE: https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="ç¤ºä¾‹builder"><a class="header" href="#ç¤ºä¾‹builder">ç¤ºä¾‹ï¼š<code>builder</code></a></h2>
<h3 id="ç¤ºä¾‹-43"><a class="header" href="#ç¤ºä¾‹-43">ç¤ºä¾‹</a></h3>
<p>è¦è¿è¡Œè¿™ä¸ªç¤ºä¾‹ï¼š</p>
<ul>
<li>å…‹éš† <a href="https://github.com/alloy-rs/examples" title="" target="_blank">examples</a> ä»“åº“ï¼š<code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>æ‰§è¡Œï¼š<code>cargo run --example builder</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example of using the `ProviderBuilder` to create a provider with a signer and network.

use alloy::{
    network::{EthereumWallet, TransactionBuilder},
    node_bindings::Anvil,
    primitives::U256,
    providers::{Provider, ProviderBuilder},
    rpc::types::TransactionRequest,
    signers::local::PrivateKeySigner,
};
use eyre::Result;

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    // Spin up a local Anvil node.
    // Ensure `anvil` is available in $PATH.
    let anvil = Anvil::new().block_time(1).try_spawn()?;

    // Set up signer from the first default Anvil account (Alice).
    let signer: PrivateKeySigner = anvil.keys()[0].clone().into();
    let wallet = EthereumWallet::from(signer.clone());

    // Create two users, Alice and Bob.
    let alice = signer.address();
    let bob = anvil.addresses()[1];

    // Set up the HTTP provider with the `reqwest` crate.
    let rpc_url = anvil.endpoint().parse()?;
    let provider =
        ProviderBuilder::new().with_recommended_fillers().wallet(wallet).on_http(rpc_url);

    // Create a transaction.
    let tx = TransactionRequest::default().with_to(bob).with_value(U256::from(100));

    // Send the transaction and wait for the broadcast.
    let pending_tx = provider.send_transaction(tx).await?;

    println!("Pending transaction... {}", pending_tx.tx_hash());

    // Wait for the transaction to be included and get the receipt.
    let receipt = pending_tx.get_receipt().await?;

    println!(
        "Transaction included in block {}",
        receipt.block_number.expect("Failed to get block number")
    );

    assert_eq!(receipt.from, alice);
    assert_eq!(receipt.to, Some(bob));

    Ok(())
}</code></pre>
<p>åœ¨ Github ä¸ŠæŸ¥çœ‹æºä»£ç  <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/providers/examples/builder.rs" title="" target="_blank">è¿™é‡Œ</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><!-- DO NOT EDIT THIS FILE. IT IS GENERATED BY RUNNING `./scripts/update.sh` -->
<!-- ANY CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN -->
<!-- EDIT OR CREATE THIS TEMPLATE INSTEAD: ./src/templates/providers/builtin.md -->
<!-- LATEST UPDATE: https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="ç¤ºä¾‹-builtin"><a class="header" href="#ç¤ºä¾‹-builtin">ç¤ºä¾‹: <code>builtin</code></a></h2>
<h3 id="ç¤ºä¾‹-44"><a class="header" href="#ç¤ºä¾‹-44">ç¤ºä¾‹</a></h3>
<p>è¿è¡Œæ­¤ç¤ºä¾‹:</p>
<ul>
<li>å…‹éš† <a href="https://github.com/alloy-rs/examples" title="" target="_blank">examples</a> ä»“åº“: <code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>è¿è¡Œ: <code>cargo run --example builtin</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example of using the `on_builtin` method in the provider.

use alloy::{
    node_bindings::Anvil,
    providers::{Provider, ProviderBuilder},
};
use eyre::Result;
use futures_util::StreamExt;

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    let anvil = Anvil::new().block_time(1).try_spawn()?;

    // Instantiate a HTTP transport provider by passing the HTTP endpoint url
    let http_rpc_url = anvil.endpoint();
    let http_provider = ProviderBuilder::new().on_builtin(&amp;http_rpc_url).await?;

    // Get latest block number
    let block_number = http_provider.get_block_number().await?;

    println!("Latest block number: {block_number:?}");

    // This requires the `pubsub` and `ws` features to be enabled on alloy-provider
    let ws_rpc_url = anvil.ws_endpoint();
    let ws_provider = ProviderBuilder::new().on_builtin(&amp;ws_rpc_url).await?;

    let sub = ws_provider.subscribe_blocks().await?;

    let mut stream = sub.into_stream().take(2);

    println!("Awaiting blocks...");

    let handle = tokio::spawn(async move {
        while let Some(block) = stream.next().await {
            println!("{}", block.header.number.expect("Failed to get block number"));
        }
    });

    handle.await?;

    // This requires the `pubsub` and `ipc` features to be enabled on alloy-provider
    // This would throw a runtime error if the ipc does not exist
    let ipc_path = "/tmp/reth.ipc";
    let ipc_provider = ProviderBuilder::new().on_builtin(ipc_path).await?;

    let _block_number = ipc_provider.get_block_number().await?;

    Ok(())
}</code></pre>
<p>åœ¨ Github ä¸Šæ‰¾åˆ°æºä»£ç  <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/providers/examples/builtin.rs" title="" target="_blank">here</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><!-- è¯·å‹¿ç¼–è¾‘æ­¤æ–‡ä»¶ã€‚å®ƒæ˜¯é€šè¿‡è¿è¡Œ `./scripts/update.sh` ç”Ÿæˆçš„ -->
<!-- å¯¹æ­¤æ–‡ä»¶çš„ä»»ä½•æ›´æ”¹éƒ½å°†è¢«è¦†ç›– -->
<!-- è¯·æ”¹ä¸ºç¼–è¾‘æˆ–åˆ›å»ºæ­¤æ¨¡æ¿: ./src/templates/providers/http.md -->
<!-- æœ€æ–°æ›´æ–°: https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="ç¤ºä¾‹-http-1"><a class="header" href="#ç¤ºä¾‹-http-1">ç¤ºä¾‹: <code>http</code></a></h2>
<h3 id="ç¤ºä¾‹-45"><a class="header" href="#ç¤ºä¾‹-45">ç¤ºä¾‹</a></h3>
<p>è¦è¿è¡Œæ­¤ç¤ºä¾‹ï¼š</p>
<ul>
<li>å…‹éš† <a href="https://github.com/alloy-rs/examples" title="" target="_blank">examples</a> ä»“åº“: <code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>è¿è¡Œ: <code>cargo run --example http</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example of using the HTTP provider with the `reqwest` crate to get the latest block number.

use alloy::providers::{Provider, ProviderBuilder};
use eyre::Result;

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    // Set up the HTTP transport which is consumed by the RPC client.
    let rpc_url = "https://eth.merkle.io".parse()?;

    // Create a provider with the HTTP transport using the `reqwest` crate.
    let provider = ProviderBuilder::new().on_http(rpc_url);

    // Get latest block number.
    let latest_block = provider.get_block_number().await?;

    println!("Latest block number: {latest_block}");

    Ok(())
}</code></pre>
<p>åœ¨ Github ä¸Šæ‰¾åˆ°æºä»£ç  <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/providers/examples/http.rs" title="" target="_blank">here</a>ã€‚</p>
<div style="break-before: page; page-break-before: always;"></div><!-- DO NOT EDIT THIS FILE. IT IS GENERATED BY RUNNING `./scripts/update.sh` -->
<!-- ANY CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN -->
<!-- EDIT OR CREATE THIS TEMPLATE INSTEAD: ./src/templates/providers/ws.md -->
<!-- LATEST UPDATE: https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="ç¤ºä¾‹-ws-1"><a class="header" href="#ç¤ºä¾‹-ws-1">ç¤ºä¾‹: <code>ws</code></a></h2>
<h3 id="ç¤ºä¾‹-46"><a class="header" href="#ç¤ºä¾‹-46">ç¤ºä¾‹</a></h3>
<p>è¦è¿è¡Œè¿™ä¸ªç¤ºä¾‹ï¼š</p>
<ul>
<li>å…‹éš† <a href="https://github.com/alloy-rs/examples" title="" target="_blank">examples</a> ä»“åº“ï¼š<code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>è¿è¡Œï¼š<code>cargo run --example ws</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example of using the WS provider to subscribe to new blocks.

use alloy::providers::{Provider, ProviderBuilder, WsConnect};
use eyre::Result;
use futures_util::StreamExt;

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    // Set up the WS transport which is consumed by the RPC client.
    let rpc_url = "wss://eth-mainnet.g.alchemy.com/v2/your-api-key";

    // Create the provider.
    let ws = WsConnect::new(rpc_url);
    let provider = ProviderBuilder::new().on_ws(ws).await?;

    // Subscribe to new blocks.
    let sub = provider.subscribe_blocks().await?;

    // Wait and take the next 4 blocks.
    let mut stream = sub.into_stream().take(4);

    println!("Awaiting blocks...");

    // Take the stream and print the block number upon receiving a new block.
    let handle = tokio::spawn(async move {
        while let Some(block) = stream.next().await {
            println!(
                "Latest block number: {}",
                block.header.number.expect("Failed to get block number")
            );
        }
    });

    handle.await?;

    Ok(())
}</code></pre>
<p>åœ¨ Github ä¸Šæ‰¾åˆ°æºä»£ç  <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/providers/examples/ws.rs" title="" target="_blank">è¿™é‡Œ</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><!-- DO NOT EDIT THIS FILE. IT IS GENERATED BY RUNNING `./scripts/update.sh` -->
<!-- ANY CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN -->
<!-- EDIT OR CREATE THIS TEMPLATE INSTEAD: ./src/templates/providers/ws_with_auth.md -->
<!-- LATEST UPDATE: https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="ç¤ºä¾‹ws_with_auth-1"><a class="header" href="#ç¤ºä¾‹ws_with_auth-1">ç¤ºä¾‹ï¼š<code>ws_with_auth</code></a></h2>
<h3 id="ç¤ºä¾‹-47"><a class="header" href="#ç¤ºä¾‹-47">ç¤ºä¾‹</a></h3>
<p>è¿è¡Œæ­¤ç¤ºä¾‹ï¼š</p>
<ul>
<li>å…‹éš† <a href="https://github.com/alloy-rs/examples" title="" target="_blank">examples</a> ä»“åº“ï¼š<code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>è¿è¡Œï¼š<code>cargo run --example ws_with_auth</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example of using the WS provider with auth to subscribe to new blocks.

use alloy::{
    providers::{Provider, ProviderBuilder, WsConnect},
    transports::Authorization,
};
use eyre::Result;
use futures_util::StreamExt;

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    // Set up the WS transport which is consumed by the RPC client.
    let rpc_url = "wss://your-ws-endpoint.com/";

    // Create authorization methods.
    let auth = Authorization::basic("username", "password");
    let auth_bearer = Authorization::bearer("bearer-token");

    // Create the WS connection object with authentication.
    let ws_basic = WsConnect::with_auth(rpc_url, Some(auth));
    let ws_bearer = WsConnect::with_auth(rpc_url, Some(auth_bearer));

    // Create the provider.
    let provider_basic = ProviderBuilder::new().on_ws(ws_basic).await?;
    let provider_bearer = ProviderBuilder::new().on_ws(ws_bearer).await?;

    // Subscribe to new blocks.
    let sub_basic = provider_basic.subscribe_blocks();
    let sub_bearer = provider_bearer.subscribe_blocks();

    // Wait and take the next 4 blocks.
    let mut stream_basic = sub_basic.await?.into_stream().take(4);
    let mut stream_bearer = sub_bearer.await?.into_stream().take(4);

    println!("Awaiting blocks...");

    // Take the basic stream and print the block number upon receiving a new block.
    let basic_handle = tokio::spawn(async move {
        while let Some(block) = stream_basic.next().await {
            println!(
                "Latest block number (basic): {}",
                block.header.number.expect("Failed to get block number")
            );
        }
    });

    // Take the bearer stream and print the block number upon receiving a new block.
    let bearer_handle = tokio::spawn(async move {
        while let Some(block) = stream_bearer.next().await {
            println!(
                "Latest block number (bearer): {}",
                block.header.number.expect("Failed to get block number")
            );
        }
    });

    // Wait for both tasks to complete.
    let _ = tokio::try_join!(basic_handle, bearer_handle)?;

    Ok(())
}</code></pre>
<p>å¯ä»¥åœ¨ Github ä¸Šæ‰¾åˆ°æºç  <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/providers/examples/ws_with_auth.rs" title="" target="_blank">here</a>ã€‚</p>
<div style="break-before: page; page-break-before: always;"></div><!-- è¯·å‹¿ç¼–è¾‘æ­¤æ–‡ä»¶ã€‚å®ƒæ˜¯é€šè¿‡è¿è¡Œ `./scripts/update.sh` è‡ªåŠ¨ç”Ÿæˆçš„ -->
<!-- å¯¹è¯¥æ–‡ä»¶è¿›è¡Œçš„ä»»ä½•æ›´æ”¹éƒ½ä¼šè¢«è¦†ç›– -->
<!-- è¯·ç¼–è¾‘æˆ–åˆ›å»ºä»¥ä¸‹æ¨¡æ¿æ¥æ›¿ä»£ï¼š./src/templates/providers/ipc.md -->
<!-- æœ€æ–°æ›´æ–°ï¼š https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="ç¤ºä¾‹ipc-1"><a class="header" href="#ç¤ºä¾‹ipc-1">ç¤ºä¾‹ï¼š<code>ipc</code></a></h2>
<h3 id="ç¤ºä¾‹-48"><a class="header" href="#ç¤ºä¾‹-48">ç¤ºä¾‹</a></h3>
<p>è¿è¡Œæ­¤ç¤ºä¾‹ï¼š</p>
<ul>
<li>å…‹éš† <a href="https://github.com/alloy-rs/examples" title="" target="_blank">examples</a> ä»“åº“: <code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>è¿è¡Œ: <code>cargo run --example ipc</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example of using the IPC provider to get the latest block number.

use alloy::providers::{IpcConnect, Provider, ProviderBuilder};
use eyre::Result;

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    // Set up the IPC transport which is consumed by the RPC client.
    let ipc_path = "/tmp/reth.ipc";

    // Create the provider.
    let ipc = IpcConnect::new(ipc_path.to_string());
    let provider = ProviderBuilder::new().on_ipc(ipc).await?;

    let latest_block = provider.get_block_number().await?;

    println!("Latest block: {latest_block}");

    Ok(())
}</code></pre>
<p>åœ¨ Github ä¸ŠæŸ¥çœ‹æºä»£ç  <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/providers/examples/ipc.rs" title="" target="_blank">è¿™é‡Œ</a>ã€‚</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="queries"><a class="header" href="#queries">Queries</a></h2>
<ul>
<li><a href="examples/queries/query_contract_storage.html">æŸ¥è¯¢åˆçº¦å­˜å‚¨</a></li>
<li><a href="examples/queries/query_deployed_bytecode.html">æŸ¥è¯¢åˆçº¦å·²éƒ¨ç½²çš„å­—èŠ‚ç </a></li>
<li><a href="examples/queries/query_logs.html">æŸ¥è¯¢æ—¥å¿—</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><!-- è¯·å‹¿ç¼–è¾‘æ­¤æ–‡ä»¶ã€‚å®ƒæ˜¯é€šè¿‡è¿è¡Œ `./scripts/update.sh` ç”Ÿæˆçš„ -->
<!-- å¯¹æ­¤æ–‡ä»¶æ‰€åšçš„ä»»ä½•æ›´æ”¹éƒ½å°†è¢«è¦†ç›– -->
<!-- è¯·ç¼–è¾‘æˆ–åˆ›å»ºè¿™ä¸ªæ¨¡æ¿: ./src/templates/queries/query_contract_storage.md -->
<!-- æœ€æ–°æ›´æ–°: https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="ç¤ºä¾‹query_contract_storage-1"><a class="header" href="#ç¤ºä¾‹query_contract_storage-1">ç¤ºä¾‹ï¼š<code>query_contract_storage</code></a></h2>
<h3 id="ç¤ºä¾‹-49"><a class="header" href="#ç¤ºä¾‹-49">ç¤ºä¾‹</a></h3>
<p>è¦è¿è¡Œæ­¤ç¤ºä¾‹ï¼š</p>
<ul>
<li>å…‹éš† <a href="https://github.com/alloy-rs/examples" title="" target="_blank">examples</a> ä»“åº“: <code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>è¿è¡Œ: <code>cargo run --example query_contract_storage</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example of querying contract storage from the Ethereum network.

use alloy::{
    primitives::{address, U256},
    providers::{Provider, ProviderBuilder},
};
use eyre::Result;

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    // Create a provider.
    let rpc_url = "https://eth.merkle.io".parse()?;
    let provider = ProviderBuilder::new().on_http(rpc_url);

    // Get storage slot 0 from the Uniswap V3 USDC-ETH pool on Ethereum mainnet.
    let pool_address = address!("88e6A0c2dDD26FEEb64F039a2c41296FcB3f5640");
    let storage_slot = U256::from(0);
    // The provider calls the RPC at the latest block by default. A block can exlpicitly be set
    // using `.block()`.
    let storage = provider.get_storage_at(pool_address, storage_slot).await?;

    println!("Slot 0: {storage:?}");

    Ok(())
}</code></pre>
<p>åœ¨ Github ä¸ŠæŸ¥çœ‹æºä»£ç  <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/queries/examples/query_contract_storage.rs" title="" target="_blank">æ­¤å¤„</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><!-- DO NOT EDIT THIS FILE. IT IS GENERATED BY RUNNING `./scripts/update.sh` -->
<!-- ANY CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN -->
<!-- EDIT OR CREATE THIS TEMPLATE INSTEAD: ./src/templates/queries/query_deployed_bytecode.md -->
<!-- LATEST UPDATE: https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="ç¤ºä¾‹query_deployed_bytecode-1"><a class="header" href="#ç¤ºä¾‹query_deployed_bytecode-1">ç¤ºä¾‹ï¼š<code>query_deployed_bytecode</code></a></h2>
<h3 id="ç¤ºä¾‹-50"><a class="header" href="#ç¤ºä¾‹-50">ç¤ºä¾‹</a></h3>
<p>è¿è¡Œæ­¤ç¤ºä¾‹:</p>
<ul>
<li>å…‹éš† <a href="https://github.com/alloy-rs/examples" title="" target="_blank">examples</a> ä»“åº“: <code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>è¿è¡Œ: <code>cargo run --example query_deployed_bytecode</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example of querying deployed bytecode of a contract on the Ethereum network.

use alloy::{
    primitives::address,
    providers::{Provider, ProviderBuilder},
};
use eyre::Result;

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    // Create a provider.
    let rpc_url = "https://eth.merkle.io".parse()?;
    let provider = ProviderBuilder::new().on_http(rpc_url);

    // Get the bytecode of the Uniswap V3 USDC-ETH pool on Ethereum mainnet.
    let pool_address = address!("88e6A0c2dDD26FEEb64F039a2c41296FcB3f5640");
    let bytecode = provider.get_code_at(pool_address).await?;

    println!("Bytecode: {bytecode:?}");

    Ok(())
}</code></pre>
<p>åœ¨ Github ä¸Šæ‰¾åˆ°æºä»£ç  <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/queries/examples/query_deployed_bytecode.rs" title="" target="_blank">here</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><!-- DO NOT EDIT THIS FILE. IT IS GENERATED BY RUNNING `./scripts/update.sh` -->
<!-- ANY CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN -->
<!-- EDIT OR CREATE THIS TEMPLATE INSTEAD: ./src/templates/queries/query_logs.md -->
<!-- LATEST UPDATE: https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="ç¤ºä¾‹-query_logs-1"><a class="header" href="#ç¤ºä¾‹-query_logs-1">ç¤ºä¾‹: <code>query_logs</code></a></h2>
<h3 id="ç¤ºä¾‹-51"><a class="header" href="#ç¤ºä¾‹-51">ç¤ºä¾‹</a></h3>
<p>è¦è¿è¡Œæ­¤ç¤ºä¾‹ï¼š</p>
<ul>
<li>å…‹éš† <a href="https://github.com/alloy-rs/examples" title="" target="_blank">examples</a> ä»“åº“: <code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>è¿è¡Œ: <code>cargo run --example query_logs</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example of querying logs from the Ethereum network.

use alloy::{
    primitives::{address, b256},
    providers::{Provider, ProviderBuilder},
    rpc::types::Filter,
};
use eyre::Result;

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    // Create a provider.
    let rpc_url = "https://eth.merkle.io".parse()?;
    let provider = ProviderBuilder::new().on_http(rpc_url);

    // Get logs from the latest block
    let latest_block = provider.get_block_number().await?;

    // Create a filter to get all logs from the latest block.
    let filter = Filter::new().from_block(latest_block);

    // Get all logs from the latest block that match the filter.
    let logs = provider.get_logs(&amp;filter).await?;

    for log in logs {
        println!("{log:?}");
    }

    // Get all logs from the latest block that match the transfer event signature/topic.
    let transfer_event_signature =
        b256!("ddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef");
    let filter = Filter::new().event_signature(transfer_event_signature).from_block(latest_block);
    // You could also use the event name instead of the event signature like so:
    // .event("Transfer(address,address,uint256)")

    // Get all logs from the latest block that match the filter.
    let logs = provider.get_logs(&amp;filter).await?;

    for log in logs {
        println!("Transfer event: {log:?}");
    }

    // Get all logs from the latest block emitted by the UNI token address.
    let uniswap_token_address = address!("1f9840a85d5aF5bf1D1762F925BDADdC4201F984");
    let filter = Filter::new().address(uniswap_token_address).from_block(latest_block);

    // Get all logs from the latest block that match the filter.
    let logs = provider.get_logs(&amp;filter).await?;

    for log in logs {
        println!("Uniswap token logs: {log:?}");
    }

    Ok(())
}</code></pre>
<p>åœ¨ Github ä¸ŠæŸ¥çœ‹æºä»£ç  <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/queries/examples/query_logs.rs" title="" target="_blank">here</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="sol-å®"><a class="header" href="#sol-å®"><code>sol!</code> å®</a></h2>
<ul>
<li><a href="examples/sol-macro/contract.html">åˆçº¦</a></li>
<li><a href="examples/sol-macro/events_errors.html">äº‹ä»¶å’Œé”™è¯¯</a></li>
<li><a href="examples/sol-macro/structs_enums.html">ç»“æ„ä½“å’Œæšä¸¾</a></li>
<li><a href="examples/sol-macro/user_defined_types.html">ç”¨æˆ·å®šä¹‰ç±»å‹</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><!-- DO NOT EDIT THIS FILE. IT IS GENERATED BY RUNNING `./scripts/update.sh` -->
<!-- ANY CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN -->
<!-- EDIT OR CREATE THIS TEMPLATE INSTEAD: ./src/templates/contracts/deploy_from_contract.md -->
<!-- LATEST UPDATE: https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="ç¤ºä¾‹-deploy_from_contract-1"><a class="header" href="#ç¤ºä¾‹-deploy_from_contract-1">ç¤ºä¾‹ï¼š <code>deploy_from_contract</code></a></h2>
<h3 id="ç¤ºä¾‹-52"><a class="header" href="#ç¤ºä¾‹-52">ç¤ºä¾‹</a></h3>
<p>è¦è¿è¡Œè¿™ä¸ªç¤ºä¾‹ï¼š</p>
<ul>
<li>å…‹éš† <a href="https://github.com/alloy-rs/examples" title="" target="_blank">examples</a> ä»“åº“ï¼š<code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>è¿è¡Œï¼š<code>cargo run --example deploy_from_contract</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example of deploying a contract from Solidity code using the `sol!` macro to Anvil and
//! interacting with it.

use alloy::{
    network::EthereumWallet, node_bindings::Anvil, primitives::U256, providers::ProviderBuilder,
    signers::local::PrivateKeySigner, sol,
};
use eyre::Result;

// Codegen from embedded Solidity code and precompiled bytecode.
sol! {
    #[allow(missing_docs)]
    // solc v0.8.26; solc Counter.sol --via-ir --optimize --bin
    #[sol(rpc, bytecode="6080806040523460135760df908160198239f35b600080fdfe6080806040526004361015601257600080fd5b60003560e01c9081633fb5c1cb1460925781638381f58a146079575063d09de08a14603c57600080fd5b3460745760003660031901126074576000546000198114605e57600101600055005b634e487b7160e01b600052601160045260246000fd5b600080fd5b3460745760003660031901126074576020906000548152f35b34607457602036600319011260745760043560005500fea2646970667358221220e978270883b7baed10810c4079c941512e93a7ba1cd1108c781d4bc738d9090564736f6c634300081a0033")]
    contract Counter {
        uint256 public number;

        function setNumber(uint256 newNumber) public {
            number = newNumber;
        }

        function increment() public {
            number++;
        }
    }
}

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    // Spin up a local Anvil node.
    // Ensure `anvil` is available in $PATH.
    let anvil = Anvil::new().try_spawn()?;

    // Set up signer from the first default Anvil account (Alice).
    let signer: PrivateKeySigner = anvil.keys()[0].clone().into();
    let wallet = EthereumWallet::from(signer);

    // Create a provider with the wallet.
    let rpc_url = anvil.endpoint().parse()?;
    let provider =
        ProviderBuilder::new().with_recommended_fillers().wallet(wallet).on_http(rpc_url);

    println!("Anvil running at `{}`", anvil.endpoint());

    // Deploy the `Counter` contract.
    let contract = Counter::deploy(&amp;provider).await?;

    println!("Deployed contract at address: {}", contract.address());

    let builder = contract.setNumber(U256::from(42));
    let tx_hash = builder.send().await?.watch().await?;

    println!("Set number to 42: {tx_hash}");

    // Increment the number to 43.
    let builder = contract.increment();
    let tx_hash = builder.send().await?.watch().await?;

    println!("Incremented number: {tx_hash}");

    // Retrieve the number, which should be 43.
    let builder = contract.number();
    let number = builder.call().await?.number.to_string();

    println!("Retrieved number: {number}");

    Ok(())
}</code></pre>
<p>åœ¨ Github ä¸Šæ‰¾åˆ°æºä»£ç  <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/contracts/examples/deploy_from_contract.rs" title="" target="_blank">è¿™é‡Œ</a>ã€‚</p>
<div style="break-before: page; page-break-before: always;"></div><!-- DO NOT EDIT THIS FILE. IT IS GENERATED BY RUNNING `./scripts/update.sh` -->
<!-- ANY CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN -->
<!-- EDIT OR CREATE THIS TEMPLATE INSTEAD: ./src/templates/sol-macro/decode_returns.md -->
<!-- LATEST UPDATE: https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="ç¤ºä¾‹decode_returns"><a class="header" href="#ç¤ºä¾‹decode_returns">ç¤ºä¾‹ï¼š<code>decode_returns</code></a></h2>
<h3 id="ç¤ºä¾‹-53"><a class="header" href="#ç¤ºä¾‹-53">ç¤ºä¾‹</a></h3>
<p>è¦è¿è¡Œæ­¤ç¤ºä¾‹ï¼š</p>
<ul>
<li>å…‹éš† <a href="https://github.com/alloy-rs/examples" title="" target="_blank">examples</a> ä»“åº“: <code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>è¿è¡Œ: <code>cargo run --example decode_returns</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example showing how to decode return values from a call to a contract using the `sol!` macro.

use alloy::{
    hex,
    primitives::{I256, U256},
    sol,
    sol_types::SolCall,
};
use eyre::Result;

// Codegen from excerpt of Chainlink Aggregator interface.
// See: https://etherscan.io/address/0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419#code
sol!(
    #[allow(missing_docs)]
    #[derive(Debug, PartialEq, Eq)]
    function getRoundData(uint80 _roundId) external view returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);
);

fn main() -&gt; Result&lt;()&gt; {
    let result = getRoundDataCall::abi_decode_returns(
        &amp;hex!(
            "0000000000000000000000000000000000000000000000060000000000004716
             00000000000000000000000000000000000000000000000000000051faad1c80
             000000000000000000000000000000000000000000000000000000006669627b
             000000000000000000000000000000000000000000000000000000006669627b
             0000000000000000000000000000000000000000000000060000000000004716"
        ),
        true,
    );

    assert_eq!(
        result,
        Ok(getRoundDataReturn {
            roundId: 110680464442257327894_u128,
            answer: I256::from_dec_str("352098000000")?,
            startedAt: U256::from(1718182523),
            updatedAt: U256::from(1718182523),
            answeredInRound: 110680464442257327894_u128,
        })
    );

    Ok(())
}</code></pre>
<p>åœ¨ Github ä¸Šæ‰¾åˆ°æºä»£ç  <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/sol-macro/examples/decode_returns.rs" title="" target="_blank">è¿™é‡Œ</a>ã€‚</p>
<div style="break-before: page; page-break-before: always;"></div><!-- ä¸è¦ç¼–è¾‘æ­¤æ–‡ä»¶ã€‚å®ƒæ˜¯é€šè¿‡è¿è¡Œ `./scripts/update.sh` ç”Ÿæˆçš„ -->
<!-- å¯¹æ­¤æ–‡ä»¶çš„ä»»ä½•æ›´æ”¹éƒ½å°†è¢«è¦†ç›– -->
<!-- è¯·æ”¹ä¸ºç¼–è¾‘æˆ–åˆ›å»ºæ­¤æ¨¡æ¿ï¼š./src/templates/sol-macro/events_errors.md -->
<!-- æœ€æ–°æ›´æ–°: https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="ç¤ºä¾‹-events_errors"><a class="header" href="#ç¤ºä¾‹-events_errors">ç¤ºä¾‹: <code>events_errors</code></a></h2>
<h3 id="ç¤ºä¾‹-54"><a class="header" href="#ç¤ºä¾‹-54">ç¤ºä¾‹</a></h3>
<p>è¦è¿è¡Œæ­¤ç¤ºä¾‹ï¼š</p>
<ul>
<li>å…‹éš† <a href="https://github.com/alloy-rs/examples" title="" target="_blank">examples</a> ä»“åº“ï¼š<code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>è¿è¡Œï¼š<code>cargo run --example events_errors</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example showing how to decode events and errors from a contract using the `sol!` macro.

use alloy::{node_bindings::Anvil, providers::ProviderBuilder, sol};
use eyre::Result;
use futures_util::StreamExt;

// Generate a contract instance from Solidity.
sol!(
    #[allow(missing_docs)]
    #[sol(rpc, bytecode = "608060405260008055348015601357600080fd5b506103e9806100236000396000f3fe608060405234801561001057600080fd5b50600436106100575760003560e01c80632baeceb71461005c5780632ccbdbca1461006657806361bc221a14610070578063c3e8b5ca1461008e578063d09de08a14610098575b600080fd5b6100646100a2565b005b61006e610103565b005b61007861013e565b60405161008591906101f9565b60405180910390f35b610096610144565b005b6100a061017f565b005b60016000808282546100b49190610243565b925050819055506000543373ffffffffffffffffffffffffffffffffffffffff167fdc69c403b972fc566a14058b3b18e1513da476de6ac475716e489fae0cbe4a2660405160405180910390a3565b6040517f23b0db14000000000000000000000000000000000000000000000000000000008152600401610135906102e3565b60405180910390fd5b60005481565b6040517fa5f9ec670000000000000000000000000000000000000000000000000000000081526004016101769061034f565b60405180910390fd5b6001600080828254610191919061036f565b925050819055506000543373ffffffffffffffffffffffffffffffffffffffff167ff6d1d8d205b41f9fb9549900a8dba5d669d68117a3a2b88c1ebc61163e8117ba60405160405180910390a3565b6000819050919050565b6101f3816101e0565b82525050565b600060208201905061020e60008301846101ea565b92915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b600061024e826101e0565b9150610259836101e0565b92508282039050818112600084121682821360008512151617156102805761027f610214565b5b92915050565b600082825260208201905092915050565b7f4572726f72204100000000000000000000000000000000000000000000000000600082015250565b60006102cd600783610286565b91506102d882610297565b602082019050919050565b600060208201905081810360008301526102fc816102c0565b9050919050565b7f4572726f72204200000000000000000000000000000000000000000000000000600082015250565b6000610339600783610286565b915061034482610303565b602082019050919050565b600060208201905081810360008301526103688161032c565b9050919050565b600061037a826101e0565b9150610385836101e0565b9250828201905082811215600083121683821260008412151617156103ad576103ac610214565b5b9291505056fea2646970667358221220a878a3c1da1a1170e4496cdbc63bd5ed1587374bcd6cf6d4f1d5b88fa981795d64736f6c63430008190033")]
    contract CounterWithError {
        int256 public counter = 0;

        // Events - using `Debug` to print the events
        #[derive(Debug)]
        event Increment(address indexed by, int256 indexed value);
        #[derive(Debug)]
        event Decrement(address indexed by, int256 indexed value);

        // Custom Error
        error ErrorA(string message);
        error ErrorB(string message);

        // Functions
        function increment() public {
            counter += 1;
            emit Increment(msg.sender, counter);
        }

        function decrement() public {
            counter -= 1;
            emit Decrement(msg.sender, counter);
        }

        function revertA() public pure {
            revert ErrorA("Error A");
        }

        function revertB() public pure {
            revert ErrorB("Error B");
        }
    }
);

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    // Spin up a local Anvil node.
    let anvil = Anvil::new().try_spawn()?;

    // Create a provider with gas estimation.
    let rpc_url = anvil.endpoint().parse()?;
    let provider = ProviderBuilder::new().with_gas_estimation().on_http(rpc_url);

    // Deploy the `Counter` contract.
    let contract = CounterWithError::deploy(provider.clone()).await?;

    // Setup a filter for the Increment and Decrement events.
    let increment_filter = contract.Increment_filter().watch().await?;
    let decrement_filter = contract.Decrement_filter().watch().await?;

    // Convert to streams.
    let mut increment_stream = increment_filter.into_stream();
    let mut decrement_stream = decrement_filter.into_stream();

    // Call the increment and decrement functions.
    let increment_call = contract.increment();
    let decrement_call = contract.decrement();

    // Wait for the calls to be included.
    let _increment_res = increment_call.send().await?;
    let _decrement_res = decrement_call.send().await?;

    // Catch the events.
    for _ in 0..2 {
        let log = tokio::select! {
            Some(Ok((incr, log))) = increment_stream.next() =&gt; {
                println!("Increment: {incr:#?}");
                // Return raw log
                log
            }
            Some(Ok((decr, log))) = decrement_stream.next() =&gt; {
                println!("Decrement: {decr:#?}");
                // Return raw log
                log
            }
        };
        println!("Log: {log:#?}");
    }

    // Call the `revertA` function.
    let err_call = contract.revertA();
    let err_result = err_call.send().await;

    if let Err(err) = err_result {
        println!("Error A: {err:#?}");
    }

    // Call the `revertB` function.
    let err_call = contract.revertB();
    let err_result = err_call.send().await;

    if let Err(err) = err_result {
        println!("Error B: {err:#?}");
    }

    Ok(())
}</code></pre>
<p>åœ¨ Github ä¸Šæ‰¾åˆ°æºä»£ç  <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/sol-macro/examples/events_errors.rs" title="" target="_blank">here</a>ã€‚</p>
<div style="break-before: page; page-break-before: always;"></div><!-- DO NOT EDIT THIS FILE. IT IS GENERATED BY RUNNING `./scripts/update.sh` -->
<!-- ANY CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN -->
<!-- EDIT OR CREATE THIS TEMPLATE INSTEAD: ./src/templates/sol-macro/structs_enums.md -->
<!-- LATEST UPDATE: https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="example-structs_enums"><a class="header" href="#example-structs_enums">Example: <code>structs_enums</code></a></h2>
<h3 id="ç¤ºä¾‹-55"><a class="header" href="#ç¤ºä¾‹-55">ç¤ºä¾‹</a></h3>
<p>è¦è¿è¡Œæ­¤ç¤ºä¾‹ï¼š</p>
<ul>
<li>å…‹éš† <a href="https://github.com/alloy-rs/examples" title="" target="_blank">examples</a> ä»“åº“ï¼š<code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>è¿è¡Œï¼š<code>cargo run --example structs_enums</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example showing how to use the `sol!` macro to generate Rust bindings for Solidity structs and
//! enums.

use alloy::{primitives::U256, sol};
use eyre::Result;

// Generates Rust bindings for Solidity structs, enums and type aliases.
sol! {
    #[allow(missing_docs)]
    #[derive(Debug)]
    /// Foo
    struct Foo {
        uint256 a;
        uint64 b;
        Bar greater;
    }

    #[allow(missing_docs)]
    #[derive(Debug)]
    /// Bar
    enum Bar {
        A,
        B,
    }
}

fn main() -&gt; Result&lt;()&gt; {
    // Create an instance of the struct.
    let foo = Foo { a: U256::from(1), b: 2_u64, greater: Bar::A };

    println!("{foo:?}");

    Ok(())
}</code></pre>
<p>åœ¨ Github ä¸Šæ‰¾åˆ°æºä»£ç  <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/sol-macro/examples/structs_enums.rs" title="" target="_blank">here</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><!-- DO NOT EDIT THIS FILE. IT IS GENERATED BY RUNNING `./scripts/update.sh` -->
<!-- ANY CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN -->
<!-- EDIT OR CREATE THIS TEMPLATE INSTEAD: ./src/templates/sol-macro/user_defined_types.md -->
<!-- LATEST UPDATE: https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="ç¤ºä¾‹-user_defined_types"><a class="header" href="#ç¤ºä¾‹-user_defined_types">ç¤ºä¾‹: <code>user_defined_types</code></a></h2>
<h3 id="ç¤ºä¾‹-56"><a class="header" href="#ç¤ºä¾‹-56">ç¤ºä¾‹</a></h3>
<p>è¿è¡Œæ­¤ç¤ºä¾‹:</p>
<ul>
<li>å…‹éš† <a href="https://github.com/alloy-rs/examples" title="" target="_blank">examples</a> ä»“åº“: <code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>è¿è¡Œ: <code>cargo run --example user_defined_types</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example showing defining user defined value types and type aliases using the `sol!` macro.

use alloy::{
    primitives::{Address, U256},
    sol,
    sol_types::SolType,
};
use eyre::Result;

// Type definition: generates a new struct that implements `SolType`
sol! {
   /// Equivalent to `struct CustomType(U256)` in Rust
   type CustomType is uint256;
}

// Type aliases
type B32 = sol! { bytes32 };

// This is equivalent to the following:
// type B32 = alloy_sol_types::sol_data::FixedBytes&lt;32&gt;;

// User defined types
type CustomArrayOf&lt;T&gt; = sol! { T[] };
type CustomTuple = sol! { tuple(address, bytes, string) };

fn main() -&gt; Result&lt;()&gt; {
    let _b32_type = B32::abi_encode(&amp;[0; 32]);

    let _custom_type = CustomType(U256::from(1));

    let _custom_array_of_type = CustomArrayOf::&lt;sol!(bool)&gt;::abi_encode(&amp;vec![true, false]);

    let _custom_tuple_type =
        CustomTuple::abi_encode(&amp;(Address::ZERO, vec![0; 32], "hello".to_string()));

    Ok(())
}</code></pre>
<p>åœ¨ Github ä¸Šæ‰¾åˆ°æºç  <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/sol-macro/examples/user_defined_types.rs" title="" target="_blank">here</a>ã€‚</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="è®¢é˜…"><a class="header" href="#è®¢é˜…">è®¢é˜…</a></h2>
<ul>
<li><a href="examples/subscriptions/poll_logs.html">ç›‘æ§å’Œè½®è¯¢åˆçº¦äº‹ä»¶æ—¥å¿—</a></li>
<li><a href="examples/subscriptions/subscribe_blocks.html">è®¢é˜…å’Œç›‘æ§åŒºå—</a></li>
<li><a href="examples/subscriptions/subscribe_logs.html">è®¢é˜…å¹¶ç›‘å¬ç‰¹å®šçš„åˆçº¦äº‹ä»¶æ—¥å¿—</a></li>
<li><a href="examples/subscriptions/subscribe_all_logs.html">è®¢é˜…å¹¶ç›‘å¬æ‰€æœ‰åˆçº¦äº‹ä»¶æ—¥å¿—</a></li>
<li><a href="examples/subscriptions/subscribe_pending_transactions.html">è®¢é˜…å¹¶ç›‘å¬å…¬å…±å†…å­˜æ± ä¸­çš„å¾…å¤„ç†äº¤æ˜“</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><!-- DO NOT EDIT THIS FILE. IT IS GENERATED BY RUNNING `./scripts/update.sh` -->
<!-- ANY CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN -->
<!-- EDIT OR CREATE THIS TEMPLATE INSTEAD: ./src/templates/subscriptions/poll_logs.md -->
<!-- LATEST UPDATE: https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="ç¤ºä¾‹-poll_logs"><a class="header" href="#ç¤ºä¾‹-poll_logs">ç¤ºä¾‹: <code>poll_logs</code></a></h2>
<h3 id="ç¤ºä¾‹-57"><a class="header" href="#ç¤ºä¾‹-57">ç¤ºä¾‹</a></h3>
<p>è¿è¡Œæ­¤ç¤ºä¾‹ï¼š</p>
<ul>
<li>å…‹éš† <a href="https://github.com/alloy-rs/examples" title="" target="_blank">examples</a> ä»“åº“ï¼š<code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>è¿è¡Œï¼š<code>cargo run --example poll_logs</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example of watching and polling for contract events by `WebSocket` subscription.

use alloy::{
    node_bindings::Anvil,
    providers::{ProviderBuilder, WsConnect},
    sol,
};
use eyre::Result;
use futures_util::StreamExt;

// Codegen from embedded Solidity code and precompiled bytecode.
// solc v0.8.26; solc Counter.sol --via-ir --optimize --bin
sol!(
    #[allow(missing_docs)]
    #[sol(rpc, bytecode = "6080806040523460195760008055610155908161001f8239f35b600080fdfe6080604052600436101561001257600080fd5b60003560e01c80632baeceb7146100d057806361bc221a146100b25763d09de08a1461003d57600080fd5b346100ad5760003660031901126100ad57600054600181019060006001831291129080158216911516176100975780600055337ff6d1d8d205b41f9fb9549900a8dba5d669d68117a3a2b88c1ebc61163e8117ba600080a3005b634e487b7160e01b600052601160045260246000fd5b600080fd5b346100ad5760003660031901126100ad576020600054604051908152f35b346100ad5760003660031901126100ad5760005460001981019081136001166100975780600055337fdc69c403b972fc566a14058b3b18e1513da476de6ac475716e489fae0cbe4a26600080a300fea26469706673582212200d333e08e1230b0b9919825888e587a45c68e2aa2f7f58752712491e2201da9c64736f6c634300081a0033")]
    contract Counter {
        int256 public counter = 0;

        event Increment(address indexed by, int256 indexed value);
        event Decrement(address indexed by, int256 indexed value);

        function increment() public {
            counter += 1;
            emit Increment(msg.sender, counter);
        }

        function decrement() public {
            counter -= 1;
            emit Decrement(msg.sender, counter);
        }
    }
);

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    // Spin up a local Anvil node.
    // Ensure `anvil` is available in $PATH.
    let anvil = Anvil::new().block_time(1).try_spawn()?;

    // Create a WebSocket provider.
    let ws = WsConnect::new(anvil.ws_endpoint());
    let provider = ProviderBuilder::new().on_ws(ws).await?;

    // Deploy the `Counter` contract.
    let contract = Counter::deploy(provider.clone()).await?;

    println!("Deployed contract at: {}", contract.address());

    // Create filters for each event.
    let increment_filter = contract.Increment_filter().watch().await?;
    let decrement_filter = contract.Decrement_filter().watch().await?;

    // Build a call to increment the counter.
    let increment_call = contract.increment();

    // Build a call to decrement the counter.
    let decrement_call = contract.decrement();

    // Send the transaction call twice for each event.
    for _ in 0..2 {
        let _ = increment_call.send().await?;
        let _ = decrement_call.send().await?;
    }

    // Poll for logs.
    increment_filter
        .into_stream()
        .take(2)
        .for_each(|log| async {
            match log {
                Ok((_event, log)) =&gt; {
                    println!("Received Increment: {log:?}");
                }
                Err(e) =&gt; {
                    println!("Error: {e:?}");
                }
            }
        })
        .await;

    decrement_filter
        .into_stream()
        .take(2)
        .for_each(|log| async {
            match log {
                Ok((_event, log)) =&gt; {
                    println!("Received Decrement: {log:?}");
                }
                Err(e) =&gt; {
                    println!("Error: {e:?}");
                }
            }
        })
        .await;

    Ok(())
}</code></pre>
<p>åœ¨ Github ä¸Šæ‰¾åˆ°æºä»£ç  <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/subscriptions/examples/poll_logs.rs" title="" target="_blank">ç‚¹å‡»è¿™é‡Œ</a>ã€‚</p>
<div style="break-before: page; page-break-before: always;"></div><!-- DO NOT EDIT THIS FILE. IT IS GENERATED BY RUNNING `./scripts/update.sh` -->
<!-- ANY CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN -->
<!-- EDIT OR CREATE THIS TEMPLATE INSTEAD: ./src/templates/subscriptions/subscribe_blocks.md -->
<!-- LATEST UPDATE: https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="ç¤ºä¾‹subscribe_blocks"><a class="header" href="#ç¤ºä¾‹subscribe_blocks">ç¤ºä¾‹ï¼š<code>subscribe_blocks</code></a></h2>
<h3 id="ç¤ºä¾‹-58"><a class="header" href="#ç¤ºä¾‹-58">ç¤ºä¾‹</a></h3>
<p>è¿è¡Œæ­¤ç¤ºä¾‹ï¼š</p>
<ul>
<li>å…‹éš† <a href="https://github.com/alloy-rs/examples" title="" target="_blank">examples</a> ä»“åº“ï¼š<code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>è¿è¡Œï¼š<code>cargo run --example subscribe_blocks</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example of subscribing to blocks and watching block headers by polling.

use alloy::{
    node_bindings::Anvil,
    providers::{Provider, ProviderBuilder, WsConnect},
};
use eyre::Result;
use futures_util::{stream, StreamExt};

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    // Spin up a local Anvil node.
    // Ensure `anvil` is available in $PATH.
    let anvil = Anvil::new().block_time(1).try_spawn()?;

    // Create a provider.
    let ws = WsConnect::new(anvil.ws_endpoint());
    let provider = ProviderBuilder::new().on_ws(ws).await?;

    // Subscribe to blocks.
    let subscription = provider.subscribe_blocks().await?;
    let mut stream = subscription.into_stream().take(2);

    while let Some(block) = stream.next().await {
        println!(
            "Received block number: {}",
            block.header.number.expect("Failed to get block number")
        );
    }

    // Poll for block headers.
    let poller = provider.watch_blocks().await?;
    let mut stream = poller.into_stream().flat_map(stream::iter).take(2);

    while let Some(block_hash) = stream.next().await {
        println!("Polled for block header: {block_hash:?}");
    }

    Ok(())
}</code></pre>
<p>ä½ å¯ä»¥åœ¨ Github ä¸Šæ‰¾åˆ°æºç  <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/subscriptions/examples/subscribe_blocks.rs" title="" target="_blank">here</a>ã€‚</p>
<div style="break-before: page; page-break-before: always;"></div><!-- DO NOT EDIT THIS FILE. IT IS GENERATED BY RUNNING `./scripts/update.sh` -->
<!-- ANY CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN -->
<!-- EDIT OR CREATE THIS TEMPLATE INSTEAD: ./src/templates/subscriptions/subscribe_logs.md -->
<!-- LATEST UPDATE: https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="ç¤ºä¾‹-subscribe_logs"><a class="header" href="#ç¤ºä¾‹-subscribe_logs">ç¤ºä¾‹: <code>subscribe_logs</code></a></h2>
<h3 id="ç¤ºä¾‹-59"><a class="header" href="#ç¤ºä¾‹-59">ç¤ºä¾‹</a></h3>
<p>è¿è¡Œæ­¤ç¤ºä¾‹ï¼š</p>
<ul>
<li>å…‹éš† <a href="https://github.com/alloy-rs/examples" title="" target="_blank">examples</a> ä»“åº“: <code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>è¿è¡Œ: <code>cargo run --example subscribe_logs</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example of subscribing and listening for specific contract events by `WebSocket` subscription.

use alloy::{
    primitives::address,
    providers::{Provider, ProviderBuilder, WsConnect},
    rpc::types::{BlockNumberOrTag, Filter},
};
use eyre::Result;
use futures_util::stream::StreamExt;

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    // Set up the WS transport which is consumed by the RPC client.
    let rpc_url = "wss://eth-mainnet.g.alchemy.com/v2/your-api-key";

    // Create the provider.
    let ws = WsConnect::new(rpc_url);
    let provider = ProviderBuilder::new().on_ws(ws).await?;

    // Create a filter to watch for UNI token transfers.
    let uniswap_token_address = address!("1f9840a85d5aF5bf1D1762F925BDADdC4201F984");
    let filter = Filter::new()
        .address(uniswap_token_address)
        // By specifying an `event` or `event_signature` we listen for a specific event of the
        // contract. In this case the `Transfer(address,address,uint256)` event.
        .event("Transfer(address,address,uint256)")
        .from_block(BlockNumberOrTag::Latest);

    // Subscribe to logs.
    let sub = provider.subscribe_logs(&amp;filter).await?;
    let mut stream = sub.into_stream();

    while let Some(log) = stream.next().await {
        println!("Uniswap token logs: {log:?}");
    }

    Ok(())
}</code></pre>
<p>åœ¨ Github ä¸ŠæŸ¥çœ‹æºä»£ç  <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/subscriptions/examples/subscribe_logs.rs" title="" target="_blank">here</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><!-- DO NOT EDIT THIS FILE. IT IS GENERATED BY RUNNING `./scripts/update.sh` -->
<!-- ANY CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN -->
<!-- EDIT OR CREATE THIS TEMPLATE INSTEAD: ./src/templates/subscriptions/subscribe_all_logs.md -->
<!-- LATEST UPDATE: https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="ç¤ºä¾‹-subscribe_all_logs"><a class="header" href="#ç¤ºä¾‹-subscribe_all_logs">ç¤ºä¾‹: <code>subscribe_all_logs</code></a></h2>
<h3 id="ç¤ºä¾‹-60"><a class="header" href="#ç¤ºä¾‹-60">ç¤ºä¾‹</a></h3>
<p>è¦è¿è¡Œè¿™ä¸ªç¤ºä¾‹:</p>
<ul>
<li>å…‹éš† <a href="https://github.com/alloy-rs/examples" title="" target="_blank">examples</a> ä»“åº“: <code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>è¿è¡Œ: <code>cargo run --example subscribe_all_logs</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example of subscribing and listening for all contract events by `WebSocket` subscription.

use alloy::{
    primitives::address,
    providers::{Provider, ProviderBuilder, WsConnect},
    rpc::types::{BlockNumberOrTag, Filter},
    sol,
    sol_types::SolEvent,
};
use eyre::Result;
use futures_util::stream::StreamExt;

// Codegen from ABI file to interact with the contract.
sol!(
    #[allow(missing_docs)]
    #[sol(rpc)]
    IWETH9,
    "examples/abi/IWETH9.json"
);

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    // Set up the WS transport which is consumed by the RPC client.
    let rpc_url = "wss://eth-mainnet.g.alchemy.com/v2/your-api-key";

    // Create the provider.
    let ws = WsConnect::new(rpc_url);
    let provider = ProviderBuilder::new().on_ws(ws).await?;

    // Create a filter to watch for all WETH9 events.
    let weth9_token_address = address!("C02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2");
    let filter = Filter::new()
        // By NOT specifying an `event` or `event_signature` we listen to ALL events of the
        // contract.
        .address(weth9_token_address)
        .from_block(BlockNumberOrTag::Latest);

    // Subscribe to logs.
    let sub = provider.subscribe_logs(&amp;filter).await?;
    let mut stream = sub.into_stream();

    while let Some(log) = stream.next().await {
        // Match on topic 0, the hash of the signature of the event.
        match log.topic0() {
            // Match the `Approval(address,address,uint256)` event.
            Some(&amp;IWETH9::Approval::SIGNATURE_HASH) =&gt; {
                let IWETH9::Approval { src, guy, wad } = log.log_decode()?.inner.data;
                println!("Approval from {src} to {guy} of value {wad}");
            }
            // Match the `Transfer(address,address,uint256)` event.
            Some(&amp;IWETH9::Transfer::SIGNATURE_HASH) =&gt; {
                let IWETH9::Transfer { src, dst, wad } = log.log_decode()?.inner.data;
                println!("Transfer from {src} to {dst} of value {wad}");
            }
            // WETH9's `Deposit(address,uint256)` and `Withdrawal(address,uint256)` events are not
            // handled here.
            _ =&gt; (),
        }
    }

    Ok(())
}</code></pre>
<p>åœ¨ Github ä¸ŠæŸ¥çœ‹æºä»£ç  <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/subscriptions/examples/subscribe_all_logs.rs" title="" target="_blank">è¿™é‡Œ</a>ã€‚</p>
<div style="break-before: page; page-break-before: always;"></div><!-- DO NOT EDIT THIS FILE. IT IS GENERATED BY RUNNING `./scripts/update.sh` -->
<!-- ANY CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN -->
<!-- EDIT OR CREATE THIS TEMPLATE INSTEAD: ./src/templates/subscriptions/subscribe_pending_transactions.md -->
<!-- LATEST UPDATE: https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="ç¤ºä¾‹-subscribe_pending_transactions"><a class="header" href="#ç¤ºä¾‹-subscribe_pending_transactions">ç¤ºä¾‹: <code>subscribe_pending_transactions</code></a></h2>
<h3 id="ç¤ºä¾‹-61"><a class="header" href="#ç¤ºä¾‹-61">ç¤ºä¾‹</a></h3>
<p>è¿è¡Œè¯¥ç¤ºä¾‹ï¼š</p>
<ul>
<li>å…‹éš† <a href="https://github.com/alloy-rs/examples" title="" target="_blank">examples</a> ä»“åº“: <code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>è¿è¡Œ: <code>cargo run --example subscribe_pending_transactions</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example of subscribing and listening for pending transactions in the public mempool by
//! `WebSocket` subscription.

use alloy::providers::{Provider, ProviderBuilder, WsConnect};
use eyre::Result;
use futures_util::StreamExt;

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    // Set up the WS transport which is consumed by the RPC client.
    let rpc_url = "wss://eth-mainnet.g.alchemy.com/v2/your-api-key";

    // Create the provider.
    let ws = WsConnect::new(rpc_url);
    let provider = ProviderBuilder::new().on_ws(ws).await?;

    // Subscribe to pending transactions.
    // Alteratively use `subscribe_full_pending_transactions` to get the full transaction details
    // directly if supported by the RPC provider.
    let sub = provider.subscribe_pending_transactions().await?;

    // Wait and take the next 3 transactions.
    let mut stream = sub.into_stream().take(3);

    println!("Awaiting pending transactions...");

    // Take the stream and print the pending transaction.
    let handle = tokio::spawn(async move {
        while let Some(tx_hash) = stream.next().await {
            // Get the transaction details.
            if let Ok(tx) = provider.get_transaction_by_hash(tx_hash).await {
                println!("Transaction details: {tx:#?}");
            }
        }
    });

    handle.await?;

    Ok(())
}</code></pre>
<p>åœ¨ Github ä¸Šæ‰¾åˆ°æºä»£ç  <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/subscriptions/examples/subscribe_pending_transactions.rs" title="" target="_blank">è¿™é‡Œ</a>ã€‚</p>
<div style="break-before: page; page-break-before: always;"></div><!-- DO NOT EDIT THIS FILE. IT IS GENERATED BY RUNNING `./scripts/update.sh` -->
<!-- ANY CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN -->
<!-- EDIT OR CREATE THIS TEMPLATE INSTEAD: ./src/templates/subscriptions/event_multiplexer.md -->
<!-- LATEST UPDATE: https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="ç¤ºä¾‹-event_multiplexer"><a class="header" href="#ç¤ºä¾‹-event_multiplexer">ç¤ºä¾‹: <code>event_multiplexer</code></a></h2>
<h3 id="ç¤ºä¾‹-62"><a class="header" href="#ç¤ºä¾‹-62">ç¤ºä¾‹</a></h3>
<p>è¿è¡Œæœ¬ç¤ºä¾‹ï¼š</p>
<ul>
<li>å…‹éš† <a href="https://github.com/alloy-rs/examples" title="" target="_blank">examples</a> ä»“åº“: <code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>è¿è¡Œ: <code>cargo run --example event_multiplexer</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example of multiplexing the watching of event logs.

use alloy::{
    node_bindings::Anvil,
    primitives::I256,
    providers::{ProviderBuilder, WsConnect},
    sol,
    sol_types::SolEvent,
};
use eyre::Result;
use futures_util::StreamExt;
use std::str::FromStr;

// Codegen from embedded Solidity code and precompiled bytecode.
// solc v0.8.26; solc EventMultiplexer.sol --via-ir --optimize --bin
sol!(
    #[allow(missing_docs)]
    #[sol(rpc, bytecode = "60808060405234601557610207908161001b8239f35b600080fdfe6080604052600436101561001257600080fd5b60003560e01c80634350913814610156578063a5f3c23b14610108578063adefc37b146100ba5763bbe93d911461004857600080fd5b346100b557610056366101bb565b818102919060008212600160ff1b82141661009f57818305149015171561009f57337fd7a123d4c8e44db3186e04b9c96c102287276929c930f2e8abcaa555ef5dcacc600080a3005b634e487b7160e01b600052601160045260246000fd5b600080fd5b346100b5576100c8366101bb565b906000828203921281831281169183139015161761009f57337f32e913bf2ad35da1e845597618bb9f3f80642a68dd39f30a093a7838aa61fb27600080a3005b346100b557610116366101bb565b906000828201928312911290801582169115161761009f57337f6da406ea462447ed7804b4a4dc69c67b53d3d45a50381ae3e9cf878c9d7c23df600080a3005b346100b557610164366101bb565b9081156101a557600160ff1b811460001983141661009f5705337f1c1e8bbe327890ea8d3f5b22370a56c3fcef7ff82f306161f64647fe5d285881600080a3005b634e487b7160e01b600052601260045260246000fd5b60409060031901126100b557600435906024359056fea2646970667358221220d876fbacf1e90fc174532f3525420c446351b467f788f9d7a726a7d55045909664736f6c634300081a0033")]
    contract EventMultiplexer {
        event Add(address indexed sender, int256 indexed value);
        event Sub(address indexed sender, int256 indexed value);
        event Mul(address indexed sender, int256 indexed value);
        event Div(address indexed sender, int256 indexed value);

        function add(int256 a, int256 b) public {
            emit Add(msg.sender, a + b);
        }

        function sub(int256 a, int256 b) public {
            emit Sub(msg.sender, a - b);
        }

        function mul(int256 a, int256 b) public {
            emit Mul(msg.sender, a * b);
        }

        function div(int256 a, int256 b) public {
            emit Div(msg.sender, a / b);
        }
    }
);

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    // Spin up a local Anvil node.
    // Ensure `anvil` is available in $PATH.
    let anvil = Anvil::new().block_time(1).try_spawn()?;

    // Create a provider.
    let ws = WsConnect::new(anvil.ws_endpoint());
    let provider = ProviderBuilder::new().on_ws(ws).await?;

    // Deploy the `EventExample` contract.
    let contract = EventMultiplexer::deploy(provider).await?;

    println!("Deployed contract at: {}", contract.address());

    // Create filters for each event.
    let add_filter = contract.Add_filter().watch().await?;
    let sub_filter = contract.Sub_filter().watch().await?;
    let mul_filter = contract.Mul_filter().watch().await?;
    let div_filter = contract.Div_filter().watch().await?;

    let a = I256::from_str("1")?;
    let b = I256::from_str("1")?;

    // Build the transaction calls.
    let add_call = contract.add(a, b);
    let sub_call = contract.sub(a, b);
    let mul_call = contract.mul(a, b);
    let div_call = contract.div(a, b);

    // Send the transaction calls.
    let _ = add_call.send().await?;
    let _ = sub_call.send().await?;
    let _ = mul_call.send().await?;
    let _ = div_call.send().await?;

    // Convert the filters into streams.
    let mut add_stream = add_filter.into_stream();
    let mut sub_stream = sub_filter.into_stream();
    let mut mul_stream = mul_filter.into_stream();
    let mut div_stream = div_filter.into_stream();

    let add_log = &amp;EventMultiplexer::Add::SIGNATURE_HASH;
    let sub_log = &amp;EventMultiplexer::Sub::SIGNATURE_HASH;
    let mul_log = &amp;EventMultiplexer::Mul::SIGNATURE_HASH;
    let div_log = &amp;EventMultiplexer::Div::SIGNATURE_HASH;

    // Use tokio::select! to multiplex the streams and capture the log
    // tokio::select! will return the first event that arrives from any of the streams
    // The for loop helps capture all the logs.
    for _ in 0..4 {
        let log = tokio::select! {
            Some(log) = add_stream.next() =&gt; {
                log?.1
            }
            Some(log) = sub_stream.next() =&gt; {
                log?.1
            }
            Some(log) = mul_stream.next() =&gt; {
                log?.1
            }
            Some(log) = div_stream.next() =&gt; {
                log?.1
            }
        };

        let topic = &amp;log.topics()[0];

        if topic == add_log {
            println!("Received Add: {log:?}");
        } else if topic == sub_log {
            println!("Received Sub: {log:?}");
        } else if topic == mul_log {
            println!("Received Mul: {log:?}");
        } else if topic == div_log {
            println!("Received Div: {log:?}");
        }
    }

    Ok(())
}</code></pre>
<p>å¯ä»¥åœ¨ Github ä¸Šæ‰¾åˆ°æºä»£ç  <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/subscriptions/examples/event_multiplexer.rs" title="" target="_blank">here</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="äº¤æ˜“-1"><a class="header" href="#äº¤æ˜“-1">äº¤æ˜“</a></h2>
<ul>
<li><a href="examples/transactions/decode_input.html">è§£ç è¾“å…¥</a></li>
<li><a href="examples/transactions/encode_decode_eip1559.html">ç¼–ç å’Œè§£ç  EIP-1559 äº¤æ˜“</a></li>
<li><a href="examples/transactions/gas_price_usd.html">è·å–ä»¥ç¾å…ƒè®¡ä»·çš„ gas ä»·æ ¼</a></li>
<li><a href="examples/transactions/trace_call.html">è°ƒç”¨è·Ÿè¸ª</a></li>
<li><a href="examples/transactions/trace_transaction.html">äº¤æ˜“è·Ÿè¸ª</a></li>
<li><a href="examples/transactions/transfer_erc20.html">è½¬è´¦ ERC20 ä»£å¸</a></li>
<li><a href="examples/transactions/transfer_eth.html">è½¬è´¦ ETH</a></li>
<li><a href="examples/transactions/send_raw_transaction.html">ç­¾ç½²å¹¶å‘é€åŸå§‹äº¤æ˜“</a></li>
<li><a href="examples/transactions/with_access_list.html">å‘é€å¸¦è®¿é—®åˆ—è¡¨çš„äº¤æ˜“</a></li>
<li><a href="examples/transactions/send_eip1559_transaction.html">å‘é€ EIP-1559 äº¤æ˜“</a></li>
<li><a href="examples/transactions/send_legacy_transaction.html">å‘é€ä¼ ç»Ÿäº¤æ˜“</a></li>
<li><a href="examples/transactions/send_eip4844_transaction.html">å‘é€ EIP-4844 äº¤æ˜“</a></li>
<li><a href="examples/transactions/send_private_transaction.html">ä½¿ç”¨ Flashbots Protect å‘é€ç§å¯†äº¤æ˜“</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><!-- DO NOT EDIT THIS FILE. IT IS GENERATED BY RUNNING `./scripts/update.sh` -->
<!-- ANY CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN -->
<!-- EDIT OR CREATE THIS TEMPLATE INSTEAD: ./src/templates/transactions/decode_input.md -->
<!-- LATEST UPDATE: https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="ç¤ºä¾‹decode_input"><a class="header" href="#ç¤ºä¾‹decode_input">ç¤ºä¾‹ï¼š<code>decode_input</code></a></h2>
<h3 id="ç¤ºä¾‹-63"><a class="header" href="#ç¤ºä¾‹-63">ç¤ºä¾‹</a></h3>
<p>è¦è¿è¡Œæ­¤ç¤ºä¾‹ï¼š</p>
<ul>
<li>å…‹éš† <a href="https://github.com/alloy-rs/examples" title="" target="_blank">examples</a> ä»“åº“: <code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>è¿è¡Œ: <code>cargo run --example decode_input</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example of how to decode the input of a transaction.

use alloy::{primitives::hex, sol, sol_types::SolCall};
use eyre::Result;

// Codegen from excerpt of Uniswap V2 Router interface.
// See: https://docs.uniswap.org/contracts/v2/reference/smart-contracts/router-02
sol!(
    #[allow(missing_docs)]
    function swapExactTokensForTokens(
        uint256 amountIn,
        uint256 amountOutMin,
        address[] calldata path,
        address to,
        uint256 deadline
      ) external returns (uint256[] memory amounts);
);

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    println!("Decoding https://etherscan.io/tx/0xd1b449d8b1552156957309bffb988924569de34fbf21b51e7af31070cc80fe9a");

    let input = "0x38ed173900000000000000000000000000000000000000000001a717cc0a3e4f84c00000000000000000000000000000000000000000000000000000000000000283568400000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000201f129111c60401630932d9f9811bd5b5fff34e000000000000000000000000000000000000000000000000000000006227723d000000000000000000000000000000000000000000000000000000000000000200000000000000000000000095ad61b0a150d79219dcf64e1e6cc01f0b64c4ce000000000000000000000000dac17f958d2ee523a2206206994597c13d831ec7";
    let input = hex::decode(input)?;

    // Decode the input using the generated `swapExactTokensForTokens` bindings.
    let decoded = swapExactTokensForTokensCall::abi_decode(&amp;input, false);

    match decoded {
        Ok(decoded) =&gt; {
            let path = decoded.path;

            println!(
                "Swap {} of token {} to {} of token {}",
                decoded.amountIn,
                path.first().expect("Path is empty"),
                decoded.amountOutMin,
                path.last().expect("Path is empty")
            );
        }
        Err(e) =&gt; {
            println!("Error decoding input: {e:?}");
        }
    }

    Ok(())
}</code></pre>
<p>å¯ä»¥åœ¨ Github ä¸Šæ‰¾åˆ°æºä»£ç  <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/transactions/examples/decode_input.rs" title="" target="_blank">here</a>ã€‚</p>
<div style="break-before: page; page-break-before: always;"></div><!-- è¯·å‹¿ç¼–è¾‘æ­¤æ–‡ä»¶ã€‚å®ƒæ˜¯é€šè¿‡è¿è¡Œ `./scripts/update.sh` ç”Ÿæˆçš„ -->
<!-- å¯¹è¿™ä¸ªæ–‡ä»¶çš„ä»»ä½•æ›´æ”¹éƒ½å°†è¢«è¦†ç›– -->
<!-- è¯·ç¼–è¾‘æˆ–åˆ›å»ºæ­¤æ¨¡æ¿ï¼š./src/templates/transactions/encode_decode_eip1559.md -->
<!-- æœ€æ–°æ›´æ–°ï¼š https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="ç¤ºä¾‹-encode_decode_eip1559"><a class="header" href="#ç¤ºä¾‹-encode_decode_eip1559">ç¤ºä¾‹: <code>encode_decode_eip1559</code></a></h2>
<h3 id="ç¤ºä¾‹-64"><a class="header" href="#ç¤ºä¾‹-64">ç¤ºä¾‹</a></h3>
<p>è¦è¿è¡Œæ­¤ç¤ºä¾‹ï¼š</p>
<ul>
<li>å…‹éš† <a href="https://github.com/alloy-rs/examples" title="" target="_blank">examples</a> ä»“åº“ï¼š<code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>è¿è¡Œï¼š<code>cargo run --example encode_decode_eip1559</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example showing how to encode and decode an [EIP-1559](https://eips.ethereum.org/EIPS/eip-1559) transaction.

use alloy::{
    consensus::{SignableTransaction, TxEip1559},
    eips::eip2930::AccessList,
    primitives::{address, b256, hex, Signature, TxKind, U256},
};
use eyre::Result;

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    // EIP1559 transaction: &lt;https://etherscan.io/tx/0x0ec0b6a2df4d87424e5f6ad2a654e27aaeb7dac20ae9e8385cc09087ad532ee0&gt;
    let tx_hash = b256!("0ec0b6a2df4d87424e5f6ad2a654e27aaeb7dac20ae9e8385cc09087ad532ee0");

    // Signer of the transaction.
    let signer = address!("DD6B8b3dC6B7AD97db52F08a275FF4483e024CEa");

    // Construct the EIP-1559 transaction.
    let tx = TxEip1559 {
        chain_id: 1,
        nonce: 0x42,
        gas_limit: 44386,
        to: TxKind::Call( address!("6069a6c32cf691f5982febae4faf8a6f3ab2f0f6")),
        value: U256::from(0_u64),
        input: hex!("a22cb4650000000000000000000000005eee75727d804a2b13038928d36f8b188945a57a0000000000000000000000000000000000000000000000000000000000000000").into(),
        max_fee_per_gas: 0x4a817c800,
        max_priority_fee_per_gas: 0x3b9aca00,
        access_list: AccessList::default(),
    };

    // Construct the signature of the transaction.
    let signature = Signature::from_scalars_and_parity(
        b256!("840cfc572845f5786e702984c2a582528cad4b49b2a10b9db1be7fca90058565"),
        b256!("25e7109ceb98168d95b09b18bbf6b685130e0562f233877d492b94eee0c5b6d1"),
        false,
    )?;

    // Convert the transaction into a signed transaction.
    let signed_tx = tx.into_signed(signature);
    assert_eq!(*signed_tx.hash(), tx_hash);

    // Recover the signer from the signed transaction to ensure it matches the expected signer.
    let recovered_signer = signed_tx.recover_signer()?;
    assert_eq!(recovered_signer, signer);

    Ok(())
}</code></pre>
<p>åœ¨ Github ä¸Šå¯ä»¥æ‰¾åˆ°æºç  <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/transactions/examples/encode_decode_eip1559.rs" title="" target="_blank">è¿™é‡Œ</a>ã€‚</p>
<div style="break-before: page; page-break-before: always;"></div><!-- DO NOT EDIT THIS FILE. IT IS GENERATED BY RUNNING `./scripts/update.sh` -->
<!-- ANY CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN -->
<!-- EDIT OR CREATE THIS TEMPLATE INSTEAD: ./src/templates/transactions/gas_price_usd.md -->
<!-- LATEST UPDATE: https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="ç¤ºä¾‹-gas_price_usd"><a class="header" href="#ç¤ºä¾‹-gas_price_usd">ç¤ºä¾‹: <code>gas_price_usd</code></a></h2>
<h3 id="ç¤ºä¾‹-65"><a class="header" href="#ç¤ºä¾‹-65">ç¤ºä¾‹</a></h3>
<p>è¿è¡Œè¿™ä¸ªç¤ºä¾‹:</p>
<ul>
<li>å…‹éš† <a href="https://github.com/alloy-rs/examples" title="" target="_blank">examples</a> ä»“åº“: <code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>è¿è¡Œ: <code>cargo run --example gas_price_usd</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example of how to get the gas price in USD using the Chainlink ETH/USD feed.

use alloy::{
    network::TransactionBuilder,
    node_bindings::Anvil,
    primitives::{address, utils::format_units, Address, Bytes, U256},
    providers::{Provider, ProviderBuilder},
    rpc::types::TransactionRequest,
    sol,
    sol_types::SolCall,
};
use eyre::Result;
use std::str::FromStr;

const ETH_USD_FEED: Address = address!("5f4eC3Df9cbd43714FE2740f5E3616155c5b8419");
const ETH_USD_FEED_DECIMALS: u8 = 8;
const ETH_DECIMALS: u32 = 18;

// Codegen from excerpt of Chainlink Aggregator interface.
// See: https://etherscan.io/address/0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419#code
sol!(
    #[allow(missing_docs)]
    function latestAnswer() external view returns (int256);
);

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    // Spin up a forked Anvil node.
    // Ensure `anvil` is available in $PATH.
    let anvil = Anvil::new().fork("https://eth.merkle.io").try_spawn()?;

    // Create a provider.
    let rpc_url = anvil.endpoint().parse()?;
    let provider = ProviderBuilder::new().on_http(rpc_url);

    // Create a call to get the latest answer from the Chainlink ETH/USD feed.
    let call = latestAnswerCall {}.abi_encode();
    let input = Bytes::from(call);

    // Call the Chainlink ETH/USD feed contract.
    let tx = TransactionRequest::default().with_to(ETH_USD_FEED).with_input(input);

    let response = provider.call(&amp;tx).await?;
    let result = U256::from_str(&amp;response.to_string())?;

    // Get the gas price of the network.
    let wei_per_gas = provider.get_gas_price().await?;

    // Convert the gas price to Gwei and USD.
    let gwei = format_units(wei_per_gas, "gwei")?.parse::&lt;f64&gt;()?;
    let usd = get_usd_value(wei_per_gas, result)?;

    println!("Gas price in Gwei: {gwei}");
    println!("Gas price in USD: {usd}");

    Ok(())
}

fn get_usd_value(amount: u128, price_usd: U256) -&gt; Result&lt;f64&gt; {
    let base = U256::from(10).pow(U256::from(ETH_DECIMALS));
    let value = U256::from(amount) * price_usd / base;
    let formatted = format_units(value, ETH_USD_FEED_DECIMALS)?.parse::&lt;f64&gt;()?;

    Ok(formatted)
}</code></pre>
<p>åœ¨ Github ä¸Šæ‰¾åˆ°æºç  <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/transactions/examples/gas_price_usd.rs" title="" target="_blank">here</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><!-- ä¸è¦ç¼–è¾‘æ­¤æ–‡ä»¶ã€‚å®ƒæ˜¯é€šè¿‡è¿è¡Œ `./scripts/update.sh` ç”Ÿæˆçš„ -->
<!-- å¯¹æ­¤æ–‡ä»¶æ‰€åšçš„ä»»ä½•æ›´æ”¹å°†è¢«è¦†ç›– -->
<!-- è¯·ç¼–è¾‘æˆ–åˆ›å»ºæ­¤æ¨¡æ¿ï¼š ./src/templates/transactions/trace_call.md -->
<!-- æœ€æ–°æ›´æ–°ï¼šhttps://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="ç¤ºä¾‹trace_call"><a class="header" href="#ç¤ºä¾‹trace_call">ç¤ºä¾‹ï¼š<code>trace_call</code></a></h2>
<h3 id="ç¤ºä¾‹-66"><a class="header" href="#ç¤ºä¾‹-66">ç¤ºä¾‹</a></h3>
<p>è¦è¿è¡Œæ­¤ç¤ºä¾‹ï¼š</p>
<ul>
<li>å…‹éš† <a href="https://github.com/alloy-rs/examples" title="" target="_blank">examples</a> ä»“åº“ï¼š<code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>è¿è¡Œï¼š<code>cargo run --example trace_call</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example of how to trace a transaction using `trace_call`.

use alloy::{
    network::TransactionBuilder,
    primitives::{address, U256},
    providers::{ext::TraceApi, ProviderBuilder},
    rpc::types::{trace::parity::TraceType, TransactionRequest},
};
use eyre::Result;

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    // Create a provider.
    let rpc_url = "https://eth.merkle.io".parse()?;
    let provider = ProviderBuilder::new().on_http(rpc_url);

    // Build a transaction to send 100 wei from Alice to Vitalik.
    let alice = address!("f39Fd6e51aad88F6F4ce6aB8827279cffFb92266");
    let vitalik = address!("d8dA6BF26964aF9D7eEd9e03E53415D37aA96045");
    let tx =
        TransactionRequest::default().with_from(alice).with_to(vitalik).with_value(U256::from(100));

    // Trace the transaction on top of the latest block.
    let trace_type = [TraceType::Trace];
    let result = provider.trace_call(&amp;tx, &amp;trace_type).await?;

    println!("{:?}", result.trace);

    Ok(())
}</code></pre>
<p>åœ¨ Github ä¸Šå¯ä»¥æ‰¾åˆ°æºä»£ç  <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/transactions/examples/trace_call.rs" title="" target="_blank">è¿™é‡Œ</a>ã€‚</p>
<div style="break-before: page; page-break-before: always;"></div><!-- DO NOT EDIT THIS FILE. IT IS GENERATED BY RUNNING `./scripts/update.sh` -->
<!-- ANY CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN -->
<!-- EDIT OR CREATE THIS TEMPLATE INSTEAD: ./src/templates/transactions/trace_transaction.md -->
<!-- LATEST UPDATE: https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="ç¤ºä¾‹-trace_transaction"><a class="header" href="#ç¤ºä¾‹-trace_transaction">ç¤ºä¾‹: <code>trace_transaction</code></a></h2>
<h3 id="ç¤ºä¾‹-67"><a class="header" href="#ç¤ºä¾‹-67">ç¤ºä¾‹</a></h3>
<p>è¦è¿è¡Œæ­¤ç¤ºä¾‹ï¼š</p>
<ul>
<li>å…‹éš† <a href="https://github.com/alloy-rs/examples" title="" target="_blank">examples</a> ä»“åº“: <code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>è¿è¡Œ: <code>cargo run --example trace_transaction</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example of how to trace a transaction using `trace_transaction`.

use alloy::{
    node_bindings::Anvil,
    primitives::b256,
    providers::{ext::DebugApi, ProviderBuilder},
    rpc::types::trace::geth::{
        GethDebugBuiltInTracerType, GethDebugTracerType, GethDebugTracingOptions,
        GethDefaultTracingOptions,
    },
};
use eyre::Result;

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    // Spin up a forked Anvil node.
    // Ensure `anvil` is available in $PATH.
    let anvil = Anvil::new().fork("https://eth.merkle.io").try_spawn()?;

    // Create a provider.
    let rpc_url = anvil.endpoint().parse()?;
    let provider = ProviderBuilder::new().on_http(rpc_url);

    // Hash of the tx we want to trace.
    let hash = b256!("97a02abf405d36939e5b232a5d4ef5206980c5a6661845436058f30600c52df7");

    // Trace with the default tracer.
    let default_options = GethDebugTracingOptions::default();
    let result = provider.debug_trace_transaction(hash, default_options).await?;

    println!("DEFAULT_TRACE: {result:?}");

    // Trace with built-in call tracer.
    let call_options = GethDebugTracingOptions {
        config: GethDefaultTracingOptions {
            disable_storage: Some(true),
            enable_memory: Some(false),
            ..Default::default()
        },
        tracer: Some(GethDebugTracerType::BuiltInTracer(GethDebugBuiltInTracerType::CallTracer)),
        ..Default::default()
    };
    let result = provider.debug_trace_transaction(hash, call_options).await?;

    println!("CALL_TRACE: {result:?}");

    // Trace using a custom JavaScript tracer.
    let js_options = GethDebugTracingOptions {
        tracer: Some(GethDebugTracerType::JsTracer("{data: [], fault: function(log) {}, step: function(log) { if(log.op.toString() == \"DELEGATECALL\") this.data.push(log.stack.peek(0)); }, result: function() { return this.data; }}".into())),
        ..Default::default()
    };
    let result = provider.debug_trace_transaction(hash, js_options).await?;

    println!("JS_TRACER: {result:?}");

    Ok(())
}</code></pre>
<p>åœ¨ Github ä¸Šå¯ä»¥æ‰¾åˆ°æºç  <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/transactions/examples/trace_transaction.rs" title="" target="_blank">è¿™é‡Œ</a>ã€‚</p>
<div style="break-before: page; page-break-before: always;"></div><!-- DO NOT EDIT THIS FILE. IT IS GENERATED BY RUNNING `./scripts/update.sh` -->
<!-- ANY CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN -->
<!-- EDIT OR CREATE THIS TEMPLATE INSTEAD: ./src/templates/transactions/transfer_erc20.md -->
<!-- LATEST UPDATE: https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="ç¤ºä¾‹-transfer_erc20"><a class="header" href="#ç¤ºä¾‹-transfer_erc20">ç¤ºä¾‹: <code>transfer_erc20</code></a></h2>
<h3 id="ç¤ºä¾‹-68"><a class="header" href="#ç¤ºä¾‹-68">ç¤ºä¾‹</a></h3>
<p>è¦è¿è¡Œæ­¤ç¤ºä¾‹:</p>
<ul>
<li>å…‹éš† <a href="https://github.com/alloy-rs/examples" title="" target="_blank">examples</a> ä»“åº“ï¼š<code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>è¿è¡Œï¼š<code>cargo run --example transfer_erc20</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example of how to transfer ERC20 tokens from one account to another.

use alloy::{node_bindings::Anvil, primitives::U256, providers::ProviderBuilder, sol};
use eyre::Result;

// Codegen from artifact.
sol!(
    #[allow(missing_docs)]
    #[sol(rpc)]
    ERC20Example,
    "examples/artifacts/ERC20Example.json"
);

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    // Spin up a forked Anvil node.
    // Ensure `anvil` is available in $PATH.
    let anvil = Anvil::new().fork("https://eth.merkle.io").try_spawn()?;

    // Create a provider.
    let rpc_url = anvil.endpoint().parse()?;
    let provider = ProviderBuilder::new().on_http(rpc_url);

    // Create two users, Alice and Bob.
    let alice = anvil.addresses()[0];
    let bob = anvil.addresses()[1];

    // Deploy the `ERC20Example` contract.
    let contract = ERC20Example::deploy(provider).await?;

    // Register the balances of Alice and Bob before the transfer.
    let alice_before_balance = contract.balanceOf(alice).call().await?._0;
    let bob_before_balance = contract.balanceOf(bob).call().await?._0;

    // Transfer and wait for inclusion.
    let amount = U256::from(100);
    let tx_hash = contract.transfer(bob, amount).send().await?.watch().await?;

    println!("Sent transaction: {tx_hash}");

    // Register the balances of Alice and Bob after the transfer.
    let alice_after_balance = contract.balanceOf(alice).call().await?._0;
    let bob_after_balance = contract.balanceOf(bob).call().await?._0;

    // Check the balances of Alice and Bob after the transfer.
    assert_eq!(alice_before_balance - alice_after_balance, amount);
    assert_eq!(bob_after_balance - bob_before_balance, amount);

    Ok(())
}</code></pre>
<p>åœ¨ Github ä¸ŠæŸ¥çœ‹æºä»£ç  <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/transactions/examples/transfer_erc20.rs" title="" target="_blank">è¿™é‡Œ</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><!-- è¯·å‹¿ç¼–è¾‘æ­¤æ–‡ä»¶ã€‚å®ƒæ˜¯é€šè¿‡è¿è¡Œ `./scripts/update.sh` ç”Ÿæˆçš„ã€‚-->
<!-- å¯¹è¯¥æ–‡ä»¶æ‰€åšçš„ä»»ä½•æ›´æ”¹éƒ½å°†è¢«è¦†ç›–ã€‚-->
<!-- è¯·ç¼–è¾‘æˆ–åˆ›å»ºæ­¤æ¨¡æ¿ï¼š ./src/templates/transactions/transfer_eth.md -->
<!-- æœ€æ–°æ›´æ–°ï¼š https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="ç¤ºä¾‹transfer_eth"><a class="header" href="#ç¤ºä¾‹transfer_eth">ç¤ºä¾‹ï¼š<code>transfer_eth</code></a></h2>
<h3 id="ç¤ºä¾‹-69"><a class="header" href="#ç¤ºä¾‹-69">ç¤ºä¾‹</a></h3>
<p>è¦è¿è¡Œæ­¤ç¤ºä¾‹ï¼š</p>
<ul>
<li>å…‹éš† <a href="https://github.com/alloy-rs/examples" title="" target="_blank">examples</a> ä»“åº“: <code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>è¿è¡Œ: <code>cargo run --example transfer_eth</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example of how to transfer ETH from one account to another.

use alloy::{
    network::{EthereumWallet, TransactionBuilder},
    node_bindings::Anvil,
    primitives::U256,
    providers::{Provider, ProviderBuilder},
    rpc::types::TransactionRequest,
    signers::local::PrivateKeySigner,
};
use eyre::Result;

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    // Spin up a local Anvil node.
    // Ensure `anvil` is available in $PATH.
    let anvil = Anvil::new().try_spawn()?;

    // Get the RPC URL.
    let rpc_url = anvil.endpoint().parse()?;

    // Set up signer from the first default Anvil account (Alice).
    let signer: PrivateKeySigner = anvil.keys()[0].clone().into();
    let wallet = EthereumWallet::from(signer);

    // Create a provider with the wallet.
    let provider =
        ProviderBuilder::new().with_recommended_fillers().wallet(wallet).on_http(rpc_url);

    // Build a transaction to send 100 wei from Alice to Bob.
    // The `from` field is automatically filled to the first signer's address (Alice).
    let bob = anvil.addresses()[1];
    let tx = TransactionRequest::default().with_to(bob).with_value(U256::from(100));

    // Send the transaction and listen for the transaction to be included.
    let tx_hash = provider.send_transaction(tx).await?.watch().await?;

    println!("Sent transaction: {tx_hash}");

    Ok(())
}</code></pre>
<p>åœ¨ Github ä¸Šå¯ä»¥æ‰¾åˆ°æºç  <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/transactions/examples/transfer_eth.rs" title="" target="_blank">è¿™é‡Œ</a>ã€‚</p>
<div style="break-before: page; page-break-before: always;"></div><!-- DO NOT EDIT THIS FILE. IT IS GENERATED BY RUNNING `./scripts/update.sh` -->
<!-- ANY CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN -->
<!-- EDIT OR CREATE THIS TEMPLATE INSTEAD: ./src/templates/transactions/send_raw_transaction.md -->
<!-- LATEST UPDATE: https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="ç¤ºä¾‹-send_raw_transaction"><a class="header" href="#ç¤ºä¾‹-send_raw_transaction">ç¤ºä¾‹: <code>send_raw_transaction</code></a></h2>
<h3 id="ç¤ºä¾‹-70"><a class="header" href="#ç¤ºä¾‹-70">ç¤ºä¾‹</a></h3>
<p>è¿è¡Œæ­¤ç¤ºä¾‹çš„æ–¹æ³•ï¼š</p>
<ul>
<li>å…‹éš† <a href="https://github.com/alloy-rs/examples" title="" target="_blank">examples</a> ä»“åº“: <code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>è¿è¡Œ: <code>cargo run --example send_raw_transaction</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example of signing, encoding and sending a raw transaction using a wallet.

use alloy::{
    network::{EthereumWallet, TransactionBuilder},
    node_bindings::Anvil,
    primitives::U256,
    providers::{Provider, ProviderBuilder},
    rpc::types::TransactionRequest,
    signers::local::PrivateKeySigner,
};
use eyre::Result;

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    // Spin up a forked Anvil node.
    // Ensure `anvil` is available in $PATH.
    let anvil = Anvil::new().try_spawn()?;

    // Create a provider.
    let rpc_url = anvil.endpoint().parse()?;
    let provider = ProviderBuilder::new().on_http(rpc_url);

    // Set up signer from the first default Anvil account (Alice).
    let signer: PrivateKeySigner = anvil.keys()[0].clone().into();
    let wallet = EthereumWallet::from(signer);

    // Create two users, Alice and Bob.
    let alice = anvil.addresses()[0];
    let bob = anvil.addresses()[1];

    // Build a transaction to send 100 wei from Alice to Bob.
    // The `from` field is automatically filled to the first signer's address (Alice).
    let tx = TransactionRequest::default()
        .with_to(bob)
        .with_nonce(0)
        .with_chain_id(anvil.chain_id())
        .with_value(U256::from(100))
        .with_gas_limit(21_000)
        .with_max_priority_fee_per_gas(1_000_000_000)
        .with_max_fee_per_gas(20_000_000_000);

    // Build and sign the transaction using the `EthereumWallet` with the provided wallet.
    let tx_envelope = tx.build(&amp;wallet).await?;

    // Send the raw transaction and retrieve the transaction receipt.
    // [Provider::send_tx_envelope] is a convenience method that encodes the transaction using
    // EIP-2718 encoding and broadcasts it to the network using [Provider::send_raw_transaction].
    let receipt = provider.send_tx_envelope(tx_envelope).await?.get_receipt().await?;

    println!("Sent transaction: {}", receipt.transaction_hash);

    assert_eq!(receipt.from, alice);
    assert_eq!(receipt.to, Some(bob));

    Ok(())
}</code></pre>
<p>åœ¨ Github ä¸ŠæŸ¥çœ‹æºç  <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/transactions/examples/send_raw_transaction.rs" title="" target="_blank">è¿™é‡Œ</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><!-- DO NOT EDIT THIS FILE. IT IS GENERATED BY RUNNING `./scripts/update.sh` -->
<!-- ANY CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN -->
<!-- EDIT OR CREATE THIS TEMPLATE INSTEAD: ./src/templates/transactions/with_access_list.md -->
<!-- LATEST UPDATE: https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="ç¤ºä¾‹-with_access_list-1"><a class="header" href="#ç¤ºä¾‹-with_access_list-1">ç¤ºä¾‹: <code>with_access_list</code></a></h2>
<h3 id="ç¤ºä¾‹-71"><a class="header" href="#ç¤ºä¾‹-71">ç¤ºä¾‹</a></h3>
<p>è¿è¡Œæœ¬ç¤ºä¾‹ï¼š</p>
<ul>
<li>å…‹éš† <a href="https://github.com/alloy-rs/examples" title="" target="_blank">examples</a> ä»“åº“: <code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>è¿è¡Œ: <code>cargo run --example with_access_list</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example of sending a EIP-1559 transaction with access list.

use alloy::{
    node_bindings::Anvil,
    providers::{Provider, ProviderBuilder},
    rpc::types::TransactionRequest,
    sol,
};
use eyre::Result;

// Codegen from artifact.
sol!(
    #[allow(missing_docs)]
    #[sol(rpc)]
    SimpleStorage,
    "examples/artifacts/SimpleStorage.json"
);

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    // Spin up a local Anvil node.
    // Ensure `anvil` is available in $PATH.
    let anvil = Anvil::new().try_spawn()?;

    // Create a provider.
    let provider =
        ProviderBuilder::new().with_recommended_fillers().on_builtin(&amp;anvil.endpoint()).await?;

    // Deploy the `SimpleStorage` contract.
    let alice = anvil.addresses()[0];
    let contract_address = SimpleStorage::deploy_builder(provider.clone(), "initial".to_string())
        .from(alice)
        .deploy()
        .await?;
    let contract = SimpleStorage::new(contract_address, provider.clone());

    // Build a transaction to set the values of the contract.
    // The `from` field is automatically filled to the first signer's address (Alice).
    let set_value_call = contract.setValues("hello".to_string(), "world".to_string());
    let calldata = set_value_call.calldata().to_owned();
    let bob = anvil.addresses()[1];
    let tx = TransactionRequest::default().from(bob).to(contract_address).input(calldata.into());

    // Create an access list for the transaction.
    let access_list_with_gas_used = provider.create_access_list(&amp;tx).await?;

    // Add the access list to the transaction.
    let tx_with_access_list = tx.access_list(access_list_with_gas_used.access_list);

    // Send the transaction with the access list.
    let tx_hash = provider.send_transaction(tx_with_access_list).await?.watch().await?;

    println!("Transaction hash: {tx_hash}");

    // Check the value of the contract.
    let value = contract.getValue().call().await?;

    assert_eq!(value._0, "hello".to_string());

    Ok(())
}</code></pre>
<p>åœ¨ Github ä¸ŠæŸ¥çœ‹æºç  <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/transactions/examples/with_access_list.rs" title="" target="_blank">here</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><!-- DO NOT EDIT THIS FILE. IT IS GENERATED BY RUNNING `./scripts/update.sh` -->
<!-- ANY CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN -->
<!-- EDIT OR CREATE THIS TEMPLATE INSTEAD: ./src/templates/transactions/send_eip1559_transaction.md -->
<!-- LATEST UPDATE: https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="ç¤ºä¾‹-send_eip1559_transaction-1"><a class="header" href="#ç¤ºä¾‹-send_eip1559_transaction-1">ç¤ºä¾‹: <code>send_eip1559_transaction</code></a></h2>
<h3 id="ç¤ºä¾‹-72"><a class="header" href="#ç¤ºä¾‹-72">ç¤ºä¾‹</a></h3>
<p>è¦è¿è¡Œè¿™ä¸ªç¤ºä¾‹ï¼š</p>
<ul>
<li>å…‹éš† <a href="https://github.com/alloy-rs/examples" title="" target="_blank">examples</a> ä»“åº“ï¼š<code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>è¿è¡Œï¼š<code>cargo run --example send_eip1559_transaction</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example showing how to send an [EIP-1559](https://eips.ethereum.org/EIPS/eip-1559) transaction.

use alloy::{
    network::TransactionBuilder,
    node_bindings::Anvil,
    primitives::U256,
    providers::{Provider, ProviderBuilder},
    rpc::types::TransactionRequest,
};
use eyre::Result;

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    // Spin up a local Anvil node.
    // Ensure `anvil` is available in $PATH.
    let anvil = Anvil::new().try_spawn()?;

    // Create a provider.
    let rpc_url = anvil.endpoint().parse()?;
    let provider = ProviderBuilder::new().on_http(rpc_url);

    // Create two users, Alice and Bob.
    let alice = anvil.addresses()[0];
    let bob = anvil.addresses()[1];

    // Build a transaction to send 100 wei from Alice to Bob.
    // The `from` field is automatically filled to the first signer's address (Alice).
    let tx = TransactionRequest::default()
        .with_to(bob)
        .with_nonce(0)
        .with_chain_id(anvil.chain_id())
        .with_value(U256::from(100))
        .with_gas_limit(21_000)
        .with_max_priority_fee_per_gas(1_000_000_000)
        .with_max_fee_per_gas(20_000_000_000);

    // Send the transaction and wait for the broadcast.
    let pending_tx = provider.send_transaction(tx).await?;

    println!("Pending transaction... {}", pending_tx.tx_hash());

    // Wait for the transaction to be included and get the receipt.
    let receipt = pending_tx.get_receipt().await?;

    println!(
        "Transaction included in block {}",
        receipt.block_number.expect("Failed to get block number")
    );

    assert_eq!(receipt.from, alice);
    assert_eq!(receipt.to, Some(bob));

    Ok(())
}</code></pre>
<p>åœ¨ Github ä¸Šå¯ä»¥æ‰¾åˆ°æºä»£ç  <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/transactions/examples/send_eip1559_transaction.rs" title="" target="_blank">è¿™é‡Œ</a>ã€‚</p>
<div style="break-before: page; page-break-before: always;"></div><!-- DO NOT EDIT THIS FILE. IT IS GENERATED BY RUNNING `./scripts/update.sh` -->
<!-- ANY CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN -->
<!-- EDIT OR CREATE THIS TEMPLATE INSTEAD: ./src/templates/transactions/send_legacy_transaction.md -->
<!-- LATEST UPDATE: https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="ç¤ºä¾‹-send_legacy_transaction-1"><a class="header" href="#ç¤ºä¾‹-send_legacy_transaction-1">ç¤ºä¾‹: <code>send_legacy_transaction</code></a></h2>
<h3 id="ç¤ºä¾‹-73"><a class="header" href="#ç¤ºä¾‹-73">ç¤ºä¾‹</a></h3>
<p>è¦è¿è¡Œæ­¤ç¤ºä¾‹ï¼š</p>
<ul>
<li>å…‹éš† <a href="https://github.com/alloy-rs/examples" title="" target="_blank">examples</a> ä»“åº“: <code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>è¿è¡Œ: <code>cargo run --example send_legacy_transaction</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example showing how to send a legacy transaction.

use alloy::{
    network::TransactionBuilder,
    node_bindings::Anvil,
    primitives::U256,
    providers::{Provider, ProviderBuilder},
    rpc::types::TransactionRequest,
};
use eyre::Result;

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    // Spin up a local Anvil node.
    // Ensure `anvil` is available in $PATH.
    let anvil = Anvil::new().try_spawn()?;

    // Create a provider.
    let rpc_url = anvil.endpoint().parse()?;
    let provider = ProviderBuilder::new().on_http(rpc_url);

    // Create two users, Alice and Bob.
    let alice = anvil.addresses()[0];
    let bob = anvil.addresses()[1];

    // Build a transaction to send 100 wei from Alice to Bob.
    // The `from` field is automatically filled to the first signer's address (Alice).
    let tx = TransactionRequest::default()
        .with_to(bob)
        .with_nonce(0)
        .with_value(U256::from(100))
        .with_gas_price(20_000_000_000)
        .with_gas_limit(21_000);

    // Send the transaction and wait for the broadcast.
    let pending_tx = provider.send_transaction(tx).await?;

    println!("Pending transaction... {}", pending_tx.tx_hash());

    // Wait for the transaction to be included and get the receipt.
    let receipt = pending_tx.get_receipt().await?;

    println!(
        "Transaction included in block {}",
        receipt.block_number.expect("Failed to get block number")
    );

    assert_eq!(receipt.from, alice);
    assert_eq!(receipt.to, Some(bob));

    Ok(())
}</code></pre>
<p>åœ¨ Github ä¸ŠæŸ¥çœ‹æºä»£ç  <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/transactions/examples/send_legacy_transaction.rs" title="" target="_blank">è¿™é‡Œ</a>ã€‚</p>
<div style="break-before: page; page-break-before: always;"></div><!-- DO NOT EDIT THIS FILE. IT IS GENERATED BY RUNNING `./scripts/update.sh` -->
<!-- ANY CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN -->
<!-- EDIT OR CREATE THIS TEMPLATE INSTEAD: ./src/templates/transactions/send_eip4844_transaction.md -->
<!-- LATEST UPDATE: https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="ç¤ºä¾‹-send_eip4844_transaction-1"><a class="header" href="#ç¤ºä¾‹-send_eip4844_transaction-1">ç¤ºä¾‹: <code>send_eip4844_transaction</code></a></h2>
<h3 id="ç¤ºä¾‹-74"><a class="header" href="#ç¤ºä¾‹-74">ç¤ºä¾‹</a></h3>
<p>è¿è¡Œæ­¤ç¤ºä¾‹:</p>
<ul>
<li>å…‹éš† <a href="https://github.com/alloy-rs/examples" title="" target="_blank">examples</a> ä»“åº“: <code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>è¿è¡Œ: <code>cargo run --example send_eip4844_transaction</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example showing how to send an [EIP-4844](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-4844.md) transaction.

use alloy::{
    consensus::{SidecarBuilder, SimpleCoder},
    eips::eip4844::DATA_GAS_PER_BLOB,
    network::TransactionBuilder,
    node_bindings::Anvil,
    providers::{Provider, ProviderBuilder},
    rpc::types::TransactionRequest,
};
use eyre::Result;

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    // Spin up a local Anvil node with the Cancun hardfork enabled.
    // Ensure `anvil` is available in $PATH.
    let anvil = Anvil::new().args(["--hardfork", "cancun"]).try_spawn()?;

    // Create a provider.
    let provider = ProviderBuilder::new().on_builtin(&amp;anvil.endpoint()).await?;

    // Create two users, Alice and Bob.
    let alice = anvil.addresses()[0];
    let bob = anvil.addresses()[1];

    // Create a sidecar with some data.
    let sidecar: SidecarBuilder&lt;SimpleCoder&gt; = SidecarBuilder::from_slice(b"Blobs are fun!");
    let sidecar = sidecar.build()?;

    // Build a transaction to send the sidecar from Alice to Bob.
    // The `from` field is automatically filled to the first signer's address (Alice).
    let gas_price = provider.get_gas_price().await?;
    let eip1559_est = provider.estimate_eip1559_fees(None).await?;
    let tx = TransactionRequest::default()
        .with_to(bob)
        .with_nonce(0)
        .with_max_fee_per_blob_gas(gas_price)
        .with_max_fee_per_gas(eip1559_est.max_fee_per_gas)
        .with_max_priority_fee_per_gas(eip1559_est.max_priority_fee_per_gas)
        .with_blob_sidecar(sidecar);

    // Send the transaction and wait for the broadcast.
    let pending_tx = provider.send_transaction(tx).await?;

    println!("Pending transaction... {}", pending_tx.tx_hash());

    // Wait for the transaction to be included and get the receipt.
    let receipt = pending_tx.get_receipt().await?;

    println!(
        "Transaction included in block {}",
        receipt.block_number.expect("Failed to get block number")
    );

    assert_eq!(receipt.from, alice);
    assert_eq!(receipt.to, Some(bob));
    assert_eq!(
        receipt.blob_gas_used.expect("Expected to be EIP-4844 transaction"),
        DATA_GAS_PER_BLOB as u128
    );

    Ok(())
}</code></pre>
<p>åœ¨ Github ä¸Šå¯ä»¥æ‰¾åˆ°æºç  <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/transactions/examples/send_eip4844_transaction.rs" title="" target="_blank">è¿™é‡Œ</a>ã€‚</p>
<div style="break-before: page; page-break-before: always;"></div><!-- DO NOT EDIT THIS FILE. IT IS GENERATED BY RUNNING `./scripts/update.sh` -->
<!-- ANY CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN -->
<!-- EDIT OR CREATE THIS TEMPLATE INSTEAD: ./src/templates/transactions/send_private_transaction.md -->
<!-- LATEST UPDATE: https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="ç¤ºä¾‹-send_private_transaction"><a class="header" href="#ç¤ºä¾‹-send_private_transaction">ç¤ºä¾‹: <code>send_private_transaction</code></a></h2>
<h3 id="ç¤ºä¾‹-75"><a class="header" href="#ç¤ºä¾‹-75">ç¤ºä¾‹</a></h3>
<p>è¿è¡Œæ­¤ç¤ºä¾‹æ­¥éª¤ï¼š</p>
<ul>
<li>å…‹éš† <a href="https://github.com/alloy-rs/examples" title="" target="_blank">examples</a> ä»“åº“: <code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>è¿è¡Œ: <code>cargo run --example send_private_transaction</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example of sending a private transaction using Flashbots Protect.

use alloy::{
    network::{eip2718::Encodable2718, EthereumWallet, TransactionBuilder},
    primitives::U256,
    providers::{Provider, ProviderBuilder},
    rpc::types::TransactionRequest,
    signers::local::PrivateKeySigner,
};
use eyre::Result;

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    // Set up the HTTP transport which is consumed by the RPC client.
    //
    // By default, Flashbots Protect transactions are only shared with the Flashbots Builder, which
    // builds only a subset of all Ethereum blocks. In `fast` mode, transactions are shared with
    // all registered builders no less than one block after they are received to increase the
    // number of blocks the user's transaction can be included in.
    //
    // Fast mode has 2 key differences from the default Protect experience:
    // - Shared with all builders: By default, Flashbots Protect transactions are only shared with
    //   the Flashbots Builder, which builds only a subset of all Ethereum blocks. In fast mode,
    //   transactions are shared with all registered builders no less than one block after they are
    //   received to increase the number of blocks the user's transaction can be included in.
    // - Larger refund paid to validator: By default, only 10% of MEV-Share refunds are paid to
    //   validators. In fast mode, validators receive 50% of refunds which makes it more likely that
    //   the userâ€™s transactions will be chosen in a given block.
    //
    // For more information, see the [Flashbots documentation](https://docs.flashbots.net/flashbots-protect/overview).
    //
    // To use `fast` mode change the URL to `https://rpc.flashbots.net/fast`.
    let flashbots_url = "https://rpc.flashbots.net".parse()?;

    // Create a provider.
    let provider = ProviderBuilder::new().on_http(flashbots_url);

    // Create a signer from a random private key.
    let signer = PrivateKeySigner::random();
    let wallet = EthereumWallet::from(signer);

    // Build a transaction to send 100 wei from Alice to Bob.
    // The `from` field is automatically filled to the first signer's address (Alice).
    let bob = PrivateKeySigner::random().address();
    let tx = TransactionRequest::default()
        .with_to(bob)
        .with_nonce(0)
        .with_chain_id(1)
        .with_value(U256::from(100))
        .with_gas_limit(21_000)
        .with_max_priority_fee_per_gas(1_000_000_000)
        .with_max_fee_per_gas(20_000_000_000);

    // Build the transaction with the provided wallet. Flashbots Protect requires the transaction to
    // be signed locally and send using `eth_sendRawTransaction`.
    let tx_envelope = tx.build(&amp;wallet).await?;

    // Encode the transaction using EIP-2718 encoding.
    let tx_encoded = tx_envelope.encoded_2718();

    // Send the raw transaction. The transaction is sent to the Flashbots relay and, if valid, will
    // be included in a block by a Flashbots builder. Note that the transaction request, as defined,
    // is invalid and will not be included in the blockchain.
    let pending = provider.send_raw_transaction(&amp;tx_encoded).await?.register().await?;

    println!("Sent transaction: {}", pending.tx_hash());

    Ok(())
}</code></pre>
<p>åœ¨ Github ä¸Šæ‰¾åˆ°æºä»£ç  <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/transactions/examples/send_private_transaction.rs" title="" target="_blank">here</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="é’±åŒ…"><a class="header" href="#é’±åŒ…">é’±åŒ…</a></h2>
<ul>
<li><a href="examples/wallets/aws_signer.html">AWS ç­¾åå™¨</a></li>
<li><a href="examples/wallets/ledger_signer.html">Ledger ç­¾åå™¨</a></li>
<li><a href="examples/wallets/private_key_signer.html">ç§é’¥ç­¾åå™¨</a></li>
<li><a href="examples/wallets/mnemonic_signer.html">åŠ©è®°è¯ç­¾åå™¨</a></li>
<li><a href="examples/wallets/sign_message.html">ç­¾åæ¶ˆæ¯</a></li>
<li><a href="examples/wallets/verify_message.html">éªŒè¯æ¶ˆæ¯</a></li>
<li><a href="examples/wallets/sign_permit_hash.html">ç­¾åè®¸å¯å“ˆå¸Œ</a></li>
<li><a href="examples/wallets/trezor_signer.html">Trezor ç­¾åå™¨</a></li>
<li><a href="examples/wallets/yubi_signer.html">Yubi ç­¾åå™¨</a></li>
<li><a href="examples/wallets/keystore_signer.html">å¯†é’¥åº“ç­¾åå™¨</a></li>
<li><a href="examples/wallets/create_keystore.html">åˆ›å»ºå¯†é’¥åº“</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><!-- DO NOT EDIT THIS FILE. IT IS GENERATED BY RUNNING `./scripts/update.sh` -->
<!-- ANY CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN -->
<!-- EDIT OR CREATE THIS TEMPLATE INSTEAD: ./src/templates/wallets/aws_signer.md -->
<!-- LATEST UPDATE: https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="ç¤ºä¾‹-aws_signer"><a class="header" href="#ç¤ºä¾‹-aws_signer">ç¤ºä¾‹: <code>aws_signer</code></a></h2>
<h3 id="ç¤ºä¾‹-76"><a class="header" href="#ç¤ºä¾‹-76">ç¤ºä¾‹</a></h3>
<p>è¦è¿è¡Œæ­¤ç¤ºä¾‹ï¼š</p>
<ul>
<li>å…‹éš† <a href="https://github.com/alloy-rs/examples" title="" target="_blank">examples</a> ä»“åº“ï¼š<code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>è¿è¡Œï¼š<code>cargo run --example aws_signer</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example showing how to use the AWS KMS signer.

use alloy::signers::{aws::AwsSigner, Signer};
use aws_config::BehaviorVersion;
use eyre::Result;

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    let Ok(key_id) = std::env::var("AWS_KEY_ID") else {
        return Ok(());
    };

    let config = aws_config::load_defaults(BehaviorVersion::latest()).await;
    let client = aws_sdk_kms::Client::new(&amp;config);
    let signer = AwsSigner::new(client, key_id, Some(1)).await?;

    let message = "Hello, world!";
    let signature = signer.sign_message(message.as_bytes()).await?;

    assert_eq!(signature.recover_address_from_msg(message)?, signer.address());

    Ok(())
}</code></pre>
<p>åœ¨ Github ä¸Šå¯ä»¥æ‰¾åˆ°æºä»£ç  <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/wallets/examples/aws_signer.rs" title="" target="_blank">è¿™é‡Œ</a>ã€‚</p>
<div style="break-before: page; page-break-before: always;"></div><!-- DO NOT EDIT THIS FILE. IT IS GENERATED BY RUNNING `./scripts/update.sh` -->
<!-- ANY CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN -->
<!-- EDIT OR CREATE THIS TEMPLATE INSTEAD: ./src/templates/wallets/ledger_signer.md -->
<!-- LATEST UPDATE: https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="ç¤ºä¾‹ledger_signer"><a class="header" href="#ç¤ºä¾‹ledger_signer">ç¤ºä¾‹ï¼š<code>ledger_signer</code></a></h2>
<h3 id="ç¤ºä¾‹-77"><a class="header" href="#ç¤ºä¾‹-77">ç¤ºä¾‹</a></h3>
<p>è¦è¿è¡Œæ­¤ç¤ºä¾‹ï¼š</p>
<ul>
<li>å…‹éš† <a href="https://github.com/alloy-rs/examples" title="" target="_blank">examples</a> ä»“åº“ï¼š<code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>è¿è¡Œï¼š<code>cargo run --example ledger_signer</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example of signing and sending a transaction using a Ledger device.

use alloy::{
    network::{EthereumWallet, TransactionBuilder},
    primitives::{address, U256},
    providers::{Provider, ProviderBuilder},
    rpc::types::TransactionRequest,
    signers::ledger::{HDPath, LedgerSigner},
};
use eyre::Result;

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    // Set up the HTTP transport which is consumed by the RPC client.
    let rpc_url = "https://eth.merkle.io".parse()?;

    // Instantiate the application by acquiring a lock on the Ledger device.
    let signer = LedgerSigner::new(HDPath::LedgerLive(0), Some(1)).await?;
    let wallet = EthereumWallet::from(signer);

    // Create a provider with the wallet.
    let provider =
        ProviderBuilder::new().with_recommended_fillers().wallet(wallet).on_http(rpc_url);

    // Build a transaction to send 100 wei from Alice to Vitalik.
    // The `from` field is automatically filled to the first signer's address (Alice).
    let vitalik = address!("d8dA6BF26964aF9D7eEd9e03E53415D37aA96045");
    let tx = TransactionRequest::default().with_to(vitalik).with_value(U256::from(100));

    // Send the transaction and wait for inclusion with 3 confirmations.
    let tx_hash =
        provider.send_transaction(tx).await?.with_required_confirmations(3).watch().await?;

    println!("Sent transaction: {tx_hash}");

    Ok(())
}</code></pre>
<p>åœ¨ Github ä¸Šå¯ä»¥æ‰¾åˆ°æºä»£ç  <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/wallets/examples/ledger_signer.rs" title="" target="_blank">here</a>ã€‚</p>
<div style="break-before: page; page-break-before: always;"></div><!-- DO NOT EDIT THIS FILE. IT IS GENERATED BY RUNNING `./scripts/update.sh` -->
<!-- ANY CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN -->
<!-- EDIT OR CREATE THIS TEMPLATE INSTEAD: ./src/templates/wallets/private_key_signer.md -->
<!-- LATEST UPDATE: https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="ç¤ºä¾‹private_key_signer"><a class="header" href="#ç¤ºä¾‹private_key_signer">ç¤ºä¾‹ï¼š<code>private_key_signer</code></a></h2>
<h3 id="ç¤ºä¾‹-78"><a class="header" href="#ç¤ºä¾‹-78">ç¤ºä¾‹</a></h3>
<p>è¿è¡Œæ­¤ç¤ºä¾‹ï¼š</p>
<ul>
<li>å…‹éš† <a href="https://github.com/alloy-rs/examples" title="" target="_blank">examples</a> ä»“åº“ï¼š<code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>è¿è¡Œï¼š<code>cargo run --example private_key_signer</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example of using a local wallet to sign and send a transaction.

use alloy::{
    network::{EthereumWallet, TransactionBuilder},
    node_bindings::Anvil,
    primitives::{address, U256},
    providers::{Provider, ProviderBuilder},
    rpc::types::TransactionRequest,
    signers::local::PrivateKeySigner,
};
use eyre::Result;

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    // Spin up a local Anvil node.
    // Ensure `anvil` is available in $PATH.
    let anvil = Anvil::new().block_time(1).try_spawn()?;

    // Set up signer from the first default Anvil account (Alice).
    // [RISK WARNING! Writing a private key in the code file is insecure behavior.]
    // The following code is for testing only. Set up signer from private key, be aware of danger.
    // let signer: PrivateKeySigner = "&lt;PRIVATE_KEY&gt;".parse().expect("should parse private key");
    let signer: PrivateKeySigner = anvil.keys()[0].clone().into();
    let wallet = EthereumWallet::from(signer);

    // Create a provider with the wallet.
    let rpc_url = anvil.endpoint().parse()?;
    let provider =
        ProviderBuilder::new().with_recommended_fillers().wallet(wallet).on_http(rpc_url);

    // Build a transaction to send 100 wei from Alice to Vitalik.
    // The `from` field is automatically filled to the first signer's address (Alice).
    let tx = TransactionRequest::default()
        .with_to(address!("d8dA6BF26964aF9D7eEd9e03E53415D37aA96045"))
        .with_value(U256::from(100));

    // Send the transaction and wait for inclusion.
    let tx_hash = provider.send_transaction(tx).await?.watch().await?;

    println!("Sent transaction: {tx_hash}");

    Ok(())
}</code></pre>
<p>åœ¨ Github ä¸Šæ‰¾åˆ°æºä»£ç  <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/wallets/examples/private_key_signer.rs" title="" target="_blank">here</a>ã€‚</p>
<div style="break-before: page; page-break-before: always;"></div><!-- DO NOT EDIT THIS FILE. IT IS GENERATED BY RUNNING `./scripts/update.sh` -->
<!-- ANY CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN -->
<!-- EDIT OR CREATE THIS TEMPLATE INSTEAD: ./src/templates/wallets/mnemonic_signer.md -->
<!-- LATEST UPDATE: https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="ç¤ºä¾‹mnemonic_signer"><a class="header" href="#ç¤ºä¾‹mnemonic_signer">ç¤ºä¾‹ï¼š<code>mnemonic_signer</code></a></h2>
<h3 id="ç¤ºä¾‹-79"><a class="header" href="#ç¤ºä¾‹-79">ç¤ºä¾‹</a></h3>
<p>è¦è¿è¡Œæ­¤ç¤ºä¾‹ï¼š</p>
<ul>
<li>å…‹éš† <a href="https://github.com/alloy-rs/examples" title="" target="_blank">examples</a> ä»“åº“ï¼š <code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>è¿è¡Œï¼š<code>cargo run --example mnemonic_signer</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example of using `MnemonicBuilder` to access a wallet from a mnemonic phrase.

use alloy::signers::local::{coins_bip39::English, MnemonicBuilder};
use eyre::Result;

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    let phrase = "work man father plunge mystery proud hollow address reunion sauce theory bonus";
    let index = 0u32;
    let password = "TREZOR123";

    // Access mnemonic phrase with password.
    // Child key at derivation path: m/44'/60'/0'/0/{index}.
    let wallet = MnemonicBuilder::&lt;English&gt;::default()
        .phrase(phrase)
        .index(index)?
        // Use this if your mnemonic is encrypted.
        .password(password)
        .build()?;

    println!("Wallet: {}", wallet.address());

    // Generate a random wallet (24 word phrase) at custom derivation path.
    let wallet = MnemonicBuilder::&lt;English&gt;::default()
        .word_count(24)
        .derivation_path("m/44'/60'/0'/2/1")?
        // Optionally add this if you want the generated mnemonic to be written
        // to a file `.write_to(path)`.
        .build_random()?;

    println!("Random wallet: {}", wallet.address());

    Ok(())
}</code></pre>
<p>åœ¨ Github ä¸ŠæŸ¥çœ‹æºä»£ç  <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/wallets/examples/mnemonic_signer.rs" title="" target="_blank">here</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><!-- DO NOT EDIT THIS FILE. IT IS GENERATED BY RUNNING `./scripts/update.sh` -->
<!-- ANY CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN -->
<!-- EDIT OR CREATE THIS TEMPLATE INSTEAD: ./src/templates/wallets/sign_message.md -->
<!-- LATEST UPDATE: https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="ç¤ºä¾‹-sign_message"><a class="header" href="#ç¤ºä¾‹-sign_message">ç¤ºä¾‹: <code>sign_message</code></a></h2>
<h3 id="ç¤ºä¾‹-80"><a class="header" href="#ç¤ºä¾‹-80">ç¤ºä¾‹</a></h3>
<p>è¦è¿è¡Œæ­¤ç¤ºä¾‹ï¼š</p>
<ul>
<li>å…‹éš† <a href="https://github.com/alloy-rs/examples" title="" target="_blank">examples</a> ä»“åº“ï¼š<code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>è¿è¡Œï¼š<code>cargo run --example sign_message</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example of signing a message with a signer.

use alloy::signers::{local::PrivateKeySigner, Signer};
use eyre::Result;

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    // Set up a random signer.
    let signer = PrivateKeySigner::random();

    // Optionally, the wallet's chain id can be set, in order to use EIP-155
    // replay protection with different chains.
    let signer = signer.with_chain_id(Some(1337));

    // The message to sign.
    let message = b"hello";

    // Sign the message asynchronously with the signer.
    let signature = signer.sign_message(message).await?;

    println!("Signature produced by {}: {:?}", signer.address(), signature);
    println!("Signature recovered address: {}", signature.recover_address_from_msg(&amp;message[..])?);

    Ok(())
}</code></pre>
<p>åœ¨ Github ä¸Šå¯ä»¥æ‰¾åˆ°æºç  <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/wallets/examples/sign_message.rs" title="" target="_blank">è¿™é‡Œ</a>ã€‚</p>
<div style="break-before: page; page-break-before: always;"></div><!-- DO NOT EDIT THIS FILE. IT IS GENERATED BY RUNNING `./scripts/update.sh` -->
<!-- ANY CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN -->
<!-- EDIT OR CREATE THIS TEMPLATE INSTEAD: ./src/templates/wallets/verify_message.md -->
<!-- LATEST UPDATE: https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="ç¤ºä¾‹-verify_message"><a class="header" href="#ç¤ºä¾‹-verify_message">ç¤ºä¾‹: <code>verify_message</code></a></h2>
<h3 id="ç¤ºä¾‹-81"><a class="header" href="#ç¤ºä¾‹-81">ç¤ºä¾‹</a></h3>
<p>è¦è¿è¡Œæ­¤ç¤ºä¾‹ï¼š</p>
<ul>
<li>å…‹éš† <a href="https://github.com/alloy-rs/examples" title="" target="_blank">examples</a> ä»“åº“: <code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>è¿è¡Œ: <code>cargo run --example verify_message</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example of verifying that a message was signed by the provided address.

use alloy::signers::{local::PrivateKeySigner, SignerSync};
use eyre::{Ok, Result};

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    // Instantiate a signer.
    let signer = PrivateKeySigner::random();

    // Sign a message.
    let message = "Some data";
    let signature = signer.sign_message_sync(message.as_bytes())?;

    // Recover the signer from the message.
    let recovered = signature.recover_address_from_msg(message)?;
    assert_eq!(recovered, signer.address());

    Ok(())
}</code></pre>
<p>åœ¨ Github ä¸Šå¯ä»¥æ‰¾åˆ°æºç  <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/wallets/examples/verify_message.rs" title="" target="_blank">here</a>ã€‚</p>
<div style="break-before: page; page-break-before: always;"></div><!-- DO NOT EDIT THIS FILE. IT IS GENERATED BY RUNNING `./scripts/update.sh` -->
<!-- ANY CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN -->
<!-- EDIT OR CREATE THIS TEMPLATE INSTEAD: ./src/templates/wallets/sign_permit_hash.md -->
<!-- LATEST UPDATE: https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="ç¤ºä¾‹-sign_permit_hash"><a class="header" href="#ç¤ºä¾‹-sign_permit_hash">ç¤ºä¾‹: <code>sign_permit_hash</code></a></h2>
<h3 id="ç¤ºä¾‹-82"><a class="header" href="#ç¤ºä¾‹-82">ç¤ºä¾‹</a></h3>
<p>è¦è¿è¡Œè¿™ä¸ªç¤ºä¾‹ï¼š</p>
<ul>
<li>å…‹éš† <a href="https://github.com/alloy-rs/examples" title="" target="_blank">examples</a> ä»“åº“: <code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>è¿è¡Œ: <code>cargo run --example sign_permit_hash</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example of signing a permit hash using a wallet.

use alloy::{
    primitives::{address, keccak256, U256},
    signers::{local::PrivateKeySigner, Signer},
    sol,
    sol_types::{eip712_domain, SolStruct},
};
use eyre::Result;
use serde::Serialize;

sol! {
    #[allow(missing_docs)]
    #[derive(Serialize)]
    struct Permit {
        address owner;
        address spender;
        uint256 value;
        uint256 nonce;
        uint256 deadline;
    }
}

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    // Set up a random signer.
    let signer = PrivateKeySigner::random();

    let domain = eip712_domain! {
        name: "Uniswap V2",
        version: "1",
        chain_id: 1,
        verifying_contract: address!("B4e16d0168e52d35CaCD2c6185b44281Ec28C9Dc"),
        salt: keccak256("test"),
    };

    let permit = Permit {
        owner: signer.address(),
        spender: address!("B4e16d0168e52d35CaCD2c6185b44281Ec28C9Dc"),
        value: U256::from(100),
        nonce: U256::from(0),
        deadline: U256::from(0),
    };

    // Derive the EIP-712 signing hash.
    let hash = permit.eip712_signing_hash(&amp;domain);

    // Sign the hash asynchronously with the wallet.
    let signature = signer.sign_hash(&amp;hash).await?;

    println!(
        "Recovered address matches wallet address: {}",
        signature.recover_address_from_prehash(&amp;hash)? == signer.address()
    );

    println!("Wallet signature matches: {}", signer.sign_hash(&amp;hash).await? == signature);

    Ok(())
}</code></pre>
<p>åœ¨ Github ä¸ŠæŸ¥çœ‹æºä»£ç  <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/wallets/examples/sign_permit_hash.rs" title="" target="_blank">here</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><!-- DO NOT EDIT THIS FILE. IT IS GENERATED BY RUNNING `./scripts/update.sh` -->
<!-- ANY CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN -->
<!-- EDIT OR CREATE THIS TEMPLATE INSTEAD: ./src/templates/wallets/trezor_signer.md -->
<!-- LATEST UPDATE: https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="ç¤ºä¾‹-trezor_signer"><a class="header" href="#ç¤ºä¾‹-trezor_signer">ç¤ºä¾‹: <code>trezor_signer</code></a></h2>
<h3 id="ç¤ºä¾‹-83"><a class="header" href="#ç¤ºä¾‹-83">ç¤ºä¾‹</a></h3>
<p>è¦è¿è¡Œè¿™ä¸ªç¤ºä¾‹ï¼š</p>
<ul>
<li>å…‹éš† <a href="https://github.com/alloy-rs/examples" title="" target="_blank">examples</a> ä»“åº“: <code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>è¿è¡Œ: <code>cargo run --example trezor_signer</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example of signing and sending a transaction using a Trezor device.

use alloy::{
    network::{EthereumWallet, TransactionBuilder},
    primitives::{address, U256},
    providers::{Provider, ProviderBuilder},
    rpc::types::TransactionRequest,
    signers::trezor::{HDPath, TrezorSigner},
};
use eyre::Result;

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    // Set up the HTTP transport which is consumed by the RPC client.
    let rpc_url = "https://eth.merkle.io".parse()?;

    // Instantiate the application by acquiring a lock on the Trezor device.
    let signer = TrezorSigner::new(HDPath::TrezorLive(0), Some(1)).await?;
    let wallet = EthereumWallet::from(signer);

    // Create a provider with the wallet.
    let provider =
        ProviderBuilder::new().with_recommended_fillers().wallet(wallet).on_http(rpc_url);

    // Build a transaction to send 100 wei from Alice to Vitalik.
    // The `from` field is automatically filled to the first signer's address (Alice).
    let vitalik = address!("d8dA6BF26964aF9D7eEd9e03E53415D37aA96045");
    let tx = TransactionRequest::default().with_to(vitalik).with_value(U256::from(100));

    // Send the transaction and wait for inclusion with 3 confirmations.
    let tx_hash =
        provider.send_transaction(tx).await?.with_required_confirmations(3).watch().await?;

    println!("Sent transaction: {tx_hash}");

    Ok(())
}</code></pre>
<p>åœ¨ Github ä¸Šæ‰¾åˆ°æºç  <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/wallets/examples/trezor_signer.rs" title="" target="_blank">è¿™é‡Œ</a>ã€‚</p>
<div style="break-before: page; page-break-before: always;"></div><!-- ä¸è¦ç¼–è¾‘è¿™ä¸ªæ–‡ä»¶ã€‚å®ƒæ˜¯é€šè¿‡è¿è¡Œ `./scripts/update.sh` ç”Ÿæˆçš„ -->
<!-- å¯¹è¿™ä¸ªæ–‡ä»¶çš„ä»»ä½•ä¿®æ”¹éƒ½ä¼šè¢«è¦†ç›– -->
<!-- è¯·ç¼–è¾‘æˆ–åˆ›å»ºæ­¤æ¨¡æ¿ï¼š./src/templates/wallets/yubi_signer.md -->
<!-- æœ€æ–°æ›´æ–°ï¼š https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="ç¤ºä¾‹yubi_signer"><a class="header" href="#ç¤ºä¾‹yubi_signer">ç¤ºä¾‹ï¼š<code>yubi_signer</code></a></h2>
<h3 id="ç¤ºä¾‹-84"><a class="header" href="#ç¤ºä¾‹-84">ç¤ºä¾‹</a></h3>
<p>è¿è¡Œè¿™ä¸ªç¤ºä¾‹ï¼š</p>
<ul>
<li>å…‹éš† <a href="https://github.com/alloy-rs/examples" title="" target="_blank">examples</a> ä»“åº“ï¼š<code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>è¿è¡Œï¼š<code>cargo run --example yubi_signer</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example of signing and sending a transaction using a Yubi device.

use alloy::{
    network::{EthereumWallet, TransactionBuilder},
    primitives::{address, U256},
    providers::{Provider, ProviderBuilder},
    rpc::types::TransactionRequest,
    signers::local::{
        yubihsm::{Connector, Credentials, UsbConfig},
        YubiSigner,
    },
};
use eyre::Result;

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    // Set up the HTTP transport which is consumed by the RPC client.
    let rpc_url = "https://eth.merkle.io".parse()?;

    // We use USB for the example, but you can connect over HTTP as well. Refer
    // to the [YubiHSM](https://docs.rs/yubihsm/0.34.0/yubihsm/) docs for more information.
    let connector = Connector::usb(&amp;UsbConfig::default());

    // Instantiate the connection to the YubiKey. Alternatively, use the
    // `from_key` method to upload a key you already have, or the `new` method
    // to generate a new keypair.
    let signer = YubiSigner::connect(connector, Credentials::default(), 0);
    let wallet = EthereumWallet::from(signer);

    // Create a provider with the wallet.
    let provider =
        ProviderBuilder::new().with_recommended_fillers().wallet(wallet).on_http(rpc_url);

    // Build a transaction to send 100 wei from Alice to Vitalik.
    // The `from` field is automatically filled to the first signer's address (Alice).
    let vitalik = address!("d8dA6BF26964aF9D7eEd9e03E53415D37aA96045");
    let tx = TransactionRequest::default().with_to(vitalik).with_value(U256::from(100));

    // Send the transaction and wait for inclusion with 3 confirmations.
    let tx_hash =
        provider.send_transaction(tx).await?.with_required_confirmations(3).watch().await?;

    println!("Sent transaction: {tx_hash}");

    Ok(())
}</code></pre>
<p>åœ¨ Github ä¸Šæ‰¾åˆ°æºç  <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/wallets/examples/yubi_signer.rs" title="" target="_blank">è¿™é‡Œ</a>ã€‚</p>
<div style="break-before: page; page-break-before: always;"></div><!-- è¯·å‹¿ç¼–è¾‘æ­¤æ–‡ä»¶ã€‚å®ƒæ˜¯é€šè¿‡è¿è¡Œ `./scripts/update.sh` ç”Ÿæˆçš„ -->
<!-- å¯¹æ­¤æ–‡ä»¶æ‰€åšçš„ä»»ä½•æ›´æ”¹éƒ½å°†è¢«è¦†ç›– -->
<!-- è¯·ç¼–è¾‘æˆ–åˆ›å»ºè¿™ä¸ªæ¨¡æ¿æ–‡ä»¶ï¼š./src/templates/wallets/keystore_signer.md -->
<!-- æœ€æ–°æ›´æ–°ï¼šhttps://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="ç¤ºä¾‹-keystore_signer"><a class="header" href="#ç¤ºä¾‹-keystore_signer">ç¤ºä¾‹: <code>keystore_signer</code></a></h2>
<h3 id="ç¤ºä¾‹-85"><a class="header" href="#ç¤ºä¾‹-85">ç¤ºä¾‹</a></h3>
<p>è¦è¿è¡Œæ­¤ç¤ºä¾‹ï¼š</p>
<ul>
<li>å…‹éš† <a href="https://github.com/alloy-rs/examples" title="" target="_blank">examples</a> ä»“åº“ï¼š<code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>è¿è¡Œï¼š<code>cargo run --example keystore_signer</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example of using a keystore wallet to sign and send a transaction.

use alloy::{
    network::{EthereumWallet, TransactionBuilder},
    node_bindings::Anvil,
    primitives::{address, U256},
    providers::{Provider, ProviderBuilder},
    rpc::types::TransactionRequest,
    signers::local::LocalSigner,
};
use eyre::Result;
use std::{env, path::PathBuf};

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    // Spin up a local Anvil node.
    // Ensure `anvil` is available in $PATH.
    let anvil = Anvil::new().block_time(1).try_spawn()?;

    // Password to decrypt the keystore file with.
    let password = "test";

    // Set up signer using Alice's keystore file.
    // The private key belongs to Alice, the first default Anvil account.
    let keystore_file_path =
        PathBuf::from(env::var("CARGO_MANIFEST_DIR")?).join("examples/keystore/alice.json");
    let signer = LocalSigner::decrypt_keystore(keystore_file_path, password)?;
    let wallet = EthereumWallet::from(signer);

    // Create a provider with the wallet.
    let rpc_url = anvil.endpoint().parse()?;
    let provider =
        ProviderBuilder::new().with_recommended_fillers().wallet(wallet).on_http(rpc_url);

    // Build a transaction to send 100 wei from Alice to Vitalik.
    // The `from` field is automatically filled to the first signer's address (Alice).
    let vitalik = address!("d8dA6BF26964aF9D7eEd9e03E53415D37aA96045");
    let tx = TransactionRequest::default().with_to(vitalik).with_value(U256::from(100));

    // Send the transaction and wait for inclusion.
    let tx_hash = provider.send_transaction(tx).await?.watch().await?;

    println!("Sent transaction: {tx_hash}");

    Ok(())
}</code></pre>
<p>åœ¨ Github ä¸ŠæŸ¥æ‰¾æºç  <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/wallets/examples/keystore_signer.rs" title="" target="_blank">here</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><!-- ä¸è¦ç¼–è¾‘æ­¤æ–‡ä»¶ï¼Œè¯¥æ–‡ä»¶æ˜¯é€šè¿‡è¿è¡Œ `./scripts/update.sh` ç”Ÿæˆçš„ -->
<!-- å¯¹æ­¤æ–‡ä»¶æ‰€åšçš„ä»»ä½•æ›´æ”¹éƒ½å°†è¢«è¦†ç›– -->
<!-- è¯·ç¼–è¾‘æˆ–åˆ›å»ºä»¥ä¸‹æ¨¡æ¿: ./src/templates/wallets/create_keystore.md -->
<!-- æœ€æ–°æ›´æ–°: https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="ç¤ºä¾‹-create_keystore"><a class="header" href="#ç¤ºä¾‹-create_keystore">ç¤ºä¾‹: <code>create_keystore</code></a></h2>
<h3 id="ç¤ºä¾‹-86"><a class="header" href="#ç¤ºä¾‹-86">ç¤ºä¾‹</a></h3>
<p>è¦è¿è¡Œæ­¤ç¤ºä¾‹ï¼š</p>
<ul>
<li>å…‹éš† <a href="https://github.com/alloy-rs/examples" title="" target="_blank">examples</a> ä»“åº“: <code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>è¿è¡Œ: <code>cargo run --example create_keystore</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example of creating a keystore file from a private key and password, and then reading it back.

use alloy::{primitives::hex, signers::local::LocalSigner};
use eyre::Result;
use rand::thread_rng;
use std::fs::read_to_string;
use tempfile::tempdir;

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    let dir = tempdir()?;
    let mut rng = thread_rng();

    // Private key of Alice, the first default Anvil account.
    let private_key = hex!("ac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80");

    // Password to encrypt the keystore file with.
    let password = "test";

    // Create a keystore file from the private key of Alice, returning a [Wallet] instance.
    let (wallet, file_path) =
        LocalSigner::encrypt_keystore(&amp;dir, &amp;mut rng, private_key, password, None)?;

    let keystore_file_path = dir.path().join(file_path);

    println!("Wrote keystore for {} to {:?}", wallet.address(), keystore_file_path);

    // Read the keystore file back.
    let recovered_wallet = LocalSigner::decrypt_keystore(keystore_file_path.clone(), password)?;

    println!(
        "Read keystore from {:?}, recovered address: {}",
        keystore_file_path,
        recovered_wallet.address()
    );

    // Assert that the address of the original key and the recovered key are the same.
    assert_eq!(wallet.address(), recovered_wallet.address());

    // Display the contents of the keystore file.
    let keystore_contents = read_to_string(keystore_file_path)?;

    println!("Keystore file contents: {keystore_contents:?}");

    Ok(())
}</code></pre>
<p>åœ¨ Github ä¸Šå¯ä»¥æ‰¾åˆ°æºç  <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/wallets/examples/create_keystore.rs" title="" target="_blank">here</a>ã€‚</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="é«˜çº§"><a class="header" href="#é«˜çº§">é«˜çº§</a></h2>
<ul>
<li><a href="examples/advanced/any_network.html">ä½¿ç”¨ <code>AnyNetwork</code></a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><!-- è¯·å‹¿ç¼–è¾‘æ­¤æ–‡ä»¶ã€‚å®ƒæ˜¯é€šè¿‡è¿è¡Œ `./scripts/update.sh` ç”Ÿæˆçš„ -->
<!-- å¯¹æ­¤æ–‡ä»¶æ‰€åšçš„ä»»ä½•æ›´æ”¹éƒ½å°†è¢«è¦†ç›– -->
<!-- è¯·æ”¹ä¸ºç¼–è¾‘æˆ–åˆ›å»ºè¯¥æ¨¡æ¿ï¼š./src/templates/advanced/any_network.md -->
<!-- æœ€æ–°æ›´æ–°ï¼š https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="ç¤ºä¾‹any_network"><a class="header" href="#ç¤ºä¾‹any_network">ç¤ºä¾‹ï¼š<code>any_network</code></a></h2>
<h3 id="ç¤ºä¾‹-87"><a class="header" href="#ç¤ºä¾‹-87">ç¤ºä¾‹</a></h3>
<p>è¦è¿è¡Œæ­¤ç¤ºä¾‹ï¼š</p>
<ul>
<li>å…‹éš† <a href="https://github.com/alloy-rs/examples" title="" target="_blank">examples</a> ä»“åº“ï¼š<code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>è¿è¡Œï¼š<code>cargo run --example any_network</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example of using `AnyNetwork` to get a type-safe representation of
//! network-specific data.
//!
//! In this example, we extract the `gasUsedForL1` and `l1BlockNumber` fields
//! of Arbitrum's transaction receipts.

use alloy::{
    network::{AnyNetwork, EthereumWallet},
    primitives::{address, Address, U128, U256, U64},
    providers::ProviderBuilder,
    signers::local::PrivateKeySigner,
    sol,
};
use eyre::Result;

// The address of the contract below deployed to Arbitrum Sepolia.
const COUNTER_CONTRACT_ADDRESS: Address = address!("d62FC4aB418580919F22E2aC3A0D93F832A95E70");

sol! {
    #[allow(missing_docs)]
    #[sol(rpc)]
    contract Counter {
        uint256 public number;

        function setNumber(uint256 newNumber) public {
            number = newNumber;
        }

        function increment() public {
            number++;
        }
    }
}

#[derive(Debug, serde::Deserialize)]
struct ArbOtherFields {
    #[serde(rename = "gasUsedForL1")]
    gas_used_for_l1: U128,
    #[serde(rename = "l1BlockNumber")]
    l1_block_number: U64,
}

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    // [RISK WARNING! Writing a private key in the code file is insecure behavior.]
    // The following code is for testing only. Set up signer from private key, be aware of danger.
    let signer: PrivateKeySigner = "&lt;PRIVATE_KEY&gt;".parse().expect("should parse private key");
    let wallet = EthereumWallet::from(signer);

    let rpc_url = "https://sepolia-rollup.arbitrum.io/rpc".parse()?;
    let provider = ProviderBuilder::new()
        .with_recommended_fillers()
        .network::&lt;AnyNetwork&gt;()
        .wallet(wallet)
        .on_http(rpc_url);

    let contract = Counter::new(COUNTER_CONTRACT_ADDRESS, &amp;provider);

    let builder = contract.setNumber(U256::from(42));
    let receipt = builder.send().await?.get_receipt().await?;

    let arb_fields: ArbOtherFields = receipt.other.deserialize_into()?;
    let l1_gas = arb_fields.gas_used_for_l1.to::&lt;u128&gt;();
    let l1_block_number = arb_fields.l1_block_number.to::&lt;u64&gt;();

    println!("Gas used for L1: {}", l1_gas);
    println!("L1 block number: {}", l1_block_number);

    Ok(())
}</code></pre>
<p>åœ¨ Github ä¸Šæ‰¾åˆ°æºç  <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/advanced/examples/any_network.rs" title="" target="_blank">here</a>ã€‚</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contributing-to-alloy"><a class="header" href="#contributing-to-alloy">Contributing to Alloy</a></h1>
<p>ğŸˆ Thanks for your help improving the project! We are so happy to have
you!</p>
<p>There are opportunities to contribute to Alloy at any level. It doesn't
matter if you are just getting started with Rust or are the most weathered
expert, we can use your help.</p>
<p><strong>No contribution is too small and all contributions are valued.</strong></p>
<p>This guide will help you get started. <strong>Do not let this guide intimidate you</strong>.
It should be considered a map to help you navigate the process.</p>
<p>The <a href="https://t.me/ethers_rs">dev channel</a> is available for any concerns not covered in this guide,
please join us!</p>
<h2 id="conduct"><a class="header" href="#conduct">Conduct</a></h2>
<p>The Alloy project adheres to the <a href="https://www.rust-lang.org/policies/code-of-conduct">Rust Code of Conduct</a>. This describes
the <em>minimum</em> behavior expected from all contributors. Instances of violations
of the Code of Conduct can be reported by contacting the project team at
<a href="mailto:james@prestwi.ch">james@prestwich</a>.</p>
<h2 id="contributing-in-issues"><a class="header" href="#contributing-in-issues">Contributing in Issues</a></h2>
<p>For any issue, there are fundamentally three ways an individual can contribute:</p>
<ol>
<li>
<p>By opening the issue for discussion: For instance, if you believe that you
have uncovered a bug in Alloy, creating a new issue in the Alloy
issue tracker is the way to report it.</p>
</li>
<li>
<p>By helping to triage the issue: This can be done by providing
supporting details (a test case that demonstrates a bug), providing
suggestions on how to address the issue, or ensuring that the issue is tagged
correctly.</p>
</li>
<li>
<p>By helping to resolve the issue: Typically this is done either in the form of
demonstrating that the issue reported is not a problem after all, or more
often, by opening a Pull Request that changes some bit of something in
Alloy in a concrete and reviewable manner.</p>
</li>
</ol>
<p><strong>Anybody can participate in any stage of contribution</strong>. We urge you to
participate in the discussion around bugs and participate in reviewing PRs.</p>
<h3 id="asking-for-general-help"><a class="header" href="#asking-for-general-help">Asking for General Help</a></h3>
<p>If you have reviewed existing documentation and still have questions or are
having problems, you can open an issue asking for help.</p>
<p>In exchange for receiving help, we ask that you contribute back a documentation
PR that helps others avoid the problems that you encountered.</p>
<h2 id="pull-requests"><a class="header" href="#pull-requests">Pull Requests</a></h2>
<p>Pull Requests are the way concrete changes are made to the code, documentation,
and dependencies in the Alloy repository.</p>
<p>Even tiny pull requests (e.g., one character pull request fixing a typo in API
documentation) are greatly appreciated. Before making a large change, it is
usually a good idea to first open an issue describing the change to solicit
feedback and guidance. This will increase the likelihood of the PR getting
merged.</p>
<p>When opening a PR <strong>please select the "Allow Edits From Maintainers" option</strong>.
Alloy maintains strict standards for code quality and style, as well as
commit signing. This option allows us to make small changes to your PR to bring
it in line with these standards. It helps us get your PR in faster, and with
less work from you.</p>
<h3 id="commits"><a class="header" href="#commits">Commits</a></h3>
<p>It is a recommended best practice to keep your changes as logically grouped as
possible within individual commits. There is no limit to the number of commits
any single Pull Request may have, and many contributors find it easier to review
changes that are split across multiple commits.</p>
<p>That said, if you have a number of commits that are "checkpoints" and don't
represent a single logical change, please squash those together.</p>
<p>Note that multiple commits often get squashed when they are landed (see the
notes about <a href="appendix/contributing.html#commit-squashing">commit squashing</a>).</p>
<h4 id="commit-message-guidelines"><a class="header" href="#commit-message-guidelines">Commit message guidelines</a></h4>
<p>Commit messages should follow the
<a href="https://www.conventionalcommits.org/en/v1.0.0/">Conventional Commits</a>
specification.</p>
<h3 id="usage"><a class="header" href="#usage">Usage</a></h3>
<p>This section lists some commonly needed commands.</p>
<p>First create a <a href="https://github.com/alloy-rs/book/fork">fork</a>.</p>
<p>Next clone your fork with the <code>--recurse-submodules</code> flag:</p>
<pre><code class="language-sh">git clone --recurse-submodules $FORK_URL
</code></pre>
<p>The book is build with <a href="https://github.com/rust-lang/mdBook"><code>mdbook</code></a>, which you can get by running <code>cargo install mdbook</code>.</p>
<p>The book requires <a href="https://github.com/jonahgoldwastaken/mdbook-external-links"><code>mdbook-external-links</code></a>: <code>cargo install mdbook-external-links</code> and <a href="https://github.com/Michael-F-Bryan/mdbook-linkcheck"><code>mdbook-linkcheck</code></a>: <code>cargo install mdbook-linkcheck</code>.</p>
<p>To see the book change live run:</p>
<pre><code class="language-sh">mdbook serve
</code></pre>
<p>To run the book with docker, run:</p>
<pre><code class="language-sh">docker run -p 3000:3000 -v `pwd`:/book peaceiris/mdbook serve
</code></pre>
<p>To perform an update of generated output inspect and run <code>./scripts/update.sh</code>.</p>
<p>To add a new section (file) to the book, add it to <code>./src/SUMMARY.md</code>.</p>
<h3 id="discuss-and-update"><a class="header" href="#discuss-and-update">Discuss and update</a></h3>
<p>You will probably get feedback or requests for changes to your Pull Request.
This is a big part of the submission process so don't be discouraged! Some
contributors may sign off on the Pull Request right away, others may have
more detailed comments or feedback. This is a necessary part of the process
in order to evaluate whether the changes are correct and necessary.</p>
<p><strong>Any community member can review a PR and you might get conflicting feedback</strong>.
Keep an eye out for comments from code owners to provide guidance on conflicting
feedback.</p>
<p><strong>Once the PR is open, do not rebase the commits</strong>. See
<a href="appendix/contributing.html#commit-squashing">Commit Squashing</a> for more details.</p>
<h3 id="commit-squashing"><a class="header" href="#commit-squashing">Commit Squashing</a></h3>
<p>In most cases, <strong>do not squash commits that you add to your Pull Request during
the review process</strong>. When the commits in your Pull Request land, they may be
squashed into one commit per logical change. Metadata will be added to the
commit message (including links to the Pull Request, links to relevant issues,
and the names of the reviewers). The commit history of your Pull Request,
however, will stay intact on the Pull Request page.</p>
<h2 id="reviewing-pull-requests"><a class="header" href="#reviewing-pull-requests">Reviewing Pull Requests</a></h2>
<p><strong>Any Alloy community member is welcome to review any pull request</strong>.</p>
<p>All Alloy contributors who choose to review and provide feedback on Pull
Requests have a responsibility to both the project and the individual making the
contribution. Reviews and feedback must be helpful, insightful, and geared
towards improving the contribution as opposed to simply blocking it. If there
are reasons why you feel the PR should not land, explain what those are. Do not
expect to be able to block a Pull Request from advancing simply because you say
"No" without giving an explanation. Be open to having your mind changed. Be open
to working with the contributor to make the Pull Request better.</p>
<p>Reviews that are dismissive or disrespectful of the contributor or any other
reviewers are strictly counter to the Code of Conduct.</p>
<p>When reviewing a Pull Request, the primary goals are for the codebase to improve
and for the person submitting the request to succeed. <strong>Even if a Pull Request
does not land, the submitters should come away from the experience feeling like
their effort was not wasted or unappreciated</strong>. Every Pull Request from a new
contributor is an opportunity to grow the community.</p>
<h3 id="review-a-bit-at-a-time"><a class="header" href="#review-a-bit-at-a-time">Review a bit at a time.</a></h3>
<p>Do not overwhelm new contributors.</p>
<p>It is tempting to micro-optimize and make everything about relative performance,
perfect grammar, or exact style matches. Do not succumb to that temptation.</p>
<p>Focus first on the most significant aspects of the change:</p>
<ol>
<li>Does this change make sense for Alloy?</li>
<li>Does this change make Alloy better, even if only incrementally?</li>
<li>Are there clear bugs or larger scale issues that need attending to?</li>
<li>Is the commit message readable and correct? If it contains a breaking change
is it clear enough?</li>
</ol>
<p>Note that only <strong>incremental</strong> improvement is needed to land a PR. This means
that the PR does not need to be perfect, only better than the status quo. Follow
up PRs may be opened to continue iterating.</p>
<p>When changes are necessary, <em>request</em> them, do not <em>demand</em> them, and <strong>do not
assume that the submitter already knows how to add a test or run a benchmark</strong>.</p>
<p>Specific performance optimization techniques, coding styles and conventions
change over time. The first impression you give to a new contributor never does.</p>
<p>Nits (requests for small changes that are not essential) are fine, but try to
avoid stalling the Pull Request. Most nits can typically be fixed by the
Alloy Collaborator landing the Pull Request but they can also be an
opportunity for the contributor to learn a bit more about the project.</p>
<p>It is always good to clearly indicate nits when you comment: e.g.
<code>Nit: change foo() to bar(). But this is not blocking.</code></p>
<p>If your comments were addressed but were not folded automatically after new
commits or if they proved to be mistaken, please, <a href="https://help.github.com/articles/managing-disruptive-comments/#hiding-a-comment">hide them</a>
with the appropriate reason to keep the conversation flow concise and relevant.</p>
<h3 id="be-aware-of-the-person-behind-the-code"><a class="header" href="#be-aware-of-the-person-behind-the-code">Be aware of the person behind the code</a></h3>
<p>Be aware that <em>how</em> you communicate requests and reviews in your feedback can
have a significant impact on the success of the Pull Request. Yes, we may land
a particular change that makes Alloy better, but the individual might just
not want to have anything to do with Alloy ever again. The goal is not just
having good code.</p>
<h3 id="abandoned-or-stalled-pull-requests"><a class="header" href="#abandoned-or-stalled-pull-requests">Abandoned or Stalled Pull Requests</a></h3>
<p>If a Pull Request appears to be abandoned or stalled, it is polite to first
check with the contributor to see if they intend to continue the work before
checking if they would mind if you took it over (especially if it just has nits
left). When doing so, it is courteous to give the original contributor credit
for the work they started (either by preserving their name and email address in
the commit log, or by using an <code>Author: </code> meta-data tag in the commit.</p>
<p><em>Adapted from the <a href="https://github.com/tokio-rs/tokio/blob/master/CONTRIBUTING.md">Tokio contributing guide</a></em>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
