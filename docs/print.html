<!DOCTYPE HTML>
<html lang="en" class="ayu" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Alloy Book</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
                <meta name="twitter:card" content="summary">
                <meta property="og:title" content="Alloy Book" />
                <meta property="og:description" content="A book on all things Alloy" />
                <meta property="og:image" content="https://raw.githubusercontent.com/alloy-rs/book/master/src/images/banner.jpg" />
        <meta name="description" content="A book on all things Alloy">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "ayu";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('ayu')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item affix "><a href="index.html">简介</a></li><li class="chapter-item affix "><li class="part-title">入门指南</li><li class="chapter-item "><a href="getting-started/installation.html"><strong aria-hidden="true">1.</strong> 安装</a></li><li class="chapter-item "><a href="getting-started/first-steps.html"><strong aria-hidden="true">2.</strong> Alloy 的第一步</a></li><li class="chapter-item affix "><li class="part-title">从 ethers-rs 迁移</li><li class="chapter-item "><a href="migrating-from-ethers/reference.html"><strong aria-hidden="true">3.</strong> 参考</a></li><li class="chapter-item affix "><li class="part-title">使用 Alloy 构建</li><li class="chapter-item "><a href="building-with-alloy/basic-building-blocks/index.html"><strong aria-hidden="true">4.</strong> 基础构建模块</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="building-with-alloy/basic-building-blocks/using-big-numbers.html"><strong aria-hidden="true">4.1.</strong> 使用大数</a></li><li class="chapter-item "><a href="building-with-alloy/basic-building-blocks/basic-hash-and-address-types.html"><strong aria-hidden="true">4.2.</strong> 基本哈希和地址类型</a></li><li class="chapter-item "><a href="building-with-alloy/basic-building-blocks/common-conversions.html"><strong aria-hidden="true">4.3.</strong> 常见转换</a></li><li class="chapter-item "><a href="building-with-alloy/basic-building-blocks/creating-instances.html"><strong aria-hidden="true">4.4.</strong> 创建实例</a></li><li class="chapter-item "><a href="building-with-alloy/basic-building-blocks/comparisons-and-equivalence.html"><strong aria-hidden="true">4.5.</strong> 比较与等价</a></li></ol></li><li class="chapter-item "><a href="building-with-alloy/connecting-to-a-blockchain/index.html"><strong aria-hidden="true">5.</strong> 连接到区块链</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="building-with-alloy/connecting-to-a-blockchain/setting-up-a-provider.html"><strong aria-hidden="true">5.1.</strong> 设置提供者</a></li><li class="chapter-item "><a href="building-with-alloy/connecting-to-a-blockchain/http-provider.html"><strong aria-hidden="true">5.2.</strong> 创建 HTTP 提供者</a></li><li class="chapter-item "><a href="building-with-alloy/connecting-to-a-blockchain/ws-provider.html"><strong aria-hidden="true">5.3.</strong> 创建 WS 提供者</a></li><li class="chapter-item "><a href="building-with-alloy/connecting-to-a-blockchain/ipc-provider.html"><strong aria-hidden="true">5.4.</strong> 创建 IPC 提供者</a></li></ol></li><li class="chapter-item "><a href="building-with-alloy/understanding-fillers.html"><strong aria-hidden="true">6.</strong> 理解填充器</a></li><li class="chapter-item "><a href="building-with-alloy/queries.html"><strong aria-hidden="true">7.</strong> 查询</a></li><li class="chapter-item "><a href="building-with-alloy/transactions/index.html"><strong aria-hidden="true">8.</strong> 交易</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="building-with-alloy/transactions/using-the-transaction-builder.html"><strong aria-hidden="true">8.1.</strong> 使用交易构建器</a></li><li class="chapter-item "><a href="building-with-alloy/transactions/sending-an-EIP-1559-transaction.html"><strong aria-hidden="true">8.2.</strong> 发送 EIP-1559 交易</a></li><li class="chapter-item "><a href="building-with-alloy/transactions/sending-a-legacy-transaction.html"><strong aria-hidden="true">8.3.</strong> 发送传统交易</a></li><li class="chapter-item "><a href="building-with-alloy/transactions/sending-an-EIP-4844-transaction.html"><strong aria-hidden="true">8.4.</strong> 发送 EIP-4844 交易</a></li><li class="chapter-item "><a href="building-with-alloy/transactions/using-access-lists.html"><strong aria-hidden="true">8.5.</strong> 使用访问列表</a></li></ol></li><li class="chapter-item "><li class="part-title">亮点</li><li class="chapter-item "><a href="highlights/the-sol!-procedural-macro.html"><strong aria-hidden="true">9.</strong> sol! 过程宏</a></li><li class="chapter-item "><a href="highlights/the-transaction-lifecycle.html"><strong aria-hidden="true">10.</strong> 交易生命周期</a></li><li class="chapter-item affix "><li class="part-title">示例</li><li class="chapter-item "><a href="examples/anvil/index.html"><strong aria-hidden="true">11.</strong> Anvil</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="examples/anvil/deploy_contract_anvil.html"><strong aria-hidden="true">11.1.</strong> 部署合约</a></li><li class="chapter-item "><a href="examples/anvil/fork_anvil.html"><strong aria-hidden="true">11.2.</strong> 分叉</a></li><li class="chapter-item "><a href="examples/anvil/local_anvil.html"><strong aria-hidden="true">11.3.</strong> 本地</a></li></ol></li><li class="chapter-item "><a href="examples/big-numbers/index.html"><strong aria-hidden="true">12.</strong> 大数</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="examples/big-numbers/comparison_equivalence.html"><strong aria-hidden="true">12.1.</strong> 比较与等价</a></li><li class="chapter-item "><a href="examples/big-numbers/conversion.html"><strong aria-hidden="true">12.2.</strong> 转换</a></li><li class="chapter-item "><a href="examples/big-numbers/create_instances.html"><strong aria-hidden="true">12.3.</strong> 创建实例</a></li><li class="chapter-item "><a href="examples/big-numbers/math_operations.html"><strong aria-hidden="true">12.4.</strong> 数学运算</a></li><li class="chapter-item "><a href="examples/big-numbers/math_utilities.html"><strong aria-hidden="true">12.5.</strong> 数学工具</a></li></ol></li><li class="chapter-item "><a href="examples/contracts/index.html"><strong aria-hidden="true">13.</strong> 合约</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="examples/contracts/deploy_from_artifact.html"><strong aria-hidden="true">13.1.</strong> 从工件部署</a></li><li class="chapter-item "><a href="examples/contracts/deploy_from_bytecode.html"><strong aria-hidden="true">13.2.</strong> 从字节码部署</a></li><li class="chapter-item "><a href="examples/contracts/deploy_from_contract.html"><strong aria-hidden="true">13.3.</strong> 从合约部署</a></li><li class="chapter-item "><a href="examples/contracts/interact_with_abi.html"><strong aria-hidden="true">13.4.</strong> 与 ABI 交互</a></li><li class="chapter-item "><a href="examples/contracts/interact_with_contract_instance.html"><strong aria-hidden="true">13.5.</strong> 与合约实例交互</a></li><li class="chapter-item "><a href="examples/contracts/unknown_return_types.html"><strong aria-hidden="true">13.6.</strong> 处理未知返回类型</a></li></ol></li><li class="chapter-item "><a href="examples/fillers/index.html"><strong aria-hidden="true">14.</strong> 填充器</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="examples/fillers/gas_filler.html"><strong aria-hidden="true">14.1.</strong> Gas 估计填充器</a></li><li class="chapter-item "><a href="examples/fillers/nonce_filler.html"><strong aria-hidden="true">14.2.</strong> Nonce 管理填充器</a></li><li class="chapter-item "><a href="examples/fillers/recommended_fillers.html"><strong aria-hidden="true">14.3.</strong> 推荐的填充器</a></li><li class="chapter-item "><a href="examples/fillers/wallet_filler.html"><strong aria-hidden="true">14.4.</strong> 钱包管理填充器</a></li></ol></li><li class="chapter-item "><a href="examples/layers/index.html"><strong aria-hidden="true">15.</strong> 层</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="examples/layers/logging_layer.html"><strong aria-hidden="true">15.1.</strong> 请求/响应日志记录层</a></li></ol></li><li class="chapter-item "><a href="examples/primitives/index.html"><strong aria-hidden="true">16.</strong> 基本类型</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="examples/primitives/bytes_and_address_types.html"><strong aria-hidden="true">16.1.</strong> 字节和地址类型</a></li><li class="chapter-item "><a href="examples/primitives/hashing_functions.html"><strong aria-hidden="true">16.2.</strong> 哈希函数</a></li></ol></li><li class="chapter-item "><a href="examples/providers/index.html"><strong aria-hidden="true">17.</strong> 提供者</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="examples/providers/builder.html"><strong aria-hidden="true">17.1.</strong> 构建者</a></li><li class="chapter-item "><a href="examples/providers/builtin.html"><strong aria-hidden="true">17.2.</strong> 内置提供者</a></li><li class="chapter-item "><a href="examples/providers/http.html"><strong aria-hidden="true">17.3.</strong> HTTP</a></li><li class="chapter-item "><a href="examples/providers/ws.html"><strong aria-hidden="true">17.4.</strong> WS</a></li><li class="chapter-item "><a href="examples/providers/ws_with_auth.html"><strong aria-hidden="true">17.5.</strong> 带身份验证的 WS</a></li><li class="chapter-item "><a href="examples/providers/ipc.html"><strong aria-hidden="true">17.6.</strong> IPC</a></li></ol></li><li class="chapter-item "><a href="examples/queries/index.html"><strong aria-hidden="true">18.</strong> 查询</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="examples/queries/query_contract_storage.html"><strong aria-hidden="true">18.1.</strong> 查询合约存储</a></li><li class="chapter-item "><a href="examples/queries/query_deployed_bytecode.html"><strong aria-hidden="true">18.2.</strong> 查询合约部署的字节码</a></li><li class="chapter-item "><a href="examples/queries/query_logs.html"><strong aria-hidden="true">18.3.</strong> 查询日志</a></li></ol></li><li class="chapter-item "><a href="examples/sol-macro/index.html"><strong aria-hidden="true">19.</strong> sol! 宏</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="examples/sol-macro/contract.html"><strong aria-hidden="true">19.1.</strong> 合约</a></li><li class="chapter-item "><a href="examples/sol-macro/decode_returns.html"><strong aria-hidden="true">19.2.</strong> 解码返回值</a></li><li class="chapter-item "><a href="examples/sol-macro/events_errors.html"><strong aria-hidden="true">19.3.</strong> 事件和错误</a></li><li class="chapter-item "><a href="examples/sol-macro/structs_enums.html"><strong aria-hidden="true">19.4.</strong> 结构体和枚举</a></li><li class="chapter-item "><a href="examples/sol-macro/user_defined_types.html"><strong aria-hidden="true">19.5.</strong> 用户定义的类型</a></li></ol></li><li class="chapter-item "><a href="examples/subscriptions/index.html"><strong aria-hidden="true">20.</strong> 订阅</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="examples/subscriptions/poll_logs.html"><strong aria-hidden="true">20.1.</strong> 监视和轮询合约事件日志</a></li><li class="chapter-item "><a href="examples/subscriptions/subscribe_blocks.html"><strong aria-hidden="true">20.2.</strong> 订阅和监视区块</a></li><li class="chapter-item "><a href="examples/subscriptions/subscribe_logs.html"><strong aria-hidden="true">20.3.</strong> 订阅和监听特定合约事件日志</a></li><li class="chapter-item "><a href="examples/subscriptions/subscribe_all_logs.html"><strong aria-hidden="true">20.4.</strong> 订阅和监听所有合约事件日志</a></li><li class="chapter-item "><a href="examples/subscriptions/subscribe_pending_transactions.html"><strong aria-hidden="true">20.5.</strong> 订阅并监听公共记忆池中的待处理交易</a></li><li class="chapter-item "><a href="examples/subscriptions/event_multiplexer.html"><strong aria-hidden="true">20.6.</strong> 事件多路复用器</a></li></ol></li><li class="chapter-item "><a href="examples/transactions/index.html"><strong aria-hidden="true">21.</strong> 交易</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="examples/transactions/decode_input.html"><strong aria-hidden="true">21.1.</strong> 解码输入</a></li><li class="chapter-item "><a href="examples/transactions/encode_decode_eip1559.html"><strong aria-hidden="true">21.2.</strong> 编码和解码 EIP-1559 交易</a></li><li class="chapter-item "><a href="examples/transactions/gas_price_usd.html"><strong aria-hidden="true">21.3.</strong> 获取以美元计的 Gas 价格</a></li><li class="chapter-item "><a href="examples/transactions/trace_call.html"><strong aria-hidden="true">21.4.</strong> 跟踪调用</a></li><li class="chapter-item "><a href="examples/transactions/trace_transaction.html"><strong aria-hidden="true">21.5.</strong> 跟踪交易</a></li><li class="chapter-item "><a href="examples/transactions/transfer_erc20.html"><strong aria-hidden="true">21.6.</strong> 转账 ERC20 代币</a></li><li class="chapter-item "><a href="examples/transactions/transfer_eth.html"><strong aria-hidden="true">21.7.</strong> 转账 ETH</a></li><li class="chapter-item "><a href="examples/transactions/send_raw_transaction.html"><strong aria-hidden="true">21.8.</strong> 签名并发送原始交易</a></li><li class="chapter-item "><a href="examples/transactions/with_access_list.html"><strong aria-hidden="true">21.9.</strong> 发送带访问列表的交易</a></li><li class="chapter-item "><a href="examples/transactions/send_eip1559_transaction.html"><strong aria-hidden="true">21.10.</strong> 发送 EIP-1559 交易</a></li><li class="chapter-item "><a href="examples/transactions/send_legacy_transaction.html"><strong aria-hidden="true">21.11.</strong> 发送传统交易</a></li><li class="chapter-item "><a href="examples/transactions/send_eip4844_transaction.html"><strong aria-hidden="true">21.12.</strong> 发送 EIP-4844 交易</a></li><li class="chapter-item "><a href="examples/transactions/send_private_transaction.html"><strong aria-hidden="true">21.13.</strong> 使用 Flashbots Protect 发送私密交易</a></li></ol></li><li class="chapter-item "><a href="examples/wallets/index.html"><strong aria-hidden="true">22.</strong> 钱包</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="examples/wallets/aws_signer.html"><strong aria-hidden="true">22.1.</strong> AWS 签名器</a></li><li class="chapter-item "><a href="examples/wallets/ledger_signer.html"><strong aria-hidden="true">22.2.</strong> Ledger 签名器</a></li><li class="chapter-item "><a href="examples/wallets/private_key_signer.html"><strong aria-hidden="true">22.3.</strong> 私钥签名器</a></li><li class="chapter-item "><a href="examples/wallets/mnemonic_signer.html"><strong aria-hidden="true">22.4.</strong> 助记词签名器</a></li><li class="chapter-item "><a href="examples/wallets/sign_message.html"><strong aria-hidden="true">22.5.</strong> 签名消息</a></li><li class="chapter-item "><a href="examples/wallets/verify_message.html"><strong aria-hidden="true">22.6.</strong> 验证消息</a></li><li class="chapter-item "><a href="examples/wallets/sign_permit_hash.html"><strong aria-hidden="true">22.7.</strong> 签名许可哈希</a></li><li class="chapter-item "><a href="examples/wallets/trezor_signer.html"><strong aria-hidden="true">22.8.</strong> Trezor 签名器</a></li><li class="chapter-item "><a href="examples/wallets/yubi_signer.html"><strong aria-hidden="true">22.9.</strong> Yubi 签名器</a></li><li class="chapter-item "><a href="examples/wallets/keystore_signer.html"><strong aria-hidden="true">22.10.</strong> 密钥库签名器</a></li><li class="chapter-item "><a href="examples/wallets/create_keystore.html"><strong aria-hidden="true">22.11.</strong> 创建密钥库</a></li></ol></li><li class="chapter-item "><a href="examples/advanced/index.html"><strong aria-hidden="true">23.</strong> 高级</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="examples/advanced/any_network.html"><strong aria-hidden="true">23.1.</strong> 使用 AnyNetwork</a></li></ol></li><li class="chapter-item "><li class="part-title">附录</li><li class="chapter-item "><a href="appendix/contributing.html"><strong aria-hidden="true">24.</strong> 帮助我们改进 Alloy</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Alloy Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/alloy-rs/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <img src="images/banner.jpg">
<p>Welcome to the hands-on guide for getting started with Alloy!</p>
<p>Alloy connects applications to blockchains.</p>
<p>Alloy is a high performance rewrite of <a href="https://github.com/gakonst/ethers-rs" title="" target="_blank">
<code>ethers-rs</code></a> from the ground up with exciting new
features.</p>
<blockquote>
<p>📖 <strong>Documentation</strong></p>
<p>You can find the official documentation for <code>alloy</code> <a href="https://docs.rs/alloy/latest/alloy/" title="" target="_blank">here</a> and for <code>alloy-core</code> <a href="https://docs.rs/alloy-core/latest/alloy_core/" title="" target="_blank">here</a>.</p>
</blockquote>
<blockquote>
<p>✨ <strong>Contributing</strong></p>
<p>You can contribute to this book on <a href="https://github.com/alloy-rs/book" title="" target="_blank">GitHub</a>.</p>
</blockquote>
<h2 id="sections"><a class="header" href="#sections">Sections</a></h2>
<h3 id="getting-started"><a class="header" href="#getting-started"><a href="./getting-started/installation.html">Getting Started</a></a></h3>
<p>To get started with Alloy, install Alloy and take your first steps.</p>
<h3 id="migrating-from-ethers"><a class="header" href="#migrating-from-ethers"><a href="./migrating-from-ethers/reference.html">Migrating from Ethers</a></a></h3>
<p>A practical guide to migrate from Ethers to Alloy.</p>
<h3 id="building-with-alloy"><a class="header" href="#building-with-alloy"><a href="./building-with-alloy/basic-building-blocks/using-big-numbers.html">Building with Alloy</a></a></h3>
<p>A walkthrough of building with Alloy.</p>
<h3 id="highlights"><a class="header" href="#highlights"><a href="./highlights/the-sol!-procedural-macro.html">Highlights</a></a></h3>
<p>Highlighted features of Alloy.</p>
<h3 id="examples"><a class="header" href="#examples"><a href="./examples/anvil/deploy_contract_anvil.html">Examples</a></a></h3>
<p>This section will give you practical examples of how Alloy can be used in your codebase.</p>
<h3 id="contributing"><a class="header" href="#contributing"><a href="./appendix/contributing.html">Contributing</a></a></h3>
<p>Thanks for your help improving the project! We are so happy to have you! We have
<a href="https://github.com/alloy-rs/book/tree/main/CONTRIBUTING.md" title="" target="_blank">a contributing guide</a> to help you get involved in the
Alloy project.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="安装"><a class="header" href="#安装">安装</a></h2>
<p><a href="https://github.com/alloy-rs/alloy" title="" target="_blank">Alloy</a> 包含多个 crate，这些 crate 提供了与任何基于以太坊的区块链交互所需的各种功能。</p>
<p>最简单的入门方式是使用 Cargo 从命令行添加带有 <code>full</code> 功能标志的 <code>alloy</code> crate：</p>
<pre><code class="language-sh">cargo add alloy --features full
</code></pre>
<p>或者，你可以在你的 <code>Cargo.toml</code> 文件中添加以下内容：</p>
<pre><code class="language-toml">alloy = { version = "0.1", features = ["full"] }
</code></pre>
<p>如果你需要更细粒度的控制所包含的功能，可以在 <code>Cargo.toml</code> 文件中添加各个独立的 crate，或者使用带有所需功能的 <code>alloy</code> crate。</p>
<p>在 <code>alloy</code> 被添加为依赖项后，你可以按如下方式导入 <code>alloy</code>：</p>
<pre><code class="language-rust ignore">use alloy::{
    network::{eip2718::Encodable2718, EthereumWallet, TransactionBuilder},
    primitives::U256,
    providers::{Provider, ProviderBuilder},
    rpc::types::TransactionRequest,
    signers::local::PrivateKeySigner,
};</code></pre>
<h3 id="功能"><a class="header" href="#功能">功能</a></h3>
<a href="https://github.com/alloy-rs/alloy/tree/main/crates/alloy" title="" target="_blank">
`alloy`</a> meta-crate 定义了许多 <a href="https://github.com/alloy-rs/alloy/blob/main/crates/alloy/Cargo.toml" title="" target="_blank">功能标志</a>：
<p>默认</p>
<ul>
<li><code>std</code></li>
<li><code>reqwest</code></li>
</ul>
<p>全功能，包含最常用的标志，适合入门使用 <code>alloy</code>。</p>
<ul>
<li><code>full</code></li>
</ul>
<p>通用功能</p>
<ul>
<li><code>consensus</code></li>
<li><code>contract</code></li>
<li><code>eips</code></li>
<li><code>genesis</code></li>
<li><code>network</code></li>
<li><code>node-bindings</code></li>
</ul>
<p>提供者</p>
<ul>
<li><code>providers</code></li>
<li><code>provider-http</code></li>
<li><code>provider-ipc</code></li>
<li><code>provider-ws</code></li>
</ul>
<p>RPC</p>
<ul>
<li><code>rpc</code></li>
<li><code>json-rpc</code></li>
<li><code>rpc-client</code></li>
<li><code>rpc-client-ipc</code></li>
<li><code>rpc-client-ws</code></li>
<li><code>rpc-types</code></li>
<li><code>rpc-types-admin</code></li>
<li><code>rpc-types-anvil</code></li>
<li><code>rpc-types-beacon</code></li>
<li><code>rpc-types-debug</code></li>
<li><code>rpc-types-engine</code></li>
<li><code>rpc-types-eth</code></li>
<li><code>rpc-types-json</code></li>
<li><code>rpc-types-trace</code></li>
<li><code>rpc-types-txpool</code></li>
</ul>
<p>签名者</p>
<ul>
<li><code>signers</code></li>
<li><code>signer-aws</code></li>
<li><code>signer-gcp</code></li>
<li><code>signer-ledger</code></li>
<li><code>signer-ledger-browser</code></li>
<li><code>signer-ledger-node</code></li>
<li><code>signer-local</code></li>
<li><code>signer-trezor</code></li>
<li><code>signer-keystore</code></li>
<li><code>signer-mnemonic</code></li>
<li><code>signer-mnemonic-all-languages</code></li>
<li><code>signer-yubihsm</code></li>
</ul>
<p>默认情况下，<code>alloy</code> 使用 <a href="https://crates.io/crates/reqwest" title="" target="_blank">
<code>reqwest</code></a> 作为 HTTP 客户端。你也可以选择切换到 <a href="https://crates.io/crates/hyper" title="" target="_blank">
<code>hyper</code></a>。
<code>reqwest</code> 和 <code>hyper</code> 功能标志是互斥的。</p>
<p>完整的可用功能列表可以在 <a href="https://docs.rs/crate/alloy/latest/features" title="" target="_blank">docs.rs</a> 或者 <a href="https://github.com/alloy-rs/alloy/blob/main/crates/alloy/Cargo.toml" title="" target="_blank">
<code>alloy</code> crate 的 <code>Cargo.toml</code></a> 中找到。</p>
<p>这些功能标志大部分与以下独立 crate 的功能相对应，并启用这些功能。</p>
<h3 id="crate"><a class="header" href="#crate">Crate</a></h3>
<p><code>alloy</code> 包含以下 crate：</p>
<ul>
<li><a href="https://github.com/alloy-rs/alloy/tree/main/crates/alloy" title="" target="_blank">alloy</a> - 整个项目的 meta-crate，包括 <a href="https://docs.rs/alloy-core" title="" target="_blank">
<code>alloy-core</code></a></li>
<li><a href="https://github.com/alloy-rs/alloy/tree/main/crates/consensus" title="" target="_blank">alloy-consensus</a> - 以太坊共识接口</li>
<li><a href="https://github.com/alloy-rs/alloy/tree/main/crates/contract" title="" target="_blank">alloy-contract</a> - 与链上合约交互</li>
<li><a href="https://github.com/alloy-rs/alloy/tree/main/crates/eips" title="" target="_blank">alloy-eips</a> - 以太坊改进提案 (EIP) 实现</li>
<li><a href="https://github.com/alloy-rs/alloy/tree/main/crates/genesis" title="" target="_blank">alloy-genesis</a> - 以太坊创世文件定义</li>
<li><a href="https://github.com/alloy-rs/alloy/tree/main/crates/json-rpc" title="" target="_blank">alloy-json-rpc</a> - JSON-RPC 2.0 客户端的核心数据类型</li>
<li><a href="https://github.com/alloy-rs/alloy/tree/main/crates/network" title="" target="_blank">alloy-network</a> - RPC 类型的网络抽象</li>
<li><a href="https://github.com/alloy-rs/alloy/tree/main/crates/node-bindings" title="" target="_blank">alloy-node-bindings</a> - 以太坊执行层客户端绑定</li>
<li><a href="https://github.com/alloy-rs/alloy/tree/main/crates/provider" title="" target="_blank">alloy-provider</a> - 与以太坊区块链接口</li>
<li><a href="https://github.com/alloy-rs/alloy/tree/main/crates/pubsub" title="" target="_blank">alloy-pubsub</a> - 以太坊 JSON-RPC <a href="https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern" title="" target="_blank">发布-订阅</a> tower 服务和类型定义</li>
<li><a href="https://github.com/alloy-rs/alloy/tree/main/crates/rpc-client" title="" target="_blank">alloy-rpc-client</a> - 低级以太坊 JSON-RPC 客户端实现</li>
<li><a href="https://github.com/alloy-rs/alloy/tree/main/crates/rpc-types" title="" target="_blank">alloy-rpc-types</a> - 所有以太坊 JSON-RPC 类型的 meta-crate
<ul>
<li><a href="https://github.com/alloy-rs/alloy/tree/main/crates/rpc-types-admin" title="" target="_blank">alloy-rpc-types-admin</a> - <code>admin</code> 以太坊 JSON-RPC 命名空间的类型</li>
<li><a href="https://github.com/alloy-rs/alloy/tree/main/crates/rpc-types-anvil" title="" target="_blank">alloy-rpc-types-anvil</a> - <a href="https://github.com/foundry-rs/foundry" title="" target="_blank">Anvil</a> 开发节点的以太坊 JSON-RPC 命名空间的类型</li>
<li><a href="https://github.com/alloy-rs/alloy/tree/main/crates/rpc-types-beacon" title="" target="_blank">alloy-rpc-types-beacon</a> - <a href="https://ethereum.github.io/beacon-APIs" title="" target="_blank">以太坊信标节点 API</a> 类型</li>
<li><a href="https://github.com/alloy-rs/alloy/tree/main/crates/rpc-types-engine" title="" target="_blank">alloy-rpc-types-engine</a> - <code>engine</code> 以太坊 JSON-RPC 命名空间的类型</li>
<li><a href="https://github.com/alloy-rs/alloy/tree/main/crates/rpc-types-eth" title="" target="_blank">alloy-rpc-types-eth</a> - <code>eth</code> 以太坊 JSON-RPC 命名空间的类型</li>
<li><a href="https://github.com/alloy-rs/alloy/tree/main/crates/rpc-types-trace" title="" target="_blank">alloy-rpc-types-trace</a> - <code>trace</code> 以太坊 JSON-RPC 命名空间的类型</li>
<li><a href="https://github.com/alloy-rs/alloy/tree/main/crates/rpc-types-txpool" title="" target="_blank">alloy-rpc-types-txpool</a> - <code>txpool</code> 以太坊 JSON-RPC 命名空间的类型</li>
</ul>
</li>
<li><a href="https://github.com/alloy-rs/alloy/tree/main/crates/serde" title="" target="_blank">alloy-serde</a> - <a href="https://serde.rs" title="" target="_blank">Serde</a> 相关实用工具</li>
<li><a href="https://github.com/alloy-rs/alloy/tree/main/crates/signer" title="" target="_blank">alloy-signer</a> - 以太坊签名者抽象
<ul>
<li><a href="https://github.com/alloy-rs/alloy/tree/main/crates/signer-aws" title="" target="_blank">alloy-signer-aws</a> - <a href="https://aws.amazon.com/kms" title="" target="_blank">AWS KMS</a> 签名实现</li>
<li><a href="https://github.com/alloy-rs/alloy/tree/main/crates/signer-gcp" title="" target="_blank">alloy-signer-gcp</a> - <a href="https://cloud.google.com/kms" title="" target="_blank">GCP KMS</a> 签名实现</li>
<li><a href="https://github.com/alloy-rs/alloy/tree/main/crates/signer-ledger" title="" target="_blank">alloy-signer-ledger</a> - <a href="https://www.ledger.com" title="" target="_blank">Ledger</a> 签名实现</li>
<li><a href="https://github.com/alloy-rs/alloy/tree/main/crates/signer-local" title="" target="_blank">alloy-signer-local</a> - 本地（私钥，密钥库，助记词，YubiHSM）签名实现</li>
<li><a href="https://github.com/alloy-rs/alloy/tree/main/crates/signer-trezor" title="" target="_blank">alloy-signer-trezor</a> - <a href="https://trezor.io" title="" target="_blank">Trezor</a> 签名实现</li>
</ul>
</li>
<li><a href="https://github.com/alloy-rs/alloy/tree/main/crates/transport" title="" target="_blank">alloy-transport</a> - 低级以太坊 JSON-RPC 传输抽象
<ul>
<li><a href="https://github.com/alloy-rs/alloy/tree/main/crates/transport-http" title="" target="_blank">alloy-transport-http</a> - HTTP 传输实现</li>
<li><a href="https://github.com/alloy-rs/alloy/tree/main/crates/transport-ipc" title="" target="_blank">alloy-transport-ipc</a> - IPC 传输实现</li>
<li><a href="https://github.com/alloy-rs/alloy/tree/main/crates/transport-ws" title="" target="_blank">alloy-transport-ws</a> - WS 传输实现</li>
</ul>
</li>
</ul>
<p><code>alloy-core</code> 包含以下 crate：</p>
<ul>
<li><a href="https://github.com/alloy-rs/core/tree/main/crates/core" title="" target="_blank">alloy-core</a> - 整个项目的 meta-crate</li>
<li><a href="https://github.com/alloy-rs/core/tree/main/crates/dyn-abi" title="" target="_blank">alloy-dyn-abi</a> - 运行时 <a href="https://docs.soliditylang.org/en/latest/abi-spec.html" title="" target="_blank">ABI</a> 和 <a href="https://eips.ethereum.org/EIPS/eip-712" title="" target="_blank">EIP-712</a> 实现</li>
<li><a href="https://github.com/alloy-rs/core/tree/main/crates/json-abi" title="" target="_blank">alloy-json-abi</a> - 全面的以太坊 <a href="https://docs.soliditylang.org/en/latest/abi-spec.html#json" title="" target="_blank">JSON-ABI</a> 实现</li>
<li><a href="https://github.com/alloy-rs/core/tree/main/crates/primitives" title="" target="_blank">alloy-primitives</a> - 基本的整数和字节类型</li>
<li><a href="https://github.com/alloy-rs/core/tree/main/crates/sol-macro-expander" title="" target="_blank">alloy-sol-macro-expander</a> - 用于 Solidity 到 Rust 过程宏的扩展器</li>
<li><a href="https://github.com/alloy-rs/core/tree/main/crates/sol-macro-input" title="" target="_blank">alloy-sol-macro-input</a> - <a href="https://docs.rs/alloy-sol-macro/latest/alloy_sol_macro/macro.sol.html" title="" target="_blank">
<code>sol!</code></a> 宏类型的输入类型</li>
<li><a href="https://github.com/alloy-rs/core/tree/main/crates/sol-macro" title="" target="_blank">alloy-sol-macro</a> - <a href="https://docs.rs/alloy-sol-macro/latest/alloy_sol_macro/macro.sol.html" title="" target="_blank">
<code>sol!</code></a> 过程宏</li>
<li><a href="https://github.com/alloy-rs/core/tree/main/crates/sol-type-parser" title="" target="_blank">alloy-sol-type-parser</a> - Solidity 类型字符串的简单解析器</li>
<li><a href="https://github.com/alloy-rs/core/tree/main/crates/sol-types" title="" target="_blank">alloy-sol-types</a> - 编译时 <a href="https://docs.soliditylang.org/en/latest/abi-spec.html" title="" target="_blank">ABI</a> 和 <a href="https://eips.ethereum.org/EIPS/eip-712" title="" target="_blank">EIP-712</a> 实现</li>
<li><a href="https://github.com/alloy-rs/core/tree/main/crates/syn-solidity" title="" target="_blank">syn-solidity</a> - <a href="https://github.com/dtolnay/syn" title="" target="_blank">
<code>syn</code></a>-驱动的 Solidity 解析器</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="起步"><a class="header" href="#起步">起步</a></h2>
<p>Alloy 允许应用程序通过使用提供者（providers）来连接区块链。提供者充当应用程序和以太坊节点之间的接口，使您能够通过 JSON-RPC 消息发送请求和接收响应。</p>
<p>使用提供者可以执行的一些常见操作包括：</p>
<ul>
<li>获取当前区块号</li>
<li>获取以太坊地址的余额</li>
<li>向区块链发送交易</li>
<li>调用智能合约函数</li>
<li>订阅日志和智能合约事件</li>
<li>获取地址的交易历史记录</li>
</ul>
<p>在<a href="getting-started/./installation.html">安装</a>了 <code>alloy</code> 之后，让我们创建一个使用 HTTP 提供者并获取最新区块号的示例。</p>
<p>安装 <a href="https://crates.io/crates/tokio" title="" target="_blank">
<code>tokio</code></a> 和 <a href="https://crates.io/crates/eyre" title="" target="_blank">
<code>eyre</code></a> 作为依赖项，并按如下定义主体：</p>
<pre><code class="language-rust ignore">//! 使用 `ProviderBuilder` 的 `on_http` 方法创建 HTTP 提供者的示例。

use alloy::providers::{Provider, ProviderBuilder};
use eyre::Result;

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    // ...

    Ok(())
}</code></pre>
<p>接下来，向主体中添加以下部分，以使用 HTTP 传输创建提供者：</p>
<pre><code class="language-rust ignore">// 设置由 RPC 客户端使用的 HTTP 传输。
let rpc_url = "https://eth.merkle.io".parse()?;

// 使用 `reqwest` crate 创建带有 HTTP 传输的提供者。
let provider = ProviderBuilder::new().on_http(rpc_url);</code></pre>
<p>最后，我们使用提供者获取最新的区块号：</p>
<pre><code class="language-rust ignore">// 获取最新区块号。
let latest_block = provider.get_block_number().await?;

// 打印区块号。
println!("Latest block number: {latest_block}");</code></pre>
<p>可以在<a href="https://github.com/alloy-rs/examples/blob/main/examples/providers/examples/http.rs" title="" target="_blank">这里</a>找到完整且可运行的示例，这是<a href="https://github.com/alloy-rs/examples/blob/main/README.md#overview" title="" target="_blank">许多 Alloy 可运行示例</a>中的一个，供您探索。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="参考"><a class="header" href="#参考">参考</a></h2>
<p><a href="https://github.com/gakonst/ethers-rs/" title="" target="_blank">ethers-rs</a> 已经被弃用，迁移至 <a href="https://github.com/alloy-rs/" title="" target="_blank">Alloy</a> 和 <a href="https://github.com/foundry-rs/" title="" target="_blank">Foundry</a>。</p>
<p>以下是找到特定 crate、依赖或信息源的迁移路径的参考指南。</p>
<h3 id="文档"><a class="header" href="#文档">文档</a></h3>
<ul>
<li>书籍: <a href="https://github.com/gakonst/ethers-rs/tree/master/book" title="" target="_blank">
<code>ethers-rs/book</code></a> <code>-&gt;</code> <a href="https://github.com/alloy-rs/book" title="" target="_blank">
<code>alloy-rs/book</code></a></li>
</ul>
<h3 id="示例"><a class="header" href="#示例">示例</a></h3>
<ul>
<li>示例: <a href="https://github.com/gakonst/ethers-rs/tree/master/examples" title="" target="_blank">
<code>ethers-rs/examples</code></a> <code>-&gt;</code> <a href="https://github.com/alloy-rs/examples" title="" target="_blank">
<code>alloy-rs/examples</code></a></li>
</ul>
<h3 id="crates"><a class="header" href="#crates">Crates</a></h3>
<ul>
<li>
<p>Meta-crate: <a href="https://github.com/gakonst/ethers-rs/tree/master/ethers" title="" target="_blank">
<code>ethers</code></a> <code>-&gt;</code> <a href="https://github.com/alloy-rs/alloy/tree/main/crates/alloy" title="" target="_blank">
<code>alloy</code></a></p>
</li>
<li>
<p>地址簿: <a href="https://github.com/gakonst/ethers-rs/tree/master/ethers-addressbook" title="" target="_blank">
<code>ethers::addressbook</code></a> <code>-&gt;</code> 无计划</p>
</li>
<li>
<p>编译器: <a href="https://github.com/gakonst/ethers-rs/tree/master/ethers-solc" title="" target="_blank">
<code>ethers::solc</code></a> <code>-&gt;</code> <a href="https://github.com/foundry-rs/compilers" title="" target="_blank">
<code>foundry-compilers</code></a></p>
</li>
<li>
<p>合约: <a href="https://github.com/gakonst/ethers-rs/tree/master/ethers-contract" title="" target="_blank">
<code>ethers::contract</code></a> <code>-&gt;</code> <a href="https://github.com/alloy-rs/alloy/tree/main/crates/contract" title="" target="_blank">
<code>alloy::contract</code></a></p>
</li>
<li>
<p>核心: <a href="https://github.com/gakonst/ethers-rs/tree/master/ethers-core" title="" target="_blank">
<code>ethers::core</code></a> <code>-&gt;</code> <a href="https://github.com/alloy-rs/core" title="" target="_blank">
<code>alloy::core</code></a></p>
<ul>
<li>类型: <a href="https://github.com/gakonst/ethers-rs/tree/master/ethers-core/src/types" title="" target="_blank">
<code>ethers::core::types::*</code></a> <code>-&gt;</code> 见 <a href="migrating-from-ethers/reference.html#types">Types</a> 部分</li>
</ul>
</li>
<li>
<p>Etherscan: <a href="https://github.com/gakonst/ethers-rs/tree/master/ethers-etherscan" title="" target="_blank">
<code>ethers::etherscan</code></a> <code>-&gt;</code> <a href="https://github.com/foundry-rs/block-explorers" title="" target="_blank">
<code>foundry-block-explorers</code></a></p>
</li>
<li>
<p>中间件: <a href="https://github.com/gakonst/ethers-rs/tree/master/ethers-middleware" title="" target="_blank">
<code>ethers::middleware</code></a> <code>-&gt;</code> 填充器 <a href="https://github.com/alloy-rs/alloy/tree/main/crates/provider/src" title="" target="_blank">
<code>alloy::provider::{fillers, layers}</code></a></p>
<ul>
<li>Gas 预言机: <a href="https://github.com/gakonst/ethers-rs/tree/master/ethers-middleware/src/gas_oracle/middleware.rs" title="" target="_blank">
<code>ethers::middleware::GasOracleMiddleware</code></a> <code>-&gt;</code> Gas 填充器 <a href="https://github.com/alloy-rs/examples/tree/main/examples/fillers/examples/gas_filler.rs" title="" target="_blank">
<code>alloy::provider::GasFiller</code></a></li>
<li>Gas 加速器: <a href="https://github.com/gakonst/ethers-rs/tree/master/ethers-middleware/src/gas_escalator" title="" target="_blank">
<code>ethers::middleware::GasEscalatorMiddleware</code></a> <code>-&gt;</code> 无计划</li>
<li>变换器: <a href="https://github.com/gakonst/ethers-rs/tree/master/ethers-middleware/src/transformer" title="" target="_blank">
<code>ethers::middleware::TransformerMiddleware</code></a> <code>-&gt;</code> 无计划</li>
<li>策略: <a href="https://github.com/gakonst/ethers-rs/blob/master/ethers-middleware/src/policy.rs" title="" target="_blank">
<code>ethers::middleware::policy::*</code></a> <code>-&gt;</code> 无计划</li>
<li>Timelag: <a href="https://github.com/gakonst/ethers-rs/tree/master/ethers-middleware/src/timelag" title="" target="_blank">
<code>ethers::middleware::timelag::*</code></a> <code>-&gt;</code> 无计划</li>
<li>Nonce 管理器: <a href="https://github.com/gakonst/ethers-rs/tree/master/ethers-middleware/src/nonce_manager.rs" title="" target="_blank">
<code>ethers::middleware::NonceManagerMiddleware</code></a> <code>-&gt;</code> Nonce 填充器<a href="https://github.com/alloy-rs/alloy/tree/main/crates/provider/src/fillers/nonce.rs" title="" target="_blank">
<code>alloy::provider::NonceFiller</code></a></li>
<li>签名: <a href="https://github.com/gakonst/ethers-rs/tree/master/ethers-middleware/src/signer.rs" title="" target="_blank">
<code>ethers::middleware::Signer</code></a> <code>-&gt;</code> 钱包填充器 <a href="https://github.com/alloy-rs/alloy/tree/main/crates/provider/src/fillers/wallet.rs" title="" target="_blank">
<code>alloy::provider::WalletFiller</code></a></li>
</ul>
</li>
<li>
<p>提供者: <a href="https://github.com/gakonst/ethers-rs/tree/master/ethers-providers" title="" target="_blank">
<code>ethers::providers</code></a> <code>-&gt;</code> 提供者 <a href="https://github.com/alloy-rs/alloy/tree/main/crates/provider" title="" target="_blank">
<code>alloy::providers</code></a></p>
</li>
<li>
<p>传输: <a href="https://github.com/gakonst/ethers-rs/tree/master/ethers-providers/src/rpc/transports" title="" target="_blank">
<code>ethers::providers::transports</code></a> <code>-&gt;</code> <a href="https://github.com/alloy-rs/alloy/tree/main/crates/transport" title="" target="_blank">
<code>alloy::transports</code></a></p>
<ul>
<li>HTTP: <a href="https://github.com/gakonst/ethers-rs/tree/master/ethers-providers/src/rpc/transports/http.rs" title="" target="_blank">
<code>ethers::providers::Http</code></a> <code>-&gt;</code> <a href="https://github.com/alloy-rs/alloy/tree/main/crates/transport-http" title="" target="_blank">
<code>alloy::transports::http</code></a></li>
<li>IPC: <a href="https://github.com/gakonst/ethers-rs/tree/master/ethers-providers/src/rpc/transports/ipc.rs" title="" target="_blank">
<code>ethers::providers::Ipc</code></a> <code>-&gt;</code> <a href="https://github.com/alloy-rs/alloy/tree/main/crates/transport-ipc" title="" target="_blank">
<code>alloy::transports::ipc</code></a></li>
<li>WS: <a href="https://github.com/gakonst/ethers-rs/tree/master/ethers-providers/src/rpc/transports/ws" title="" target="_blank">
<code>ethers::providers::Ws</code></a> <code>-&gt;</code> <a href="https://github.com/alloy-rs/alloy/tree/main/crates/transport-ws" title="" target="_blank">
<code>alloy::transports::ws</code></a></li>
</ul>
</li>
<li>
<p>签名者: <a href="https://github.com/gakonst/ethers-rs/tree/master/ethers-signers" title="" target="_blank">
<code>ethers::signers</code></a> <code>-&gt;</code> 签名者 <a href="https://github.com/alloy-rs/alloy/tree/main/crates/signer" title="" target="_blank">
<code>alloy::signers</code></a></p>
<ul>
<li>AWS: <a href="https://github.com/gakonst/ethers-rs/tree/master/ethers-signers/src/aws" title="" target="_blank">
<code>ethers::signers::aws::*</code></a> <code>-&gt;</code> <a href="https://github.com/alloy-rs/alloy/tree/main/crates/signer-aws" title="" target="_blank">
<code>alloy::signers::aws</code></a></li>
<li>Ledger: <a href="https://github.com/gakonst/ethers-rs/tree/master/ethers-signers/src/ledger" title="" target="_blank">
<code>ethers::signers::ledger::*</code></a> <code>-&gt;</code> <a href="https://github.com/alloy-rs/alloy/tree/main/crates/signer-ledger" title="" target="_blank">
<code>alloy::signers::ledger</code></a></li>
<li>Trezor: <a href="https://github.com/gakonst/ethers-rs/tree/master/ethers-signers/src/trezor" title="" target="_blank">
<code>ethers::signers::trezor::*</code></a> <code>-&gt;</code> <a href="https://github.com/alloy-rs/alloy/tree/main/crates/signer-trezor" title="" target="_blank">
<code>alloy::signer::trezor</code></a></li>
<li>钱包: <a href="https://github.com/gakonst/ethers-rs/tree/master/ethers-signers/src/wallet" title="" target="_blank">
<code>ethers::signers::wallet::*</code></a> <code>-&gt;</code> <a href="https://github.com/alloy-rs/alloy/tree/main/crates/signer-local" title="" target="_blank">
<code>alloy::signer::local</code></a></li>
</ul>
</li>
</ul>
<h3 id="类型"><a class="header" href="#类型">类型</a></h3>
<h4 id="原始类型"><a class="header" href="#原始类型">原始类型</a></h4>
<ul>
<li>地址: <a href="https://github.com/gakonst/ethers-rs/tree/master/ethers-core/src/types/mod.rs" title="" target="_blank">
<code>ethers::types::Address</code></a> <code>-&gt;</code> <a href="https://github.com/alloy-rs/core/tree/main/crates/primitives/src/lib.rs" title="" target="_blank">
<code>alloy::primitives::Address</code></a></li>
<li>U64: <a href="https://github.com/gakonst/ethers-rs/tree/master/ethers-core/src/types/mod.rs" title="" target="_blank">
<code>ethers::types::U64</code></a> <code>-&gt;</code> <a href="https://github.com/alloy-rs/core/tree/main/crates/primitives/src/lib.rs" title="" target="_blank">
<code>alloy::primitives::U64</code></a></li>
<li>U128: <a href="https://github.com/gakonst/ethers-rs/tree/master/ethers-core/src/types/mod.rs" title="" target="_blank">
<code>ethers::types::U128</code></a> <code>-&gt;</code> <a href="https://github.com/alloy-rs/core/tree/main/crates/primitives/src/lib.rs" title="" target="_blank">
<code>alloy::primitives::U128</code></a></li>
<li>U256: <a href="https://github.com/gakonst/ethers-rs/tree/master/ethers-core/src/types/mod.rs" title="" target="_blank">
<code>ethers::types::U256</code></a> <code>-&gt;</code> <a href="https://github.com/alloy-rs/core/tree/main/crates/primitives/src/lib.rs" title="" target="_blank">
<code>alloy::primitives::U256</code></a></li>
<li>U512: <a href="https://github.com/gakonst/ethers-rs/tree/master/ethers-core/src/types/mod.rs" title="" target="_blank">
<code>ethers::types::U512</code></a> <code>-&gt;</code> <a href="https://github.com/alloy-rs/core/tree/main/crates/primitives/src/lib.rs" title="" target="_blank">
<code>alloy::primitives::U512</code></a></li>
<li>H32: <a href="https://github.com/gakonst/ethers-rs/tree/master/ethers-core/src/types/mod.rs" title="" target="_blank">
<code>ethers::types::H32</code></a> <code>-&gt;</code> <a href="https://github.com/alloy-rs/core/tree/main/crates/primitives/src/lib.rs" title="" target="_blank">
<code>alloy::primitives::aliases::B32</code></a></li>
<li>H64: <a href="https://github.com/gakonst/ethers-rs/tree/master/ethers-core/src/types/mod.rs" title="" target="_blank">
<code>ethers::types::H64</code></a> <code>-&gt;</code> <a href="https://github.com/alloy-rs/core/tree/main/crates/primitives/src/lib.rs" title="" target="_blank">
<code>alloy::primitives::B64</code></a></li>
<li>H128: <a href="https://github.com/gakonst/ethers-rs/tree/master/ethers-core/src/types/mod.rs" title="" target="_blank">
<code>ethers::types::H128</code></a> <code>-&gt;</code> <a href="https://github.com/alloy-rs/core/tree/main/crates/primitives/src/lib.rs" title="" target="_blank">
<code>alloy::primitives::B128</code></a></li>
<li>H160: <a href="https://github.com/gakonst/ethers-rs/tree/master/ethers-core/src/types/mod.rs" title="" target="_blank">
<code>ethers::types::H160</code></a> <code>-&gt;</code> <a href="https://github.com/alloy-rs/core/tree/main/crates/primitives/src/lib.rs" title="" target="_blank">
<code>alloy::primitives::B160</code></a></li>
<li>H256: <a href="https://github.com/gakonst/ethers-rs/tree/master/ethers-core/src/types/mod.rs" title="" target="_blank">
<code>ethers::types::H256</code></a> <code>-&gt;</code> <a href="https://github.com/alloy-rs/core/tree/main/crates/primitives/src/lib.rs" title="" target="_blank">
<code>alloy::primitives::B256</code></a></li>
<li>H512: <a href="https://github.com/gakonst/ethers-rs/tree/master/ethers-core/src/types/mod.rs" title="" target="_blank">
<code>ethers::types::H512</code></a> <code>-&gt;</code> <a href="https://github.com/alloy-rs/core/tree/main/crates/primitives/src/lib.rs" title="" target="_blank">
<code>alloy::primitives::B512</code></a></li>
<li>Bloom: <a href="https://github.com/gakonst/ethers-rs/tree/master/ethers-core/src/types/mod.rs" title="" target="_blank">
<code>ethers::types::Bloom</code></a> <code>-&gt;</code> <a href="https://github.com/alloy-rs/core/tree/main/crates/primitives/src/lib.rs" title="" target="_blank">
<code>alloy::primitives::Bloom</code></a></li>
<li>TxHash: <a href="https://github.com/gakonst/ethers-rs/tree/master/ethers-core/src/types/mod.rs" title="" target="_blank">
<code>ethers::types::TxHash</code></a> <code>-&gt;</code> <a href="https://github.com/alloy-rs/core/tree/main/crates/primitives/src/lib.rs" title="" target="_blank">
<code>alloy::primitives::TxHash</code></a></li>
</ul>
<p>由于 <code>ruint</code> 的一个<a href="https://github.com/alloy-rs/core/issues/554#issuecomment-1978620017" title="" target="_blank">限制</a>，BigEndianHash <a href="https://github.com/gakonst/ethers-rs/tree/master/ethers-core/src/types/mod.rs" title="" target="_blank">
<code>ethers::types::BigEndianHash</code></a> 可以如下表示：</p>
<pre><code class="language-rust ignore">// `U256` =&gt; `B256`
let x = B256::from(u256);

// `B256` =&gt; `U256`
let x: U256 = b256.into();
let x = U256::from_be_bytes(b256.into())</code></pre>
<h4 id="rpc"><a class="header" href="#rpc">RPC</a></h4>
<ul>
<li>字节: <a href="https://github.com/gakonst/ethers-rs/tree/master/ethers-core/src/types/bytes.rs" title="" target="_blank">
<code>ethers::types::bytes::*</code></a> <code>-&gt;</code> <a href="https://github.com/alloy-rs/core/tree/main/crates/primitives/src/lib.rs" title="" target="_blank">
<code>alloy::primitives::Bytes</code></a></li>
<li>链: <a href="https://github.com/gakonst/ethers-rs/tree/master/ethers-core/src/types/chain.rs" title="" target="_blank">
<code>ethers::types::Chain</code></a> <code>-&gt;</code> <a href="https://github.com/alloy-rs/chains" title="" target="_blank">
<code>alloy-rs/chains</code></a></li>
<li>ENS: <a href="https://github.com/gakonst/ethers-rs/tree/master/ethers-core/src/types/ens.rs" title="" target="_blank">
<code>ethers::types::ens</code></a> <code>-&gt;</code> <a href="https://github.com/foundry-rs/foundry/tree/master/crates/common/src/ens.rs" title="" target="_blank">
<code>foundry-common</code></a></li>
<li>Trace: <a href="https://github.com/gakonst/ethers-rs/tree/master/ethers-core/src/types/trace" title="" target="_blank">
<code>ethers::types::trace::*</code></a> <code>-&gt;</code> <a href="https://github.com/alloy-rs/alloy/tree/main/crates/rpc-types-trace" title="" target="_blank">
<code>alloy::rpc::types::trace</code></a></li>
<li>{Block, Fee, Filter, Log, Syncing, Transaction, TxPool}: <a href="https://github.com/gakonst/ethers-rs/tree/master/ethers-core/src/types" title="" target="_blank">
<code>ethers::types::*</code></a> <code>-&gt;</code> <a href="https://github.com/alloy-rs/alloy/tree/main/crates/rpc-types/src/eth" title="" target="_blank">
<code>alloy::rpc::types::eth::*</code></a></li>
<li>Proof: <a href="https://github.com/gakonst/ethers-rs/tree/master/ethers-core/src/types/proof.rs" title="" target="_blank">
<code>ethers::types::proof::*</code></a> <code>-&gt;</code> 账户 <a href="https://github.com/alloy-rs/alloy/tree/main/crates/rpc-types/src/eth/account.rs" title="" target="_blank">
<code>alloy::rpc::types::eth::account::*</code></a></li>
<li>签名: <a href="https://github.com/gakonst/ethers-rs/tree/master/ethers-core/src/types/signature.rs" title="" target="_blank">
<code>ethers::types::signature::*</code></a> <code>-&gt;</code> <a href="https://github.com/alloy-rs/alloy/tree/main/crates/rpc-types/src/eth/transaction/signature.rs" title="" target="_blank">
<code>alloy::rpc::types::eth::transaction::signature::*</code></a></li>
<li>提现: <a href="https://github.com/gakonst/ethers-rs/tree/master/ethers-core/src/types/withdrawal.rs" title="" target="_blank">
<code>ethers::types::withdrawal::*</code></a> <code>-&gt;</code> EIP4895 <a href="https://github.com/alloy-rs/alloy/tree/main/crates/eips/src/eip4895.rs" title="" target="_blank">
<code>alloy::eips::eip4895</code></a></li>
<li>操作码: <a href="https://github.com/gakonst/ethers-rs/tree/master/ethers-core/src/types/opcode.rs" title="" target="_blank">
<code>ethers::types::opcode::*</code></a> <code>-&gt;</code> <a href="https://github.com/alloy-rs/core/tree/main/crates/syn-solidity" title="" target="_blank">
<code>syn-solidity</code></a></li>
</ul>
<h3 id="abi"><a class="header" href="#abi">ABI</a></h3>
<ul>
<li>绑定: <a href="https://github.com/gakonst/ethers-rs/tree/51fe937f6515689b17a3a83b74a05984ad3a7f11/ethers-contract/ethers-contract-abigen" title="" target="_blank">
<code>abigen!</code></a> <code>-&gt;</code> <a href="https://github.com/alloy-rs/core/tree/main/crates/sol-types" title="" target="_blank">
<code>sol!</code></a>，可用于 <a href="https://github.com/alloy-rs/alloy/blob/aea7e07b4b335a3a35e3870a6c277d397d0f3932/crates/alloy/src/lib.rs#L52-L64" title="" target="_blank">
<code>alloy::sol</code></a>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="基本构建模块"><a class="header" href="#基本构建模块">基本构建模块</a></h1>
<ul>
<li><a href="building-with-alloy/basic-building-blocks/using-big-numbers.html">使用大数</a></li>
<li><a href="building-with-alloy/basic-building-blocks/basic-hash-and-address-types.html">基本哈希和地址类型</a></li>
<li><a href="building-with-alloy/basic-building-blocks/common-conversions.html">常见转换</a></li>
<li><a href="building-with-alloy/basic-building-blocks/creating-instances.html">创建实例</a></li>
<li><a href="building-with-alloy/basic-building-blocks/comparisons-and-equivalence.html">比较和等价</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="使用大数"><a class="header" href="#使用大数">使用大数</a></h2>
<p>以太坊使用大数（也称为“bignums”或“任意精度整数”）来表示其代码库中的某些值以及区块链交易中的一些值。这是必要的，因为 <a href="https://ethereum.org/en/developers/docs/evm" title="" target="_blank">EVM</a> 在 256 位字大小上运行，这与现代机器通常的 32 位或 64 位不同。这种选择是为了方便使用 256 位密码学（例如 <a href="https://github.com/ethereum/eth-hash" title="" target="_blank">Keccak-256</a> 哈希或 <a href="https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm" title="" target="_blank">secp256k1</a> 签名）。</p>
<p>值得注意的是，不仅仅是以太坊这种区块链或加密货币使用大数。许多其他区块链和加密货币也使用大数来表示其各自系统中的值。</p>
<h3 id="实用工具"><a class="header" href="#实用工具">实用工具</a></h3>
<p>为了创建应用程序，通常需要在容易让人理解的值（例如 ether）和合约及数学函数使用的机器可读形式（例如 wei）之间进行转换。这在以太坊工作中尤为重要，因为某些数值，如余额和 gas 价格，在发送交易时必须以 wei 表示，即使它们以其他格式（如 ether 或 gwei）显示给用户。为了帮助进行这种转换，<code>alloy::primitives::utils</code> 提供了两个函数，<a href="https://github.com/alloy-rs/core/blob/main/crates/primitives/src/utils/units.rs" title="" target="_blank">
<code>parse_units</code></a> 和 <a href="https://github.com/alloy-rs/core/blob/main/crates/primitives/src/utils/units.rs" title="" target="_blank">
<code>format_units</code></a>，它们可以轻松地在人类可读和机器可读的值形式之间转换。parse_units 可以将表示 ether 值的字符串（例如 “1.1”）转换为可以在合约和数学函数中使用的 wei 大数。format_units 可以将大数值转换为人类可读的字符串，这对于向用户显示值非常有用。</p>
<!-- DO NOT EDIT THIS FILE. IT IS GENERATED BY RUNNING `./scripts/update.sh` -->
<!-- ANY CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN -->
<!-- EDIT OR CREATE THIS TEMPLATE INSTEAD: ./src/templates/big-numbers/math_operations.md -->
<!-- LATEST UPDATE: https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="示例-math_operations数学运算"><a class="header" href="#示例-math_operations数学运算">示例: <code>math_operations</code>（数学运算）</a></h2>
<h3 id="示例-1"><a class="header" href="#示例-1">示例</a></h3>
<p>要运行此示例：</p>
<ul>
<li>克隆 <a href="https://github.com/alloy-rs/examples">examples</a> 仓库: <code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>运行: <code>cargo run --example math_operations</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example of performing arithmetic operations with `U256`.

use alloy::primitives::{utils::format_units, U256};
use eyre::Result;
use std::ops::{Div, Mul};

/// `U256` implements traits in `std::ops`, that means it supports arithmetic operations
/// using standard Rust operators `+`, `-`. `*`, `/`, `%`, along with additional utilities to
/// perform common mathematical tasks.
fn main() -&gt; Result&lt;()&gt; {
    let a = U256::from(10);
    let b = U256::from(2);

    // addition
    let sum = a + b;
    assert_eq!(sum, U256::from(12));

    // subtraction
    let difference = a - b;
    assert_eq!(difference, U256::from(8));

    // multiplication
    let product = a * b;
    assert_eq!(product, U256::from(20));

    // division
    let quotient = a / b;
    assert_eq!(quotient, U256::from(5));

    // modulo
    let remainder = a % b;
    assert_eq!(remainder, U256::ZERO); // equivalent to `U256::from(0)`

    // exponentiation
    let power = a.pow(b);
    assert_eq!(power, U256::from(100));

    // Multiply two 'ether' numbers:
    // Big numbers are integers, that can represent fixed point numbers.
    // For instance, 1 ether has 18 fixed
    // decimal places (1.000000000000000000), and its big number
    // representation is 10^18 = 1000000000000000000.
    // When we multiply such numbers we are summing up their exponents.
    // So if we multiply 10^18 * 10^18 we get 10^36, that is obviously incorrect.
    // In order to get the correct result we need to divide by 10^18.
    let eth1 = U256::from(10_000000000000000000_u128); // 10 ether
    let eth2 = U256::from(20_000000000000000000_u128); // 20 ether
    let base = U256::from(10).pow(U256::from(18));
    let mul = eth1.mul(eth2).div(base); // We also divide by 10^18
    let s: String = format_units(mul, "ether")?;
    assert_eq!(s, "200.000000000000000000"); // 200

    Ok(())
}</code></pre>
<p>在 Github 上找到源码 <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/big-numbers/examples/math_operations.rs">here</a>.</p>
<!-- DO NOT EDIT THIS FILE. IT IS GENERATED BY RUNNING `./scripts/update.sh` -->
<!-- ANY CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN -->
<!-- EDIT OR CREATE THIS TEMPLATE INSTEAD: ./src/templates/big-numbers/math_utilities.md -->
<!-- LATEST UPDATE: https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="示例math_utilities"><a class="header" href="#示例math_utilities">示例：<code>math_utilities</code></a></h2>
<h3 id="示例-2"><a class="header" href="#示例-2">示例</a></h3>
<p>运行此示例：</p>
<ul>
<li>克隆 <a href="https://github.com/alloy-rs/examples">examples</a> 仓库：<code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>运行：<code>cargo run --example math_utilities</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example of using math utilities to handle big numbers in 'wei' units.

use alloy::primitives::{
    utils::{format_units, parse_units},
    U256,
};
use eyre::Result;

fn main() -&gt; Result&lt;()&gt; {
    parse_units_example()?;
    format_units_example()?;

    Ok(())
}

/// dApps business logics handle big numbers in 'wei' units (i.e. sending transactions, on-chain
/// math, etc.). We provide convenient methods to map user inputs (usually in 'ether' or 'gwei')
/// into 'wei' format.
fn parse_units_example() -&gt; Result&lt;()&gt; {
    let pu = parse_units("1.0", "wei")?;
    let num: U256 = pu.into();
    assert_eq!(num, U256::from(1));

    let pu = parse_units("1.0", "kwei")?;
    let num: U256 = pu.into();
    assert_eq!(num, U256::from(1000));

    let pu = parse_units("1.0", "mwei")?;
    let num: U256 = pu.into();
    assert_eq!(num, U256::from(1000000));

    let pu = parse_units("1.0", "gwei")?;
    let num: U256 = pu.into();
    assert_eq!(num, U256::from(1000000000));

    let pu = parse_units("1.0", "szabo")?;
    let num: U256 = pu.into();
    assert_eq!(num, U256::from(1000000000000_u128));

    let pu = parse_units("1.0", "finney")?;
    let num: U256 = pu.into();
    assert_eq!(num, U256::from(1000000000000000_u128));

    let pu = parse_units("1.0", "ether")?;
    let num: U256 = pu.into();
    assert_eq!(num, U256::from(1000000000000000000_u128));

    let pu = parse_units("1.0", 18)?;
    let num: U256 = pu.into();
    assert_eq!(num, U256::from(1000000000000000000_u128));

    Ok(())
}

/// dApps business logics handle big numbers in 'wei' units (i.e. sending transactions, on-chain
/// math, etc.). On the other hand it is useful to convert big numbers into user readable formats
/// when displaying on a UI. Generally dApps display numbers in 'ether' and 'gwei' units,
/// respectively for displaying amounts and gas. The `format_units` function will format a big
/// number into a user readable string.
fn format_units_example() -&gt; Result&lt;()&gt; {
    // 1 ETHER = 10^18 WEI
    let one_ether = U256::from(1000000000000000000_u128);

    let num: String = format_units(one_ether, "wei")?;
    assert_eq!(num, "1000000000000000000.0");

    let num: String = format_units(one_ether, "gwei")?;
    assert_eq!(num, "1000000000.000000000");

    let num: String = format_units(one_ether, "ether")?;
    assert_eq!(num, "1.000000000000000000");

    // 1 GWEI = 10^9 WEI
    let one_gwei = U256::from(1000000000_u128);

    let num: String = format_units(one_gwei, 0)?;
    assert_eq!(num, "1000000000.0");

    let num: String = format_units(one_gwei, "wei")?;
    assert_eq!(num, "1000000000.0");

    let num: String = format_units(one_gwei, "kwei")?;
    assert_eq!(num, "1000000.000");

    let num: String = format_units(one_gwei, "mwei")?;
    assert_eq!(num, "1000.000000");

    let num: String = format_units(one_gwei, "gwei")?;
    assert_eq!(num, "1.000000000");

    let num: String = format_units(one_gwei, "szabo")?;
    assert_eq!(num, "0.001000000000");

    let num: String = format_units(one_gwei, "finney")?;
    assert_eq!(num, "0.000001000000000");

    let num: String = format_units(one_gwei, "ether")?;
    assert_eq!(num, "0.000000001000000000");

    Ok(())
}</code></pre>
<p>在 Github 上找到源代码 <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/big-numbers/examples/math_utilities.rs">here</a>。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="基本哈希和地址类型"><a class="header" href="#基本哈希和地址类型">基本哈希和地址类型</a></h2>
<!-- DO NOT EDIT THIS FILE. IT IS GENERATED BY RUNNING `./scripts/update.sh` -->
<!-- ANY CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN -->
<!-- EDIT OR CREATE THIS TEMPLATE INSTEAD: ./src/templates/primitives/bytes_and_address_types.md -->
<!-- LATEST UPDATE: https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="示例-bytes_and_address_types"><a class="header" href="#示例-bytes_and_address_types">示例: <code>bytes_and_address_types</code></a></h2>
<h3 id="示例-3"><a class="header" href="#示例-3">示例</a></h3>
<p>要运行此示例：</p>
<ul>
<li>克隆 <a href="https://github.com/alloy-rs/examples">examples</a> 仓库：<code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>运行：<code>cargo run --example bytes_and_address_types</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example of basic usage of bytes and address types and macros.

use alloy::primitives::{
    address, b128, b256, b512, b64, bytes, fixed_bytes, Address, Bytes, FixedBytes,
};
use eyre::Result;

fn main() -&gt; Result&lt;()&gt; {
    // Bytes type
    let a = bytes!("0123abcd");
    assert_eq!(a, Bytes::from(&amp;[0x01, 0x23, 0xab, 0xcd]));
    assert_eq!(a.len(), 4);

    // Address type
    let b = address!("f39Fd6e51aad88F6F4ce6aB8827279cffFb92266");
    assert_eq!(
        b,
        Address::from(&amp;[
            0xf3, 0x9f, 0xd6, 0xe5, 0x1a, 0xad, 0x88, 0xf6, 0xf4, 0xce, 0x6a, 0xb8, 0x82, 0x72,
            0x79, 0xcf, 0xff, 0xb9, 0x22, 0x66
        ])
    );
    assert_eq!(b.len(), 20);

    // FixedBytes&lt;8&gt; type
    let c = b64!("0102030405060708");
    assert_eq!(c, FixedBytes::from(&amp;[0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08]));
    assert_eq!(c.len(), 8);

    // FixedBytes&lt;16&gt; type
    let d = b128!("0102030405060708090a0b0c0d0e0f10");
    assert_eq!(
        d,
        FixedBytes::from(&amp;[
            0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e,
            0x0f, 0x10,
        ])
    );
    assert_eq!(d.len(), 16);

    // FixedBytes&lt;32&gt; type
    let e = b256!("0102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f20");
    assert_eq!(
        e,
        FixedBytes::from(&amp;[
            0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e,
            0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c,
            0x1d, 0x1e, 0x1f, 0x20,
        ]),
    );
    assert_eq!(e.len(), 32);

    // FixedBytes&lt;64&gt; type
    let f = b512!("0102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f202122232425262728292a2b2c2d2e2f303132333435363738393a3b3c3d3e3f40");
    assert_eq!(
        f,
        FixedBytes::from(&amp;[
            0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e,
            0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c,
            0x1d, 0x1e, 0x1f, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a,
            0x2b, 0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38,
            0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f, 0x40,
        ]),
    );
    assert_eq!(f.len(), 64);

    // FixedBytes&lt;20&gt; type, determined by the length of the input
    let g = fixed_bytes!("0102030405060708090a0b0c0d0e0f1011121314");
    assert_eq!(
        g,
        FixedBytes::from(&amp;[
            0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e,
            0x0f, 0x10, 0x11, 0x12, 0x13, 0x14,
        ]),
    );
    assert_eq!(g.len(), 20);

    Ok(())
}</code></pre>
<p>在 Github 上可以找到源码 <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/primitives/examples/bytes_and_address_types.rs">here</a>.</p>
<!-- DO NOT EDIT THIS FILE. IT IS GENERATED BY RUNNING `./scripts/update.sh` -->
<!-- ANY CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN -->
<!-- EDIT OR CREATE THIS TEMPLATE INSTEAD: ./src/templates/primitives/hashing_functions.md -->
<!-- LATEST UPDATE: https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="示例-hashing_functions-哈希函数"><a class="header" href="#示例-hashing_functions-哈希函数">示例: <code>hashing_functions</code> 哈希函数</a></h2>
<h3 id="示例-4"><a class="header" href="#示例-4">示例</a></h3>
<p>要运行这个示例：</p>
<ul>
<li>克隆 <a href="https://github.com/alloy-rs/examples">examples</a> 代码库: <code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>运行: <code>cargo run --example hashing_functions</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example of basic usage of hashing functions.

use alloy::primitives::{eip191_hash_message, keccak256};
use eyre::{Ok, Result};

fn main() -&gt; Result&lt;()&gt; {
    // [`Keccak-256`]: https://en.wikipedia.org/wiki/SHA-3
    let hash = keccak256(b"hello world");
    assert_eq!(
        hash.to_string(),
        "0x47173285a8d7341e5e972fc677286384f802f8ef42a5ec5f03bbfa254cb01fad"
    );
    assert_eq!(hash.len(), 32);

    // Hash a message according to [EIP-191] (version `0x01`).
    //
    // The final message is a UTF-8 string, encoded as follows:
    // `"\x19Ethereum Signed Message:\n" + message.length + message`
    //
    // This message is then hashed using [`Keccak-256`]: https://en.wikipedia.org/wiki/SHA-3.
    //
    // [EIP-191]: https://eips.ethereum.org/EIPS/eip-191
    let eip191_hash = eip191_hash_message(b"hello_world");
    assert_eq!(
        eip191_hash.to_string(),
        "0xd52de6e039c023a7c77752126e4d9d99e2a7dacea3d19e97e9c2ebcb3ecf1c00"
    );
    assert_eq!(eip191_hash.len(), 32);

    Ok(())
}</code></pre>
<p>在 Github 上找到源码 <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/primitives/examples/hashing_functions.rs">这里</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="common-conversions"><a class="header" href="#common-conversions">Common conversions</a></h2>
<!-- DO NOT EDIT THIS FILE. IT IS GENERATED BY RUNNING `./scripts/update.sh` -->
<!-- ANY CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN -->
<!-- EDIT OR CREATE THIS TEMPLATE INSTEAD: ./src/templates/big-numbers/conversion.md -->
<!-- LATEST UPDATE: https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="示例-conversion"><a class="header" href="#示例-conversion">示例: <code>conversion</code></a></h2>
<h3 id="示例-5"><a class="header" href="#示例-5">示例</a></h3>
<p>运行这个示例:</p>
<ul>
<li>克隆 <a href="https://github.com/alloy-rs/examples">examples</a> 仓库: <code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>运行: <code>cargo run --example conversion</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example of converting `U256` to native Rust types.

use alloy::primitives::{utils::format_units, U256};
use eyre::Result;

/// `U256` provides useful conversion functions to enable transformation into native Rust types.
///
/// It is important to note that converting a big-number to a floating point type (such as a `f32`
/// or `f64`) can result in a loss of precision, since you cannot fit 256 bits of information into
/// 64 bits.
///
/// However, there may be cases where you want to perform conversions for presentation purposes.
/// For example, you may want to display a large number to the user in a more readable format.
fn main() -&gt; Result&lt;()&gt; {
    let num = U256::from(42_u8);

    let a: u128 = num.to::&lt;u128&gt;();
    assert_eq!(a, 42);

    let b: u64 = num.to::&lt;u64&gt;();
    assert_eq!(b, 42);

    let c: u32 = num.to::&lt;u32&gt;();
    assert_eq!(c, 42);

    let d: usize = num.to::&lt;usize&gt;();
    assert_eq!(d, 42);

    let e: String = num.to_string();
    assert_eq!(e, "42");

    let f: String = format_units(num, 4)?;
    assert_eq!(f, "0.0042");

    Ok(())
}</code></pre>
<p>在 Github 上找到源代码 <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/big-numbers/examples/conversion.rs">here</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="创建实例"><a class="header" href="#创建实例">创建实例</a></h2>
<!-- DO NOT EDIT THIS FILE. IT IS GENERATED BY RUNNING `./scripts/update.sh` -->
<!-- ANY CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN -->
<!-- EDIT OR CREATE THIS TEMPLATE INSTEAD: ./src/templates/big-numbers/create_instances.md -->
<!-- LATEST UPDATE: https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="示例-create_instances"><a class="header" href="#示例-create_instances">示例: <code>create_instances</code></a></h2>
<h3 id="例子"><a class="header" href="#例子">例子</a></h3>
<p>运行此示例：</p>
<ul>
<li>克隆 <a href="https://github.com/alloy-rs/examples">examples</a> 仓库: <code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>运行: <code>cargo run --example create_instances</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example of creating instances of `U256` from strings and numbers.

use alloy::primitives::{
    utils::{parse_units, ParseUnits},
    U256,
};
use eyre::Result;
use std::str::FromStr;

fn main() -&gt; Result&lt;()&gt; {
    // From strings
    let a = U256::from_str("42")?;
    assert_eq!(a.to_string(), "42");

    let amount = "42";
    let units = 4;
    let b: ParseUnits = parse_units(amount, units)?;
    assert_eq!(b.to_string(), "420000");

    // From numbers
    let c = U256::from(42_u8);
    assert_eq!(c.to_string(), "42");

    let d = U256::from(42_u16);
    assert_eq!(d.to_string(), "42");

    let e = U256::from(42_u32);
    assert_eq!(e.to_string(), "42");

    let f = U256::from(42_u64);
    assert_eq!(f.to_string(), "42");

    let g = U256::from(42_u128);
    assert_eq!(g.to_string(), "42");

    let h = U256::from(0x2a);
    assert_eq!(h.to_string(), "42");

    let i = U256::from(42);
    assert_eq!(i.to_string(), "42");

    Ok(())
}</code></pre>
<p>在 Github 上查看源代码 <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/big-numbers/examples/create_instances.rs">here</a>。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="比较与等价"><a class="header" href="#比较与等价">比较与等价</a></h2>
<!-- 请不要编辑此文件。它是通过运行 `./scripts/update.sh` 生成的 -->
<!-- 对此文件做的任何更改都会被覆盖 -->
<!-- 请改编辑或创建这个模板：./src/templates/big-numbers/comparison_equivalence.md -->
<!-- 最新更新： https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="示例comparison_equivalence"><a class="header" href="#示例comparison_equivalence">示例：<code>comparison_equivalence</code></a></h2>
<h3 id="示例-6"><a class="header" href="#示例-6">示例</a></h3>
<p>要运行此示例：</p>
<ul>
<li>克隆 <a href="https://github.com/alloy-rs/examples">examples</a> 仓库：<code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>运行：<code>cargo run --example comparison_equivalence</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example of comparison and equivalence of `U256` instances.

use alloy::primitives::U256;

/// `U256` implements traits in `std::cmp`, that means `U256` instances
/// can be easily compared using standard Rust operators.
fn main() {
    // a == b
    let a = U256::from(100_u32);
    let b = U256::from(100_u32);
    assert!(a == b);

    // a &lt; b
    let a = U256::from(1_u32);
    let b = U256::from(100_u32);
    assert!(a &lt; b);

    // a &lt;= b
    let a = U256::from(100_u32);
    let b = U256::from(100_u32);
    assert!(a &lt;= b);

    // a &gt; b
    let a = U256::from(100_u32);
    let b = U256::from(1_u32);
    assert!(a &gt; b);

    // a &gt;= b
    let a = U256::from(100_u32);
    let b = U256::from(100_u32);
    assert!(a &gt;= b);

    // a == 0
    let a = U256::ZERO;
    assert!(a.is_zero());
}</code></pre>
<p>在 Github 上可以找到源码：<a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/big-numbers/examples/comparison_equivalence.rs">这里</a>。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="连接区块链"><a class="header" href="#连接区块链">连接区块链</a></h1>
<ul>
<li><a href="building-with-alloy/connecting-to-a-blockchain/setting-up-a-provider.html">设置 Provider</a></li>
<li><a href="building-with-alloy/connecting-to-a-blockchain/http-provider.html" title="" target="_blank">创建 HTTP provider</a></li>
<li><a href="building-with-alloy/connecting-to-a-blockchain/ws-provider.html">创建 WS provider</a></li>
<li><a href="building-with-alloy/connecting-to-a-blockchain/ipc-provider.html">创建 IPC provider</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="设置-provider"><a class="header" href="#设置-provider">设置 <code>Provider</code></a></h2>
<p>一个 <a href="https://docs.rs/alloy/latest/alloy/providers/trait.Provider.html" title="" target="_blank">
<code>Provider</code></a> 是对 Ethereum 网络连接的抽象，提供一个简洁、一致的接口来使用标准的 Ethereum 节点功能。</p>
<h3 id="builder"><a class="header" href="#builder">Builder</a></h3>
<p>创建 <a href="https://docs.rs/alloy/latest/alloy/providers/trait.Provider.html" title="" target="_blank">
<code>Provider</code></a> 的正确方式是通过 <a href="https://docs.rs/alloy/latest/alloy/providers/struct.ProviderBuilder.html" title="" target="_blank">
<code>ProviderBuilder</code></a>，这是一个 <a href="https://rust-unofficial.github.io/patterns/patterns/creational/builder.html" title="" target="_blank">builder</a>。</p>
<p>Alloy 提供了具体的传输实现，比如 <a href="building-with-alloy/connecting-to-a-blockchain/./http-provider.html"><code>HTTP</code></a>、<a href="building-with-alloy/connecting-to-a-blockchain/./ws-provider.html"><code>WS</code> (WebSockets)</a> 和 <a href="building-with-alloy/connecting-to-a-blockchain/./ipc-provider.html"><code>IPC</code> (进程间通信)</a>，以及封装单个或多个传输的高级传输方式。</p>
<pre><code class="language-rust ignore">//! 使用 `on_http` 方法的 HTTP provider 示例。

use alloy::providers::{Provider, ProviderBuilder};
use eyre::Result;

#[tokio::main]
async fn main() -&gt; eyre::Result&lt;()&gt; {
    // 设置由 RPC 客户端使用的 HTTP 传输。
    let rpc_url = "https://eth.merkle.io".parse()?;

    // 使用 `reqwest` crate 创建一个带有 HTTP 传输的 provider。
    let provider = ProviderBuilder::new().on_http(rpc_url);

    Ok(())
}</code></pre>
<p>接下来，让我们看看 <a href="building-with-alloy/connecting-to-a-blockchain/./http-provider.html">HTTP Provider</a>。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="http-provider"><a class="header" href="#http-provider">HTTP <code>Provider</code></a></h2>
<p><code>Http</code> 提供者建立与节点的 HTTP 连接，允许你发送 JSON-RPC 请求到节点以获取数据、模拟调用、发送交易等等。</p>
<h3 id="初始化-http-提供者"><a class="header" href="#初始化-http-提供者">初始化 Http 提供者</a></h3>
<p>推荐的初始化 <code>Http</code> 提供者的方法是使用 <a href="https://docs.rs/alloy/latest/alloy/providers/struct.ProviderBuilder.html#method.on_http" title="" target="_blank">
<code>on_http</code></a> 方法在 <a href="https://docs.rs/alloy/latest/alloy/providers/struct.ProviderBuilder.html" title="" target="_blank">
<code>ProviderBuilder</code></a> 上。</p>
<pre><code class="language-rust ignore">//! 使用 `ProviderBuilder` 上的 `on_http` 方法创建 HTTP 提供者的示例。

use alloy::providers::{Provider, ProviderBuilder};
use eyre::Result;

#[tokio::main]
async fn main() -&gt; eyre::Result&lt;()&gt; {
    // 设置由 RPC 客户端使用的 HTTP 传输。
    let rpc_url = "https://eth.merkle.io".parse()?;

    // 使用 `reqwest` crate 创建一个带有 HTTP 传输的提供者。
    let provider = ProviderBuilder::new().on_http(rpc_url);

    Ok(())
}</code></pre>
<p>另一种初始化方法是使用 <a href="https://docs.rs/alloy/latest/alloy/providers/struct.ProviderBuilder.html#method.on_builtin" title="" target="_blank">
<code>on_builtin</code></a> 方法在 <a href="https://docs.rs/alloy/latest/alloy/providers/struct.ProviderBuilder.html" title="" target="_blank">
<code>ProviderBuilder</code></a> 上。根据 URL 的格式，该方法会自动确定连接类型（<code>Http</code>、<code>Ws</code> 或 <code>Ipc</code>）。如果你需要一个装箱的传输方法，该方法特别有用。</p>
<pre><code class="language-rust ignore">//! 使用 `ProviderBuilder` 上的 `on_builtin` 方法创建 HTTP 提供者的示例。

use alloy::providers::{Provider, ProviderBuilder};
use eyre::Result;

#[tokio::main]
async fn main() -&gt; eyre::Result&lt;()&gt; {
    // 使用 `reqwest` crate 创建一个带有 HTTP 传输的提供者。
    let provider = ProviderBuilder::new().on_builtin("https://eth.merkle.io").await?;

    Ok(())
}</code></pre>
<!-- 请勿编辑此文件。它是通过运行 `./scripts/update.sh` 生成的 -->
<!-- 对此文件的任何更改都将被覆盖 -->
<!-- 请改为编辑或创建此模板: ./src/templates/providers/http.md -->
<!-- 最新更新: https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="示例-http"><a class="header" href="#示例-http">示例: <code>http</code></a></h2>
<h3 id="示例-7"><a class="header" href="#示例-7">示例</a></h3>
<p>要运行此示例：</p>
<ul>
<li>克隆 <a href="https://github.com/alloy-rs/examples">examples</a> 仓库: <code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>运行: <code>cargo run --example http</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example of using the HTTP provider with the `reqwest` crate to get the latest block number.

use alloy::providers::{Provider, ProviderBuilder};
use eyre::Result;

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    // Set up the HTTP transport which is consumed by the RPC client.
    let rpc_url = "https://eth.merkle.io".parse()?;

    // Create a provider with the HTTP transport using the `reqwest` crate.
    let provider = ProviderBuilder::new().on_http(rpc_url);

    // Get latest block number.
    let latest_block = provider.get_block_number().await?;

    println!("Latest block number: {latest_block}");

    Ok(())
}</code></pre>
<p>在 Github 上找到源代码 <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/providers/examples/http.rs">here</a>。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="ws-provider"><a class="header" href="#ws-provider">WS <code>Provider</code></a></h2>
<p><code>Ws</code> 提供者与节点建立 WebSocket 连接，允许你发送 JSON-RPC 请求到节点以获取数据、模拟调用、发送交易等功能。<code>Ws</code> 提供者可以用于任何支持 WebSocket 连接的以太坊节点。这使得程序可以实时与网络进行交互，而不需要通过 HTTP 轮询来获取诸如新区块头和过滤日志之类的信息。</p>
<h3 id="初始化-ws-提供者"><a class="header" href="#初始化-ws-提供者">初始化 <code>Ws</code> 提供者</a></h3>
<p>推荐的方法是使用 <a href="https://docs.rs/alloy/latest/alloy/providers/struct.ProviderBuilder.html" title="" target="_blank">
<code>ProviderBuilder</code></a> 的 <a href="https://docs.rs/alloy/latest/alloy/providers/struct.ProviderBuilder.html#method.on_ws" title="" target="_blank">
<code>on_ws</code></a> 方法与 <a href="https://docs.rs/alloy/latest/alloy/providers/struct.WsConnect.html" title="" target="_blank">
<code>WsConnect</code></a> 配置来初始化 <code>Ws</code> 提供者。</p>
<pre><code class="language-rust ignore">//! 使用 `ProviderBuilder` 的 `on_ws` 方法创建一个 WS 提供者的示例。

use alloy::providers::{Provider, ProviderBuilder, WsConnect};
use eyre::Result;

#[tokio::main]
async fn main() -&gt; eyre::Result&lt;()&gt; {
    // 设置由 RPC 客户端消费的 WS 传输。
    let rpc_url = "wss://eth-mainnet.g.alchemy.com/v2/your-api-key";

    // 创建提供者。
    let ws = WsConnect::new(rpc_url);
    let provider = ProviderBuilder::new().on_ws(ws).await?;

    Ok(())
}</code></pre>
<p>另一种初始化方法是使用 <a href="https://docs.rs/alloy/latest/alloy/providers/struct.ProviderBuilder.html" title="" target="_blank">
<code>ProviderBuilder</code></a> 的 <a href="https://docs.rs/alloy/latest/alloy/providers/struct.ProviderBuilder.html#method.on_builtin" title="" target="_blank">
<code>on_builtin</code></a> 方法。该方法将根据 URL 的格式自动确定连接类型（<code>Http</code>、<code>Ws</code> 或 <code>Ipc</code>）。如果你需要一个封装的 transport，这个方法特别有用。</p>
<pre><code class="language-rust ignore">//! 使用 `ProviderBuilder` 的 `on_builtin` 方法创建一个 WS 提供者的示例。

use alloy::providers::{Provider, ProviderBuilder};
use eyre::Result;

#[tokio::main]
async fn main() -&gt; eyre::Result&lt;()&gt; {
    // 使用 WS 传输创建一个提供者。
    let provider = ProviderBuilder::new().on_builtin("wss://eth-mainnet.g.alchemy.com/v2/your-api-key").await?;

    Ok(())
}</code></pre>
<p>与其他提供者类似，你也可以通过 WebSockets 与节点建立授权连接。</p>
<!-- DO NOT EDIT THIS FILE. IT IS GENERATED BY RUNNING `./scripts/update.sh` -->
<!-- ANY CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN -->
<!-- EDIT OR CREATE THIS TEMPLATE INSTEAD: ./src/templates/providers/ws.md -->
<!-- LATEST UPDATE: https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="示例-ws"><a class="header" href="#示例-ws">示例: <code>ws</code></a></h2>
<h3 id="示例-8"><a class="header" href="#示例-8">示例</a></h3>
<p>要运行这个示例：</p>
<ul>
<li>克隆 <a href="https://github.com/alloy-rs/examples">examples</a> 仓库：<code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>运行：<code>cargo run --example ws</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example of using the WS provider to subscribe to new blocks.

use alloy::providers::{Provider, ProviderBuilder, WsConnect};
use eyre::Result;
use futures_util::StreamExt;

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    // Set up the WS transport which is consumed by the RPC client.
    let rpc_url = "wss://eth-mainnet.g.alchemy.com/v2/your-api-key";

    // Create the provider.
    let ws = WsConnect::new(rpc_url);
    let provider = ProviderBuilder::new().on_ws(ws).await?;

    // Subscribe to new blocks.
    let sub = provider.subscribe_blocks().await?;

    // Wait and take the next 4 blocks.
    let mut stream = sub.into_stream().take(4);

    println!("Awaiting blocks...");

    // Take the stream and print the block number upon receiving a new block.
    let handle = tokio::spawn(async move {
        while let Some(block) = stream.next().await {
            println!(
                "Latest block number: {}",
                block.header.number.expect("Failed to get block number")
            );
        }
    });

    handle.await?;

    Ok(())
}</code></pre>
<p>在 Github 上找到源代码 <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/providers/examples/ws.rs">这里</a>.</p>
<!-- DO NOT EDIT THIS FILE. IT IS GENERATED BY RUNNING `./scripts/update.sh` -->
<!-- ANY CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN -->
<!-- EDIT OR CREATE THIS TEMPLATE INSTEAD: ./src/templates/providers/ws_with_auth.md -->
<!-- LATEST UPDATE: https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="示例ws_with_auth"><a class="header" href="#示例ws_with_auth">示例：<code>ws_with_auth</code></a></h2>
<h3 id="示例-9"><a class="header" href="#示例-9">示例</a></h3>
<p>运行此示例：</p>
<ul>
<li>克隆 <a href="https://github.com/alloy-rs/examples">examples</a> 仓库：<code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>运行：<code>cargo run --example ws_with_auth</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example of using the WS provider with auth to subscribe to new blocks.

use alloy::{
    providers::{Provider, ProviderBuilder, WsConnect},
    transports::Authorization,
};
use eyre::Result;
use futures_util::StreamExt;

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    // Set up the WS transport which is consumed by the RPC client.
    let rpc_url = "wss://your-ws-endpoint.com/";

    // Create authorization methods.
    let auth = Authorization::basic("username", "password");
    let auth_bearer = Authorization::bearer("bearer-token");

    // Create the WS connection object with authentication.
    let ws_basic = WsConnect::with_auth(rpc_url, Some(auth));
    let ws_bearer = WsConnect::with_auth(rpc_url, Some(auth_bearer));

    // Create the provider.
    let provider_basic = ProviderBuilder::new().on_ws(ws_basic).await?;
    let provider_bearer = ProviderBuilder::new().on_ws(ws_bearer).await?;

    // Subscribe to new blocks.
    let sub_basic = provider_basic.subscribe_blocks();
    let sub_bearer = provider_bearer.subscribe_blocks();

    // Wait and take the next 4 blocks.
    let mut stream_basic = sub_basic.await?.into_stream().take(4);
    let mut stream_bearer = sub_bearer.await?.into_stream().take(4);

    println!("Awaiting blocks...");

    // Take the basic stream and print the block number upon receiving a new block.
    let basic_handle = tokio::spawn(async move {
        while let Some(block) = stream_basic.next().await {
            println!(
                "Latest block number (basic): {}",
                block.header.number.expect("Failed to get block number")
            );
        }
    });

    // Take the bearer stream and print the block number upon receiving a new block.
    let bearer_handle = tokio::spawn(async move {
        while let Some(block) = stream_bearer.next().await {
            println!(
                "Latest block number (bearer): {}",
                block.header.number.expect("Failed to get block number")
            );
        }
    });

    // Wait for both tasks to complete.
    let _ = tokio::try_join!(basic_handle, bearer_handle)?;

    Ok(())
}</code></pre>
<p>可以在 Github 上找到源码 <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/providers/examples/ws_with_auth.rs">here</a>。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="ipc-provider"><a class="header" href="#ipc-provider">IPC <code>Provider</code></a></h2>
<p><a href="https://en.wikipedia.org/wiki/Inter-process_communication" title="" target="_blank">IPC（进程间通信）</a> 传输允许我们的程序通过本地 <a href="https://en.wikipedia.org/wiki/Unix_domain_socket" title="" target="_blank">Unix 域 socket</a> 或 <a href="https://learn.microsoft.com/en-us/windows/win32/ipc/named-pipes" title="" target="_blank">Windows 命名管道</a>与一个节点进行通信。</p>
<p>使用 IPC 传输让 ethers 库可以向 Ethereum 客户端发送 JSON-RPC 请求并接收响应，而无需网络连接或 HTTP 服务器。这对于与运行在同一网络上的本地 Ethereum 节点进行交互非常有用。使用 IPC <a href="https://github.com/0xKitsune/geth-ipc-rpc-bench" title="" target="_blank">比 RPC 更快</a>，但是你需要能够连接到一个本地节点。</p>
<h3 id="初始化一个-ipc-提供者"><a class="header" href="#初始化一个-ipc-提供者">初始化一个 <code>Ipc</code> 提供者</a></h3>
<p>初始化 <code>Ipc</code> 提供者的推荐方式是使用 <a href="https://docs.rs/alloy/latest/alloy/providers/struct.ProviderBuilder.html" title="" target="_blank">
<code>ProviderBuilder</code></a> 上的 <a href="https://docs.rs/alloy/latest/alloy/providers/struct.ProviderBuilder.html#method.on_ipc" title="" target="_blank">
<code>on_ipc</code></a> 方法，并配置 <a href="https://docs.rs/alloy/latest/alloy/providers/struct.IpcConnect.html" title="" target="_blank">
<code>IpcConnect</code></a>。</p>
<pre><code class="language-rust ignore">//! 使用 `ProviderBuilder` 上的 `on_ipc` 方法创建一个 IPC 提供者的示例。

use alloy::providers::{IpcConnect, Provider, ProviderBuilder};
use eyre::Result;

#[tokio::main]
async fn main() -&gt; eyre::Result&lt;()&gt; {
    // 设置由 RPC 客户端使用的 IPC 传输。
    let ipc_path = "/tmp/reth.ipc";

    // 创建提供者。
    let ipc = IpcConnect::new(ipc_path.to_string());
    let provider = ProviderBuilder::new().on_ipc(ipc).await?;

    Ok(())
}</code></pre>
<p>另一种初始化方式是使用 <a href="https://docs.rs/alloy/latest/alloy/providers/struct.ProviderBuilder.html" title="" target="_blank">
<code>ProviderBuilder</code></a> 上的 <a href="https://docs.rs/alloy/latest/alloy/providers/struct.ProviderBuilder.html#method.on_builtin" title="" target="_blank">
<code>on_builtin</code></a> 方法。此方法会根据 URL 的格式自动确定连接类型（<code>Http</code>、<code>Ws</code> 或 <code>Ipc</code>）。如果你需要一个盒装传输，此方法特别有用。</p>
<pre><code class="language-rust ignore">//! 使用 `ProviderBuilder` 上的 `on_builtin` 方法创建一个 IPC 提供者的示例。

use alloy::providers::{Provider, ProviderBuilder};
use eyre::Result;

#[tokio::main]
async fn main() -&gt; eyre::Result&lt;()&gt; {
    // 使用 IPC 传输创建提供者。
    let provider = ProviderBuilder::new().on_builtin("/tmp/reth.ipc").await?;

    Ok(())
}</code></pre>
<!-- 请勿编辑此文件。它是通过运行 `./scripts/update.sh` 自动生成的 -->
<!-- 对该文件进行的任何更改都会被覆盖 -->
<!-- 请编辑或创建以下模板来替代：./src/templates/providers/ipc.md -->
<!-- 最新更新： https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="示例ipc"><a class="header" href="#示例ipc">示例：<code>ipc</code></a></h2>
<h3 id="示例-10"><a class="header" href="#示例-10">示例</a></h3>
<p>运行此示例：</p>
<ul>
<li>克隆 <a href="https://github.com/alloy-rs/examples">examples</a> 仓库: <code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>运行: <code>cargo run --example ipc</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example of using the IPC provider to get the latest block number.

use alloy::providers::{IpcConnect, Provider, ProviderBuilder};
use eyre::Result;

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    // Set up the IPC transport which is consumed by the RPC client.
    let ipc_path = "/tmp/reth.ipc";

    // Create the provider.
    let ipc = IpcConnect::new(ipc_path.to_string());
    let provider = ProviderBuilder::new().on_ipc(ipc).await?;

    let latest_block = provider.get_block_number().await?;

    println!("Latest block: {latest_block}");

    Ok(())
}</code></pre>
<p>在 Github 上查看源代码 <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/providers/examples/ipc.rs">这里</a>。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="理解-fillers"><a class="header" href="#理解-fillers">理解 <code>Fillers</code></a></h2>
<p><a href="https://docs.rs/alloy/latest/alloy/providers/fillers/index.html" title="" target="_blank">Fillers</a> 装饰了一个 <a href="https://docs.rs/alloy/latest/alloy/providers/trait.Provider.html" title="" target="_blank">
<code>Provider</code></a>，在交易发送到网络之前填充交易细节。Fillers 用于设置 nonce、gas 价格、gas 限制和其他交易细节，它们在任何其他层调用之前被调用。</p>
<!-- DO NOT EDIT THIS FILE. IT IS GENERATED BY RUNNING `./scripts/update.sh` -->
<!-- ANY CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN -->
<!-- EDIT OR CREATE THIS TEMPLATE INSTEAD: ./src/templates/fillers/recommended_fillers.md -->
<!-- LATEST UPDATE: https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="示例-recommended_fillers"><a class="header" href="#示例-recommended_fillers">示例: <code>recommended_fillers</code></a></h2>
<h3 id="示例-11"><a class="header" href="#示例-11">示例</a></h3>
<p>要运行这个示例:</p>
<ul>
<li>克隆 <a href="https://github.com/alloy-rs/examples">examples</a> 仓库: <code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>运行: <code>cargo run --example recommended_fillers</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example of using the `.with_recommended_fillers()` method in the provider.

use alloy::{
    network::{EthereumWallet, TransactionBuilder},
    node_bindings::Anvil,
    primitives::{address, U256},
    providers::{Provider, ProviderBuilder},
    rpc::types::request::TransactionRequest,
    signers::local::PrivateKeySigner,
};
use eyre::Result;

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    // Spin up a local Anvil node.
    // Ensure `anvil` is available in $PATH.
    let anvil = Anvil::new().try_spawn()?;

    // Set up signer from the first default Anvil account (Alice).
    let signer: PrivateKeySigner = anvil.keys()[0].clone().into();
    let wallet = EthereumWallet::from(signer);

    // Create a provider with the wallet.
    let rpc_url = anvil.endpoint().parse()?;
    let provider = ProviderBuilder::new()
        // Adds the `ChainIdFiller`, `GasFiller` and the `NonceFiller` layers.
        .with_recommended_fillers()
        .wallet(wallet)
        .on_http(rpc_url);

    // Build an EIP-1559 type transaction to send 100 wei to Vitalik.
    // Notice that the `nonce` field is set by the `NonceFiller`.
    // Notice that the gas related fields are set by the `GasFiller`.
    // Notice that the `chain_id` field is set by the `ChainIdFiller`.
    let vitalik = address!("d8dA6BF26964aF9D7eEd9e03E53415D37aA96045");
    let tx = TransactionRequest::default().with_to(vitalik).with_value(U256::from(100));

    // Send the transaction, the nonce (0) is automatically managed by the provider.
    let builder = provider.send_transaction(tx.clone()).await?;
    let node_hash = *builder.tx_hash();
    let pending_tx =
        provider.get_transaction_by_hash(node_hash).await?.expect("Pending transaction not found");
    assert_eq!(pending_tx.nonce, 0);

    println!("Transaction sent with nonce: {}", pending_tx.nonce);

    // Send the transaction, the nonce (1) is automatically managed by the provider.
    let builder = provider.send_transaction(tx).await?;
    let node_hash = *builder.tx_hash();
    let pending_tx =
        provider.get_transaction_by_hash(node_hash).await?.expect("Pending transaction not found");
    assert_eq!(pending_tx.nonce, 1);

    println!("Transaction sent with nonce: {}", pending_tx.nonce);

    Ok(())
}</code></pre>
<p>在 Github 上找到源代码 <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/fillers/examples/recommended_fillers.rs">here</a>.</p>
<!-- DO NOT EDIT THIS FILE. IT IS GENERATED BY RUNNING `./scripts/update.sh` -->
<!-- ANY CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN -->
<!-- EDIT OR CREATE THIS TEMPLATE INSTEAD: ./src/templates/fillers/gas_filler.md -->
<!-- LATEST UPDATE: https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="示例gas_filler"><a class="header" href="#示例gas_filler">示例：<code>gas_filler</code></a></h2>
<h3 id="示例-12"><a class="header" href="#示例-12">示例</a></h3>
<p>要运行此示例：</p>
<ul>
<li>克隆 <a href="https://github.com/alloy-rs/examples">examples</a> 仓库：<code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>运行：<code>cargo run --example gas_filler</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example of using the `GasFiller` in the provider.

use alloy::{
    network::{EthereumWallet, TransactionBuilder},
    node_bindings::Anvil,
    primitives::{address, U256},
    providers::{Provider, ProviderBuilder},
    rpc::types::request::TransactionRequest,
    signers::local::PrivateKeySigner,
};
use eyre::Result;

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    // Spin up a local Anvil node.
    // Ensure `anvil` is available in $PATH.
    let anvil = Anvil::new().try_spawn()?;

    // Set up signer from the first default Anvil account (Alice).
    let signer: PrivateKeySigner = anvil.keys()[0].clone().into();
    let wallet = EthereumWallet::from(signer);

    // Create a provider with the wallet.
    let rpc_url = anvil.endpoint().parse()?;
    let provider = ProviderBuilder::new()
        // Add the `GasFiller` to the provider.
        // It is generally recommended to use the `.with_recommended_fillers()` method, which
        // includes the `GasFiller`.
        .with_gas_estimation()
        .wallet(wallet)
        .on_http(rpc_url);

    // Build an EIP-1559 type transaction to send 100 wei to Vitalik.
    let vitalik = address!("d8dA6BF26964aF9D7eEd9e03E53415D37aA96045");
    let tx = TransactionRequest::default()
        .with_to(vitalik)
        .with_value(U256::from(100))
        // Notice that without the `NonceFiller`, you need to set `nonce` field.
        .with_nonce(0)
        // Notice that without the `ChainIdFiller`, you need to set the `chain_id` field.
        .with_chain_id(anvil.chain_id());

    // Send the transaction, the nonce (0) is automatically managed by the provider.
    let builder = provider.send_transaction(tx.clone()).await?;
    let node_hash = *builder.tx_hash();
    let pending_tx =
        provider.get_transaction_by_hash(node_hash).await?.expect("Pending transaction not found");
    assert_eq!(pending_tx.nonce, 0);

    println!("Transaction sent with nonce: {}", pending_tx.nonce);

    // Update the nonce and send the transaction again.
    let tx = tx.with_nonce(1);

    // Send the transaction, the nonce (1) is automatically managed by the provider.
    let builder = provider.send_transaction(tx).await?;
    let node_hash = *builder.tx_hash();
    let pending_tx =
        provider.get_transaction_by_hash(node_hash).await?.expect("Pending transaction not found");
    assert_eq!(pending_tx.nonce, 1);

    println!("Transaction sent with nonce: {}", pending_tx.nonce);

    Ok(())
}</code></pre>
<p>在 Github 上找到源代码 <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/fillers/examples/gas_filler.rs">here</a>.</p>
<!-- DO NOT EDIT THIS FILE. IT IS GENERATED BY RUNNING `./scripts/update.sh` -->
<!-- ANY CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN -->
<!-- EDIT OR CREATE THIS TEMPLATE INSTEAD: ./src/templates/fillers/nonce_filler.md -->
<!-- LATEST UPDATE: https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="示例-nonce_filler"><a class="header" href="#示例-nonce_filler">示例: <code>nonce_filler</code></a></h2>
<h3 id="示例-13"><a class="header" href="#示例-13">示例</a></h3>
<p>运行此示例:</p>
<ul>
<li>克隆 <a href="https://github.com/alloy-rs/examples">examples</a> 仓库: <code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>运行: <code>cargo run --example nonce_filler</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example of using the `NonceFiller` in the provider.

use alloy::{
    network::{EthereumWallet, TransactionBuilder},
    node_bindings::Anvil,
    primitives::{address, U256},
    providers::{Provider, ProviderBuilder},
    rpc::types::request::TransactionRequest,
    signers::local::PrivateKeySigner,
};
use eyre::Result;

/// In Ethereum, the nonce of a transaction is a number that represents the number of transactions
/// that have been sent from a particular account. The nonce is used to ensure that transactions are
/// processed in the order they are intended, and to prevent the same transaction from being
/// processed multiple times.
///
/// The nonce manager in Alloy is a layer that helps you manage the nonce
/// of transactions by keeping track of the current nonce for a given account and automatically
/// incrementing it as needed. This can be useful if you want to ensure that transactions are sent
/// in the correct order, or if you want to avoid having to manually manage the nonce yourself.
#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    // Spin up a local Anvil node.
    // Ensure `anvil` is available in $PATH.
    let anvil = Anvil::new().try_spawn()?;

    // Set up signer from the first default Anvil account (Alice).
    let signer: PrivateKeySigner = anvil.keys()[0].clone().into();
    let wallet = EthereumWallet::from(signer);

    // Create a provider with the wallet.
    let rpc_url = anvil.endpoint().parse()?;
    let provider = ProviderBuilder::new()
        // Add the `NonceFiller` to the provider.
        // It is generally recommended to use the `.with_recommended_fillers()` method, which
        // includes the `NonceFiller`.
        .with_nonce_management()
        .wallet(wallet)
        .on_http(rpc_url);

    // Build an EIP-1559 type transaction to send 100 wei to Vitalik.
    let vitalik = address!("d8dA6BF26964aF9D7eEd9e03E53415D37aA96045");
    let tx = TransactionRequest::default()
        .with_to(vitalik)
        .with_value(U256::from(100))
        // Notice that without the `GasFiller`, you need to set the gas related fields.
        .with_gas_limit(21_000)
        .with_max_fee_per_gas(20_000_000_000)
        .with_max_priority_fee_per_gas(1_000_000_000)
        // Notice that without the `ChainIdFiller`, you need to set the `chain_id` field.
        .with_chain_id(anvil.chain_id());

    // Send the transaction, the nonce (0) is automatically managed by the provider.
    let builder = provider.send_transaction(tx.clone()).await?;
    let node_hash = *builder.tx_hash();
    let pending_tx =
        provider.get_transaction_by_hash(node_hash).await?.expect("Transaction not found");
    assert_eq!(pending_tx.nonce, 0);

    println!("Transaction sent with nonce: {}", pending_tx.nonce);

    // Send the transaction, the nonce (1) is automatically managed by the provider.
    let builder = provider.send_transaction(tx).await?;
    let node_hash = *builder.tx_hash();
    let pending_tx =
        provider.get_transaction_by_hash(node_hash).await?.expect("Transaction not found");
    assert_eq!(pending_tx.nonce, 1);

    println!("Transaction sent with nonce: {}", pending_tx.nonce);

    Ok(())
}</code></pre>
<p>在 Github 上查看源代码 <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/fillers/examples/nonce_filler.rs">此处</a>.</p>
<!-- DO NOT EDIT THIS FILE. IT IS GENERATED BY RUNNING `./scripts/update.sh` -->
<!-- ANY CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN -->
<!-- EDIT OR CREATE THIS TEMPLATE INSTEAD: ./src/templates/fillers/wallet_filler.md -->
<!-- LATEST UPDATE: https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="示例-wallet_filler"><a class="header" href="#示例-wallet_filler">示例: <code>wallet_filler</code></a></h2>
<h3 id="示例-14"><a class="header" href="#示例-14">示例</a></h3>
<p>要运行此示例：</p>
<ul>
<li>克隆 <a href="https://github.com/alloy-rs/examples">examples</a> 仓库：<code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>运行：<code>cargo run --example wallet_filler</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example of using the `WalletFiller` in the provider.

use alloy::{
    network::{EthereumWallet, TransactionBuilder},
    node_bindings::Anvil,
    primitives::{address, b256, U256},
    providers::{Provider, ProviderBuilder},
    rpc::types::request::TransactionRequest,
    signers::local::PrivateKeySigner,
};
use eyre::Result;

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    // Spin up a local Anvil node.
    // Ensure `anvil` is available in $PATH.
    let anvil = Anvil::new().try_spawn()?;

    // Set up signer from the first default Anvil account (Alice).
    let signer: PrivateKeySigner = anvil.keys()[0].clone().into();
    let wallet = EthereumWallet::from(signer);

    // Create a provider with the wallet.
    let rpc_url = anvil.endpoint().parse()?;
    let provider = ProviderBuilder::new()
        // Add the `WalletFiller` to the provider
        .wallet(wallet)
        .on_http(rpc_url);

    // Build a legacy type transaction to send 100 wei to Vitalik.
    let vitalik = address!("d8dA6BF26964aF9D7eEd9e03E53415D37aA96045");
    let tx = TransactionRequest::default()
        .with_to(vitalik)
        .with_value(U256::from(100))
        // Notice that without the `NonceFiller`, you need to manually set the nonce field.
        .with_nonce(0)
        // Notice that without the `GasFiller`, you need to set the gas related fields.
        .with_gas_price(20_000_000_000)
        .with_gas_limit(21_000);

    let builder = provider.send_transaction(tx).await?;
    let node_hash = *builder.tx_hash();

    println!(
        "Node hash matches expected hash: {}",
        node_hash == b256!("eb56033eab0279c6e9b685a5ec55ea0ff8d06056b62b7f36974898d4fbb57e64")
    );

    // Send the transaction and wait for the broadcast.
    let pending_tx = builder.register().await?;

    println!("Pending transaction hash matches node hash: {}", *pending_tx.tx_hash() == node_hash);

    let tx_hash = pending_tx.await?;
    assert_eq!(tx_hash, node_hash);

    println!("Transaction hash matches node hash: {}", tx_hash == node_hash);

    // Wait for the transaction to be included and get the receipt.
    let receipt =
        provider.get_transaction_receipt(tx_hash).await?.expect("Transaction receipt not found");
    let receipt_hash = receipt.transaction_hash;
    assert_eq!(receipt_hash, node_hash);

    println!("Transaction receipt hash matches node hash: {}", receipt_hash == node_hash);

    Ok(())
}</code></pre>
<p>在 Github 上可以找到源代码 <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/fillers/examples/wallet_filler.rs">here</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="查询"><a class="header" href="#查询">查询</a></h2>
<!-- 请勿编辑此文件。它是通过运行 `./scripts/update.sh` 生成的 -->
<!-- 对此文件所做的任何更改都将被覆盖 -->
<!-- 请编辑或创建这个模板: ./src/templates/queries/query_contract_storage.md -->
<!-- 最新更新: https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="示例query_contract_storage"><a class="header" href="#示例query_contract_storage">示例：<code>query_contract_storage</code></a></h2>
<h3 id="示例-15"><a class="header" href="#示例-15">示例</a></h3>
<p>要运行此示例：</p>
<ul>
<li>克隆 <a href="https://github.com/alloy-rs/examples">examples</a> 仓库: <code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>运行: <code>cargo run --example query_contract_storage</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example of querying contract storage from the Ethereum network.

use alloy::{
    primitives::{address, U256},
    providers::{Provider, ProviderBuilder},
};
use eyre::Result;

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    // Create a provider.
    let rpc_url = "https://eth.merkle.io".parse()?;
    let provider = ProviderBuilder::new().on_http(rpc_url);

    // Get storage slot 0 from the Uniswap V3 USDC-ETH pool on Ethereum mainnet.
    let pool_address = address!("88e6A0c2dDD26FEEb64F039a2c41296FcB3f5640");
    let storage_slot = U256::from(0);
    // The provider calls the RPC at the latest block by default. A block can exlpicitly be set
    // using `.block()`.
    let storage = provider.get_storage_at(pool_address, storage_slot).await?;

    println!("Slot 0: {storage:?}");

    Ok(())
}</code></pre>
<p>在 Github 上查看源代码 <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/queries/examples/query_contract_storage.rs">此处</a>.</p>
<!-- DO NOT EDIT THIS FILE. IT IS GENERATED BY RUNNING `./scripts/update.sh` -->
<!-- ANY CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN -->
<!-- EDIT OR CREATE THIS TEMPLATE INSTEAD: ./src/templates/queries/query_deployed_bytecode.md -->
<!-- LATEST UPDATE: https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="示例query_deployed_bytecode"><a class="header" href="#示例query_deployed_bytecode">示例：<code>query_deployed_bytecode</code></a></h2>
<h3 id="示例-16"><a class="header" href="#示例-16">示例</a></h3>
<p>运行此示例:</p>
<ul>
<li>克隆 <a href="https://github.com/alloy-rs/examples">examples</a> 仓库: <code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>运行: <code>cargo run --example query_deployed_bytecode</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example of querying deployed bytecode of a contract on the Ethereum network.

use alloy::{
    primitives::address,
    providers::{Provider, ProviderBuilder},
};
use eyre::Result;

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    // Create a provider.
    let rpc_url = "https://eth.merkle.io".parse()?;
    let provider = ProviderBuilder::new().on_http(rpc_url);

    // Get the bytecode of the Uniswap V3 USDC-ETH pool on Ethereum mainnet.
    let pool_address = address!("88e6A0c2dDD26FEEb64F039a2c41296FcB3f5640");
    let bytecode = provider.get_code_at(pool_address).await?;

    println!("Bytecode: {bytecode:?}");

    Ok(())
}</code></pre>
<p>在 Github 上找到源代码 <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/queries/examples/query_deployed_bytecode.rs">here</a>.</p>
<!-- DO NOT EDIT THIS FILE. IT IS GENERATED BY RUNNING `./scripts/update.sh` -->
<!-- ANY CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN -->
<!-- EDIT OR CREATE THIS TEMPLATE INSTEAD: ./src/templates/queries/query_logs.md -->
<!-- LATEST UPDATE: https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="示例-query_logs"><a class="header" href="#示例-query_logs">示例: <code>query_logs</code></a></h2>
<h3 id="示例-17"><a class="header" href="#示例-17">示例</a></h3>
<p>要运行此示例：</p>
<ul>
<li>克隆 <a href="https://github.com/alloy-rs/examples">examples</a> 仓库: <code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>运行: <code>cargo run --example query_logs</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example of querying logs from the Ethereum network.

use alloy::{
    primitives::{address, b256},
    providers::{Provider, ProviderBuilder},
    rpc::types::Filter,
};
use eyre::Result;

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    // Create a provider.
    let rpc_url = "https://eth.merkle.io".parse()?;
    let provider = ProviderBuilder::new().on_http(rpc_url);

    // Get logs from the latest block
    let latest_block = provider.get_block_number().await?;

    // Create a filter to get all logs from the latest block.
    let filter = Filter::new().from_block(latest_block);

    // Get all logs from the latest block that match the filter.
    let logs = provider.get_logs(&amp;filter).await?;

    for log in logs {
        println!("{log:?}");
    }

    // Get all logs from the latest block that match the transfer event signature/topic.
    let transfer_event_signature =
        b256!("ddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef");
    let filter = Filter::new().event_signature(transfer_event_signature).from_block(latest_block);
    // You could also use the event name instead of the event signature like so:
    // .event("Transfer(address,address,uint256)")

    // Get all logs from the latest block that match the filter.
    let logs = provider.get_logs(&amp;filter).await?;

    for log in logs {
        println!("Transfer event: {log:?}");
    }

    // Get all logs from the latest block emitted by the UNI token address.
    let uniswap_token_address = address!("1f9840a85d5aF5bf1D1762F925BDADdC4201F984");
    let filter = Filter::new().address(uniswap_token_address).from_block(latest_block);

    // Get all logs from the latest block that match the filter.
    let logs = provider.get_logs(&amp;filter).await?;

    for log in logs {
        println!("Uniswap token logs: {log:?}");
    }

    Ok(())
}</code></pre>
<p>在 Github 上查看源代码 <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/queries/examples/query_logs.rs">here</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="交易"><a class="header" href="#交易">交易</a></h1>
<ul>
<li><a href="building-with-alloy/transactions/using-the-transaction-builder.html">使用交易构建器</a></li>
<li><a href="building-with-alloy/transactions/sending-an-EIP-1559-transaction.html">发送 EIP-1559 交易</a></li>
<li><a href="building-with-alloy/transactions/sending-a-legacy-transaction.html">发送传统交易</a></li>
<li><a href="building-with-alloy/transactions/sending-an-EIP-4844-transaction.html">发送 EIP-4844 交易</a></li>
<li><a href="building-with-alloy/transactions/using-access-lists.html">使用访问列表</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="使用-transactionbuilder"><a class="header" href="#使用-transactionbuilder">使用 <code>TransactionBuilder</code></a></h2>
<a href="https://docs.rs/alloy/latest/alloy/network/trait.TransactionBuilder.html" title="" target="_blank">
`TransactionBuilder`</a> 是一个用于特定网络的交易构建器，可通过 `.with_*` 方法进行配置。
<p>常见的可配置字段包括：</p>
<ul>
<li><a href="https://docs.rs/alloy/latest/alloy/network/trait.TransactionBuilder.html#method.with_from" title="" target="_blank">with_from</a></li>
<li><a href="https://docs.rs/alloy/latest/alloy/network/trait.TransactionBuilder.html#method.with_to" title="" target="_blank">with_to</a></li>
<li><a href="https://docs.rs/alloy/latest/alloy/network/trait.TransactionBuilder.html#method.with_nonce" title="" target="_blank">with_nonce</a></li>
<li><a href="https://docs.rs/alloy/latest/alloy/network/trait.TransactionBuilder.html#method.with_chain_id" title="" target="_blank">with_chain_id</a></li>
<li><a href="https://docs.rs/alloy/latest/alloy/network/trait.TransactionBuilder.html#method.with_value" title="" target="_blank">with_value</a></li>
<li><a href="https://docs.rs.alloy/latest/alloy/network/trait.TransactionBuilder.html#method.with_gas_limit" title="" target="_blank">with_gas_limit</a></li>
<li><a href="https://docs.rs/alloy/latest/alloy/network/trait.TransactionBuilder.html#method.with_max_priority_fee_per_gas" title="" target="_blank">with_max_priority_fee_per_gas</a></li>
<li><a href="https://docs.rs/alloy/latest/alloy/network/trait.TransactionBuilder.html#method.with_max_fee_per_blob_gas" title="" target="_blank">with_max_fee_per_gas</a></li>
</ul>
<p>通常推荐使用构建者模式，如下所示，而不是直接设置值（相比于 <code>set_to</code>，使用 <code>with_to</code>）。</p>
<pre><code class="language-rust ignore">//! 展示如何使用 `TransactionBuilder` 构建交易的示例

use alloy::{
    network::TransactionBuilder,
    node_bindings::Anvil,
    primitives::U256,
    providers::{Provider, ProviderBuilder},
    rpc::types::TransactionRequest,
};
use eyre::Result;

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    // Spin up a local Anvil node.
    // Ensure `anvil` is available in $PATH.
    let anvil = Anvil::new().try_spawn()?;

    // Create a provider.
    let rpc_url = anvil.endpoint().parse()?;
    let provider = ProviderBuilder::new().on_http(rpc_url);

    // Create two users, Alice and Bob.
    let alice = anvil.addresses()[0];
    let bob = anvil.addresses()[1];

    // Build a transaction to send 100 wei from Alice to Bob.
    // The `from` field is automatically filled to the first signer's address (Alice).
    let tx = TransactionRequest::default()
        .with_to(bob)
        .with_nonce(0)
        .with_chain_id(anvil.chain_id())
        .with_value(U256::from(100))
        .with_gas_limit(21_000)
        .with_max_priority_fee_per_gas(1_000_000_000)
        .with_max_fee_per_gas(20_000_000_000);

    // Send the transaction and wait for the broadcast.
    let pending_tx = provider.send_transaction(tx).await?;

    println!("Pending transaction... {}", pending_tx.tx_hash());

    // Wait for the transaction to be included and get the receipt.
    let receipt = pending_tx.get_receipt().await?;

    println!(
        "Transaction included in block {}",
        receipt.block_number.expect("Failed to get block number")
    );

    assert_eq!(receipt.from, alice);
    assert_eq!(receipt.to, Some(bob));

    Ok(())
}</code></pre>
<p>建议在 <a href="building-with-alloy/transactions/../connecting-to-a-blockchain/setting-up-a-provider.html">ProviderBuilder</a> 上使用 <code>.with_recommended_fillers()</code> 方法，该方法会自动为你<a href="building-with-alloy/transactions/../understanding-fillers.html">填充字段</a>。</p>
<!-- DO NOT EDIT THIS FILE. IT IS GENERATED BY RUNNING `./scripts/update.sh` -->
<!-- ANY CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN -->
<!-- EDIT OR CREATE THIS TEMPLATE INSTEAD: ./src/templates/fillers/recommended_fillers.md -->
<!-- LATEST UPDATE: https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="示例-recommended_fillers-1"><a class="header" href="#示例-recommended_fillers-1">示例: <code>recommended_fillers</code></a></h2>
<h3 id="示例-18"><a class="header" href="#示例-18">示例</a></h3>
<p>要运行这个示例:</p>
<ul>
<li>克隆 <a href="https://github.com/alloy-rs/examples">examples</a> 仓库: <code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>运行: <code>cargo run --example recommended_fillers</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example of using the `.with_recommended_fillers()` method in the provider.

use alloy::{
    network::{EthereumWallet, TransactionBuilder},
    node_bindings::Anvil,
    primitives::{address, U256},
    providers::{Provider, ProviderBuilder},
    rpc::types::request::TransactionRequest,
    signers::local::PrivateKeySigner,
};
use eyre::Result;

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    // Spin up a local Anvil node.
    // Ensure `anvil` is available in $PATH.
    let anvil = Anvil::new().try_spawn()?;

    // Set up signer from the first default Anvil account (Alice).
    let signer: PrivateKeySigner = anvil.keys()[0].clone().into();
    let wallet = EthereumWallet::from(signer);

    // Create a provider with the wallet.
    let rpc_url = anvil.endpoint().parse()?;
    let provider = ProviderBuilder::new()
        // Adds the `ChainIdFiller`, `GasFiller` and the `NonceFiller` layers.
        .with_recommended_fillers()
        .wallet(wallet)
        .on_http(rpc_url);

    // Build an EIP-1559 type transaction to send 100 wei to Vitalik.
    // Notice that the `nonce` field is set by the `NonceFiller`.
    // Notice that the gas related fields are set by the `GasFiller`.
    // Notice that the `chain_id` field is set by the `ChainIdFiller`.
    let vitalik = address!("d8dA6BF26964aF9D7eEd9e03E53415D37aA96045");
    let tx = TransactionRequest::default().with_to(vitalik).with_value(U256::from(100));

    // Send the transaction, the nonce (0) is automatically managed by the provider.
    let builder = provider.send_transaction(tx.clone()).await?;
    let node_hash = *builder.tx_hash();
    let pending_tx =
        provider.get_transaction_by_hash(node_hash).await?.expect("Pending transaction not found");
    assert_eq!(pending_tx.nonce, 0);

    println!("Transaction sent with nonce: {}", pending_tx.nonce);

    // Send the transaction, the nonce (1) is automatically managed by the provider.
    let builder = provider.send_transaction(tx).await?;
    let node_hash = *builder.tx_hash();
    let pending_tx =
        provider.get_transaction_by_hash(node_hash).await?.expect("Pending transaction not found");
    assert_eq!(pending_tx.nonce, 1);

    println!("Transaction sent with nonce: {}", pending_tx.nonce);

    Ok(())
}</code></pre>
<p>在 Github 上找到源代码 <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/fillers/examples/recommended_fillers.rs">here</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="发送-eip-1559-交易"><a class="header" href="#发送-eip-1559-交易">发送 EIP-1559 交易</a></h2>
<!-- DO NOT EDIT THIS FILE. IT IS GENERATED BY RUNNING `./scripts/update.sh` -->
<!-- ANY CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN -->
<!-- EDIT OR CREATE THIS TEMPLATE INSTEAD: ./src/templates/transactions/send_eip1559_transaction.md -->
<!-- LATEST UPDATE: https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="示例-send_eip1559_transaction"><a class="header" href="#示例-send_eip1559_transaction">示例: <code>send_eip1559_transaction</code></a></h2>
<h3 id="示例-19"><a class="header" href="#示例-19">示例</a></h3>
<p>要运行这个示例：</p>
<ul>
<li>克隆 <a href="https://github.com/alloy-rs/examples">examples</a> 仓库：<code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>运行：<code>cargo run --example send_eip1559_transaction</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example showing how to send an [EIP-1559](https://eips.ethereum.org/EIPS/eip-1559) transaction.

use alloy::{
    network::TransactionBuilder,
    node_bindings::Anvil,
    primitives::U256,
    providers::{Provider, ProviderBuilder},
    rpc::types::TransactionRequest,
};
use eyre::Result;

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    // Spin up a local Anvil node.
    // Ensure `anvil` is available in $PATH.
    let anvil = Anvil::new().try_spawn()?;

    // Create a provider.
    let rpc_url = anvil.endpoint().parse()?;
    let provider = ProviderBuilder::new().on_http(rpc_url);

    // Create two users, Alice and Bob.
    let alice = anvil.addresses()[0];
    let bob = anvil.addresses()[1];

    // Build a transaction to send 100 wei from Alice to Bob.
    // The `from` field is automatically filled to the first signer's address (Alice).
    let tx = TransactionRequest::default()
        .with_to(bob)
        .with_nonce(0)
        .with_chain_id(anvil.chain_id())
        .with_value(U256::from(100))
        .with_gas_limit(21_000)
        .with_max_priority_fee_per_gas(1_000_000_000)
        .with_max_fee_per_gas(20_000_000_000);

    // Send the transaction and wait for the broadcast.
    let pending_tx = provider.send_transaction(tx).await?;

    println!("Pending transaction... {}", pending_tx.tx_hash());

    // Wait for the transaction to be included and get the receipt.
    let receipt = pending_tx.get_receipt().await?;

    println!(
        "Transaction included in block {}",
        receipt.block_number.expect("Failed to get block number")
    );

    assert_eq!(receipt.from, alice);
    assert_eq!(receipt.to, Some(bob));

    Ok(())
}</code></pre>
<p>在 Github 上可以找到源代码 <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/transactions/examples/send_eip1559_transaction.rs">这里</a>。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="发送传统交易"><a class="header" href="#发送传统交易">发送传统交易</a></h2>
<!-- DO NOT EDIT THIS FILE. IT IS GENERATED BY RUNNING `./scripts/update.sh` -->
<!-- ANY CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN -->
<!-- EDIT OR CREATE THIS TEMPLATE INSTEAD: ./src/templates/transactions/send_legacy_transaction.md -->
<!-- LATEST UPDATE: https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="示例-send_legacy_transaction"><a class="header" href="#示例-send_legacy_transaction">示例: <code>send_legacy_transaction</code></a></h2>
<h3 id="示例-20"><a class="header" href="#示例-20">示例</a></h3>
<p>要运行此示例：</p>
<ul>
<li>克隆 <a href="https://github.com/alloy-rs/examples">examples</a> 仓库: <code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>运行: <code>cargo run --example send_legacy_transaction</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example showing how to send a legacy transaction.

use alloy::{
    network::TransactionBuilder,
    node_bindings::Anvil,
    primitives::U256,
    providers::{Provider, ProviderBuilder},
    rpc::types::TransactionRequest,
};
use eyre::Result;

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    // Spin up a local Anvil node.
    // Ensure `anvil` is available in $PATH.
    let anvil = Anvil::new().try_spawn()?;

    // Create a provider.
    let rpc_url = anvil.endpoint().parse()?;
    let provider = ProviderBuilder::new().on_http(rpc_url);

    // Create two users, Alice and Bob.
    let alice = anvil.addresses()[0];
    let bob = anvil.addresses()[1];

    // Build a transaction to send 100 wei from Alice to Bob.
    // The `from` field is automatically filled to the first signer's address (Alice).
    let tx = TransactionRequest::default()
        .with_to(bob)
        .with_nonce(0)
        .with_value(U256::from(100))
        .with_gas_price(20_000_000_000)
        .with_gas_limit(21_000);

    // Send the transaction and wait for the broadcast.
    let pending_tx = provider.send_transaction(tx).await?;

    println!("Pending transaction... {}", pending_tx.tx_hash());

    // Wait for the transaction to be included and get the receipt.
    let receipt = pending_tx.get_receipt().await?;

    println!(
        "Transaction included in block {}",
        receipt.block_number.expect("Failed to get block number")
    );

    assert_eq!(receipt.from, alice);
    assert_eq!(receipt.to, Some(bob));

    Ok(())
}</code></pre>
<p>在 Github 上查看源代码 <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/transactions/examples/send_legacy_transaction.rs">这里</a>。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="发送-eip-4844-交易"><a class="header" href="#发送-eip-4844-交易">发送 EIP-4844 交易</a></h2>
<!-- DO NOT EDIT THIS FILE. IT IS GENERATED BY RUNNING `./scripts/update.sh` -->
<!-- ANY CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN -->
<!-- EDIT OR CREATE THIS TEMPLATE INSTEAD: ./src/templates/transactions/send_eip4844_transaction.md -->
<!-- LATEST UPDATE: https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="示例-send_eip4844_transaction"><a class="header" href="#示例-send_eip4844_transaction">示例: <code>send_eip4844_transaction</code></a></h2>
<h3 id="示例-21"><a class="header" href="#示例-21">示例</a></h3>
<p>运行此示例:</p>
<ul>
<li>克隆 <a href="https://github.com/alloy-rs/examples">examples</a> 仓库: <code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>运行: <code>cargo run --example send_eip4844_transaction</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example showing how to send an [EIP-4844](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-4844.md) transaction.

use alloy::{
    consensus::{SidecarBuilder, SimpleCoder},
    eips::eip4844::DATA_GAS_PER_BLOB,
    network::TransactionBuilder,
    node_bindings::Anvil,
    providers::{Provider, ProviderBuilder},
    rpc::types::TransactionRequest,
};
use eyre::Result;

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    // Spin up a local Anvil node with the Cancun hardfork enabled.
    // Ensure `anvil` is available in $PATH.
    let anvil = Anvil::new().args(["--hardfork", "cancun"]).try_spawn()?;

    // Create a provider.
    let provider = ProviderBuilder::new().on_builtin(&amp;anvil.endpoint()).await?;

    // Create two users, Alice and Bob.
    let alice = anvil.addresses()[0];
    let bob = anvil.addresses()[1];

    // Create a sidecar with some data.
    let sidecar: SidecarBuilder&lt;SimpleCoder&gt; = SidecarBuilder::from_slice(b"Blobs are fun!");
    let sidecar = sidecar.build()?;

    // Build a transaction to send the sidecar from Alice to Bob.
    // The `from` field is automatically filled to the first signer's address (Alice).
    let gas_price = provider.get_gas_price().await?;
    let eip1559_est = provider.estimate_eip1559_fees(None).await?;
    let tx = TransactionRequest::default()
        .with_to(bob)
        .with_nonce(0)
        .with_max_fee_per_blob_gas(gas_price)
        .with_max_fee_per_gas(eip1559_est.max_fee_per_gas)
        .with_max_priority_fee_per_gas(eip1559_est.max_priority_fee_per_gas)
        .with_blob_sidecar(sidecar);

    // Send the transaction and wait for the broadcast.
    let pending_tx = provider.send_transaction(tx).await?;

    println!("Pending transaction... {}", pending_tx.tx_hash());

    // Wait for the transaction to be included and get the receipt.
    let receipt = pending_tx.get_receipt().await?;

    println!(
        "Transaction included in block {}",
        receipt.block_number.expect("Failed to get block number")
    );

    assert_eq!(receipt.from, alice);
    assert_eq!(receipt.to, Some(bob));
    assert_eq!(
        receipt.blob_gas_used.expect("Expected to be EIP-4844 transaction"),
        DATA_GAS_PER_BLOB as u128
    );

    Ok(())
}</code></pre>
<p>在 Github 上可以找到源码 <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/transactions/examples/send_eip4844_transaction.rs">这里</a>。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="使用访问列表"><a class="header" href="#使用访问列表">使用访问列表</a></h2>
<!-- DO NOT EDIT THIS FILE. IT IS GENERATED BY RUNNING `./scripts/update.sh` -->
<!-- ANY CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN -->
<!-- EDIT OR CREATE THIS TEMPLATE INSTEAD: ./src/templates/transactions/with_access_list.md -->
<!-- LATEST UPDATE: https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="示例-with_access_list"><a class="header" href="#示例-with_access_list">示例: <code>with_access_list</code></a></h2>
<h3 id="示例-22"><a class="header" href="#示例-22">示例</a></h3>
<p>运行本示例：</p>
<ul>
<li>克隆 <a href="https://github.com/alloy-rs/examples">examples</a> 仓库: <code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>运行: <code>cargo run --example with_access_list</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example of sending a EIP-1559 transaction with access list.

use alloy::{
    node_bindings::Anvil,
    providers::{Provider, ProviderBuilder},
    rpc::types::TransactionRequest,
    sol,
};
use eyre::Result;

// Codegen from artifact.
sol!(
    #[allow(missing_docs)]
    #[sol(rpc)]
    SimpleStorage,
    "examples/artifacts/SimpleStorage.json"
);

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    // Spin up a local Anvil node.
    // Ensure `anvil` is available in $PATH.
    let anvil = Anvil::new().try_spawn()?;

    // Create a provider.
    let provider =
        ProviderBuilder::new().with_recommended_fillers().on_builtin(&amp;anvil.endpoint()).await?;

    // Deploy the `SimpleStorage` contract.
    let alice = anvil.addresses()[0];
    let contract_address = SimpleStorage::deploy_builder(provider.clone(), "initial".to_string())
        .from(alice)
        .deploy()
        .await?;
    let contract = SimpleStorage::new(contract_address, provider.clone());

    // Build a transaction to set the values of the contract.
    // The `from` field is automatically filled to the first signer's address (Alice).
    let set_value_call = contract.setValues("hello".to_string(), "world".to_string());
    let calldata = set_value_call.calldata().to_owned();
    let bob = anvil.addresses()[1];
    let tx = TransactionRequest::default().from(bob).to(contract_address).input(calldata.into());

    // Create an access list for the transaction.
    let access_list_with_gas_used = provider.create_access_list(&amp;tx).await?;

    // Add the access list to the transaction.
    let tx_with_access_list = tx.access_list(access_list_with_gas_used.access_list);

    // Send the transaction with the access list.
    let tx_hash = provider.send_transaction(tx_with_access_list).await?.watch().await?;

    println!("Transaction hash: {tx_hash}");

    // Check the value of the contract.
    let value = contract.getValue().call().await?;

    assert_eq!(value._0, "hello".to_string());

    Ok(())
}</code></pre>
<p>在 Github 上查看源码 <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/transactions/examples/with_access_list.rs">here</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="sol-过程宏"><a class="header" href="#sol-过程宏"><code>sol!</code> 过程宏</a></h2>
<p><code>sol!</code> 过程宏解析 Solidity 语法以生成实现了 <a href="https://github.com/alloy-rs/core/tree/main/crates/sol-types" title="" target="_blank">alloy-sol-types</a> 特性的类型。它使用 <a href="https://github.com/alloy-rs/core/tree/main/crates/syn-solidity" title="" target="_blank">
<code>syn-solidity</code></a>，一个基于 <a href="https://github.com/dtolnay/syn" title="" target="_blank">syn</a> 的 Solidity 解析器。它旨在模仿官方 Solidity 编译器 (<code>solc</code>) 在解析有效 Solidity 代码时的行为。这意味着所有 <code>solc</code> <code>0.5.0</code> 及以上版本认可的有效 Solidity 代码都被支持。</p>
<p>在最基本的形式下，<code>sol!</code> 是这样使用的：</p>
<pre><code class="language-rust ignore">use alloy::{primitives::U256, sol};

// 用标准 Solidity 声明一个 Solidity 类型
sol! {
    struct Foo {
        uint256 bar;
        bool baz;
    }
}

// 一个对应的 Rust 结构体被生成了！

// pub struct Foo {
//     pub bar: Uint&lt;256, 4&gt;,
//     pub baz: bool,
// }

let foo = Foo { bar: U256::from(42), baz: true };</code></pre>
<h3 id="使用方法"><a class="header" href="#使用方法">使用方法</a></h3>
<p>有多种使用 <code>sol!</code> 宏的方法。</p>
<p>你可以直接编写 Solidity 代码：</p>
<pre><code class="language-rust ignore">sol! {
    contract Counter {
        uint256 public number;

        function setNumber(uint256 newNumber) public {
            number = newNumber;
        }

        function increment() public {
            number++;
        }
    }
}</code></pre>
<p>或者提供一个 Solidity 文件的路径：</p>
<pre><code class="language-rust ignore">sol!(
    #[sol(rpc)]
    Counter,
    "artifacts/Counter.json"
);</code></pre>
<p>另外，如果你启用了 <code>json</code> 特性标志，你可以提供一个 ABI，或者是一个 JSON 格式的路径：</p>
<pre><code class="language-rust ignore">sol!(
   ICounter,
   r#"[
        {
            "type": "function",
            "name": "increment",
            "inputs": [],
            "outputs": [],
            "stateMutability": "nonpayable"
        },
        {
            "type": "function",
            "name": "number",
            "inputs": [],
            "outputs": [
                {
                    "name": "",
                    "type": "uint256",
                    "internalType": "uint256"
                }
            ],
            "stateMutability": "view"
        },
        {
            "type": "function",
            "name": "setNumber",
            "inputs": [
                {
                    "name": "newNumber",
                    "type": "uint256",
                    "internalType": "uint256"
                }
            ],
            "outputs": [],
            "stateMutability": "nonpayable"
        }
   ]"#
);</code></pre>
<p>这与以下内容相同：</p>
<pre><code class="language-rust ignore">sol! {
    interface ICounter {
        uint256 public number;

        function setNumber(uint256 newNumber);

        function increment();
    }
}</code></pre>
<p>另外，你也可以通过文件加载一个 ABI：</p>
<pre><code class="language-rust ignore">sol!(
    ICounter,
    "abi/Counter.json"
);</code></pre>
<p>你也可以直接使用函数：</p>
<pre><code class="language-rust ignore">sol!(
    function swapExactTokensForTokens(
        uint256 amountIn,
        uint256 amountOutMin,
        address[] calldata path,
        address to,
        uint256 deadline
      ) external returns (uint256[] memory amounts);
);

println!("解码 https://etherscan.io/tx/0xd1b449d8b1552156957309bffb988924569de34fbf21b51e7af31070cc80fe9a");

let input = hex::decode("0x38ed173900000000000000000000000000000000000000000001a717cc0a3e4f84c00000000000000000000000000000000000000000000000000000000000000283568400000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000201f129111c60401630932d9f9811bd5b5fff34e000000000000000000000000000000000000000000000000000000006227723d000000000000000000000000000000000000000000000000000000000000000200000000000000000000000095ad61b0a150d79219dcf64e1e6cc01f0b64c4ce000000000000000000000000dac17f958d2ee523a2206206994597c13d831ec7")?;

// 使用生成的 `swapExactTokensForTokens` 绑定解码输入。
let decoded = swapExactTokensForTokensCall::abi_decode(&amp;input, false);</code></pre>
<h3 id="属性"><a class="header" href="#属性">属性</a></h3>
<p>结合 <code>sol!</code> 宏的 <code>#[sol(rpc)]</code> 属性，<a href="https://docs.rs/alloy/latest/alloy/contract/struct.CallBuilder.html" title="" target="_blank">
<code>CallBuilder</code></a> 可以用来与链上合约进行交互。<code>#[sol(rpc)]</code> 属性为合约中的每个函数生成一个方法，该方法返回该函数的 <code>CallBuilder</code>。</p>
<p>如果提供了 <code>#[sol(bytecode = "0x...")]</code>，合约可以通过 <code>Counter::deploy</code> 部署，并会创建一个新实例。</p>
<pre><code class="language-rust ignore">//! 示例展示如何使用 `#[sol(rpc)]` 和 #[sol(bytecode = "0x...")] 属性
//! interacting with it.

use alloy::{
    network::EthereumWallet, node_bindings::Anvil, primitives::U256, providers::ProviderBuilder,
    signers::local::PrivateKeySigner, sol,
};
use eyre::Result;

// Codegen from embedded Solidity code and precompiled bytecode.
sol! {
    #[allow(missing_docs)]
    // solc v0.8.26; solc Counter.sol --via-ir --optimize --bin
    #[sol(rpc, bytecode="6080806040523460135760df908160198239f35b600080fdfe6080806040526004361015601257600080fd5b60003560e01c9081633fb5c1cb1460925781638381f58a146079575063d09de08a14603c57600080fd5b3460745760003660031901126074576000546000198114605e57600101600055005b634e487b7160e01b600052601160045260246000fd5b600080fd5b3460745760003660031901126074576020906000548152f35b34607457602036600319011260745760043560005500fea2646970667358221220e978270883b7baed10810c4079c941512e93a7ba1cd1108c781d4bc738d9090564736f6c634300081a0033")]
    contract Counter {
        uint256 public number;

        function setNumber(uint256 newNumber) public {
            number = newNumber;
        }

        function increment() public {
            number++;
        }
    }
}

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    // Spin up a local Anvil node.
    // Ensure `anvil` is available in $PATH.
    let anvil = Anvil::new().try_spawn()?;

    // Set up signer from the first default Anvil account (Alice).
    let signer: PrivateKeySigner = anvil.keys()[0].clone().into();
    let wallet = EthereumWallet::from(signer);

    // Create a provider with the wallet.
    let rpc_url = anvil.endpoint().parse()?;
    let provider =
        ProviderBuilder::new().with_recommended_fillers().wallet(wallet).on_http(rpc_url);

    println!("Anvil running at `{}`", anvil.endpoint());

    // Deploy the `Counter` contract.
    let contract = Counter::deploy(&amp;provider).await?;

    println!("Deployed contract at address: {}", contract.address());

    let builder = contract.setNumber(U256::from(42));
    let tx_hash = builder.send().await?.watch().await?;

    println!("Set number to 42: {tx_hash}");

    // Increment the number to 43.
    let builder = contract.increment();
    let tx_hash = builder.send().await?.watch().await?;

    println!("Incremented number: {tx_hash}");

    // Retrieve the number, which should be 43.
    let builder = contract.number();
    let number = builder.call().await?.number.to_string();

    println!("Retrieved number: {number}");

    Ok(())
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="交易生命周期"><a class="header" href="#交易生命周期">交易生命周期</a></h2>
<p>本文将带你了解将 <code>100 wei</code> 从 <code>Alice</code> 发送到 <code>Bob</code> 的交易定义过程，签署交易并广播已签署的交易到以太坊网络。</p>
<p>让我们以<a href="https://docs.rs/alloy/latest/alloy/rpc/types/eth/struct.TransactionRequest.html" title="" target="_blank">
<code>TransactionRequest</code></a>的形式表达我们的意图:</p>
<pre><code class="language-rust ignore">// 构建一个从 Alice 发送 100 wei 到 Bob 的交易。
let tx = TransactionRequest::default()
    .with_from(alice)
    .with_to(bob)
    .with_nonce(nonce)
    .with_chain_id(chain_id)
    .with_value(U256::from(100))
    .with_gas_price(gas_price)
    .with_gas_limit(gas_limit);</code></pre>
<h3 id="设置"><a class="header" href="#设置">设置</a></h3>
<p>首先我们将设置我们的环境:</p>
<p>我们先定义本地以太坊节点 <a href="https://github.com/foundry-rs/foundry/tree/master/crates/anvil" title="" target="_blank">Anvil</a> 的 RPC URL。
如果你没有安装 <code>Anvil</code>，请参阅 <a href="https://github.com/foundry-rs/foundry" title="" target="_blank">Foundry</a> 的 <a href="https://book.getfoundry.sh/getting-started/installation" title="" target="_blank">安装指南</a>。</p>
<pre><code class="language-rust ignore">// 启动一个本地 Anvil 节点。
// 确保 `anvil` 在 $PATH 中可用。
let anvil = Anvil::new().try_spawn()?;

// 获取 RPC URL。
let rpc_url = anvil.endpoint().parse()?;</code></pre>
<pre><code class="language-rust ignore">// 或者你也可以使用 https://chainlist.org/ 上的任何有效 RPC URL。
let rpc_url = "https://eth.merkle.io".parse()?;</code></pre>
<p>接下来让我们为 Alice 定义一个 <code>signer</code>。默认情况下，<code>Anvil</code> 定义了一个助记词：“test test test test test test test test test test test junk”。确保不要在测试环境外使用这个助记词。我们将在 <a href="https://docs.rs/alloy/latest/alloy/network/struct.EthereumWallet.html" title="" target="_blank">
<code>EthereumWallet</code></a> 中注册这个 signer，以便在 <code>Provider</code> 中签署我们未来的交易。</p>
<p>派生这个助记词的第一个密钥给 Alice：</p>
<pre><code class="language-rust ignore">// 设置 signer 来自 Anvil 的第一个默认账户（Alice）。
let signer: PrivateKeySigner = anvil.keys()[0].clone().into();
let wallet = EthereumWallet::from(signer);</code></pre>
<p>接下来让我们获取用户 <code>Alice</code> 和 <code>Bob</code> 的地址：</p>
<pre><code class="language-rust ignore">// 创建两个用户，Alice 和 Bob。
let alice = anvil.addresses()[0];
let bob = anvil.addresses()[1];</code></pre>
<p>接下来我们可以使用 <a href="https://docs.rs/alloy/latest/alloy/providers/struct.ProviderBuilder.html" title="" target="_blank">
<code>ProviderBuilder</code></a> 来构建 <a href="https://docs.rs/alloy/latest/alloy/providers/trait.Provider.html" title="" target="_blank">
<code>Provider</code></a>。</p>
<pre><code class="language-rust ignore">// 使用钱包创建一个 provider。
let provider = ProviderBuilder::new()
    .with_recommended_fillers()
    .wallet(wallet)
    .on_http(rpc_url);</code></pre>
<p>注意我们在 <a href="highlights/../building-with-alloy/connecting-to-a-blockchain/setting-up-a-provider.html">ProviderBuilder</a> 上使用了 <code>.with_recommended_fillers()</code> 方法来自动<a href="highlights/../building-with-alloy/understanding-fillers.html">填充字段</a>。</p>
<p>让我们修改原来的 <code>TransactionRequest</code>，以便使用安装在 <code>Provider</code> 上的 <a href="https://docs.rs/alloy/latest/alloy/providers/fillers/type.RecommendedFiller.html" title="" target="_blank">RecommendedFiller</a> 自动填写交易详情。</p>
<p><code>RecommendedFillers</code> 包括以下填充器：</p>
<ul>
<li><a href="https://docs.rs/alloy/latest/alloy/providers/fillers/struct.GasFiller.html" title="" target="_blank">GasFiller</a></li>
<li><a href="https://docs.rs/alloy/latest/alloy/providers/fillers/struct.NonceFiller.html" title="" target="_blank">NonceFiller</a></li>
<li><a href="https://docs.rs/alloy/latest/alloy/providers/fillers/struct.ChainIdFiller.html" title="" target="_blank">ChainIdFiller</a></li>
</ul>
<p>因为我们使用了 <code>RecommendedFillers</code>，我们的 <code>TransactionRequest</code> 只需要使用原字段的子集：</p>
<pre><code class="language-diff">// 构建一个从 Alice 发送 100 wei 到 Bob 的交易。
let tx = TransactionRequest::default()
-   .with_from(alice)
    .with_to(bob)
-   .with_nonce(nonce)
-   .with_chain_id(chain_id)
    .with_value(U256::from(100))
-   .with_gas_price(gas_price)
-   .with_gas_limit(gas_limit);
</code></pre>
<p>变为：</p>
<pre><code class="language-rust ignore">// 构建一个从 Alice 发送 100 wei 到 Bob 的交易。
// `from` 字段自动填充为第一个 signer's 地址（Alice）。
let tx = TransactionRequest::default()
    .with_to(bob)
    .with_value(U256::from(100));</code></pre>
<p>好多啦！</p>
<h3 id="签署并广播交易"><a class="header" href="#签署并广播交易">签署并广播交易</a></h3>
<p>鉴于我们在 <code>Provider</code> 上配置了一个 signer，我们可以在本地签署交易并在一行中广播：</p>
<p>广播交易后有三种方法监听交易的包含，具体取决于你的需求：</p>
<pre><code class="language-rust ignore">// 发送交易并监听交易被广播。
let pending_tx = provider.send_transaction(tx).await?.register().await?;</code></pre>
<pre><code class="language-rust ignore">// 发送交易并监听交易被包含。
let tx_hash = provider.send_transaction(tx).await?.watch().await?;</code></pre>
<pre><code class="language-rust ignore">// 发送交易并在交易被包含后获取收据。
let tx_receipt = provider.send_transaction(tx).await?.get_receipt().await?;</code></pre>
<p>让我们深入了解我们刚刚做的事情。</p>
<p>通过调用：</p>
<pre><code class="language-rust ignore">let tx_builder = provider.send_transaction(tx).await?;</code></pre>
<a href="https://docs.rs/alloy/latest/alloy/providers/trait.Provider.html#method.send_transaction" title="" target="_blank">
`Provider::send_transaction`</a> 方法返回一个用于配置等待交易的 <a href="https://docs.rs/alloy/latest/alloy/providers/struct.PendingTransactionBuilder.html" title="" target="_blank">
`PendingTransactionBuilder`</a>。
<p>我们可以在它上面，例如，设置 <a href="https://docs.rs.alloy/latest/alloy/providers/struct.PendingTransactionBuilder.html#method.set_required_confirmations" title="" target="_blank">
<code>required_confirmations</code></a> 或者设置 <a href="https://docs.rs/alloy/latest/alloy/providers/struct.PendingTransactionBuilder.html#method.set_timeout" title="" target="_blank">
<code>timeout</code></a>：</p>
<pre><code class="language-rust ignore">// 配置等待交易。
let pending_tx_builder = provider.send_transaction(tx)
    .await?
    .with_required_confirmations(2)
    .with_timeout(Some(std::time::Duration::from_secs(60)));</code></pre>
<p>通过传递 <code>TransactionRequest</code>，我们填充任何缺失的字段。这涉及填写细节如 nonce、链 ID、gas 价格和 gas 限制：</p>
<pre><code class="language-diff">// 构建一个从 Alice 发送 100 wei 到 Bob 的交易。
let tx = TransactionRequest::default()
+   .with_from(alice)
    .with_to(bob)
+   .with_nonce(nonce)
+   .with_chain_id(chain_id)
    .with_value(U256::from(100))
+   .with_gas_price(gas_price)
+   .with_gas_limit(gas_limit);
</code></pre>
<p>作为 <code>Provider</code> 上注册的 <a href="https://docs.rs/alloy/latest/alloy/providers/fillers/trait.TxFiller.html#tymethod.fill" title="" target="_blank">钱包的 <code>fill</code> 方法</a> 的一部分，我们使用 Alice 的签名器从填充的 <code>TransactionRequest</code> 中构建一个已签名的交易。</p>
<p>此时，<code>TransactionRequest</code> 变成一个 <code>TransactionEnvelope</code>，准备发送到网络。通过调用 <a href="https://docs.rs/alloy/latest/alloy/providers/struct.PendingTransactionBuilder.html#method.register" title="" target="_blank">
<code>register</code></a>, <a href="https://docs.rs/alloy/latest/alloy/providers/struct.PendingTransactionBuilder.html#method.watch" title="" target="_blank">
<code>watch</code></a> 或 <a href="https://docs.rs/alloy/latest/alloy/providers/struct.PendingTransactionBuilder.html#method.get_receipt" title="" target="_blank">
<code>get_receipt</code></a>，我们可以广播交易并跟踪交易状态。</p>
<p>例如：</p>
<pre><code class="language-rust ignore">// 发送交易并在交易被包含后获取收据。
let tx_receipt = provider.send_transaction(tx).await?.get_receipt().await?;</code></pre>
<a href="https://docs.rs/alloy/latest/alloy/rpc/types/struct.TransactionReceipt.html" title="" target="_blank">
`TransactionReceipt`</a> 提供了交易的完整记录和结果，包括交易哈希、区块详情、使用的 gas 以及涉及的地址。
<pre><code class="language-rust ignore">pub struct TransactionReceipt {
    // ...

    /// 交易哈希。
    pub transaction_hash: TxHash,

    /// 在区块中的索引。
    pub transaction_index: Option&lt;TxIndex&gt;,

    /// 包含此交易的区块哈希。
    pub block_hash: Option&lt;BlockHash&gt;,

    /// 包含此交易的区块号。
    pub block_number: Option&lt;BlockNumber&gt;,

    /// 仅此交易使用的 gas。
    pub gas_used: u128,

    /// 发送者地址。
    pub from: Address,

    /// 接收者地址。如果是合约创建交易则为 None。
    pub to: Option&lt;Address&gt;,

    /// 创建的合约地址，若不是部署则为 None。
    pub contract_address: Option&lt;Address&gt;,

    // ...
}</code></pre>
<p>这就完成了广播已签署交易的旅程。一旦交易被包含在区块中，它就成为以太坊区块链的一个不可改变的部分，确保 <code>100 wei</code> 从 <code>Alice</code> 转移到 <code>Bob</code> 的记录永久存在。</p>
<h2 id="综合起来"><a class="header" href="#综合起来">综合起来</a></h2>
<pre><code class="language-rust ignore">//! Example of how to transfer ETH from one account to another.

use alloy::{
    network::{EthereumWallet, TransactionBuilder},
    node_bindings::Anvil,
    primitives::U256,
    providers::{Provider, ProviderBuilder},
    rpc::types::TransactionRequest,
    signers::local::PrivateKeySigner,
};
use eyre::Result;

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    // Spin up a local Anvil node.
    // Ensure `anvil` is available in $PATH.
    let anvil = Anvil::new().try_spawn()?;

    // Get the RPC URL.
    let rpc_url = anvil.endpoint().parse()?;

    // Set up signer from the first default Anvil account (Alice).
    let signer: PrivateKeySigner = anvil.keys()[0].clone().into();
    let wallet = EthereumWallet::from(signer);

    // Create a provider with the wallet.
    let provider =
        ProviderBuilder::new().with_recommended_fillers().wallet(wallet).on_http(rpc_url);

    // Build a transaction to send 100 wei from Alice to Bob.
    // The `from` field is automatically filled to the first signer's address (Alice).
    let bob = anvil.addresses()[1];
    let tx = TransactionRequest::default().with_to(bob).with_value(U256::from(100));

    // Send the transaction and listen for the transaction to be included.
    let tx_hash = provider.send_transaction(tx).await?.watch().await?;

    println!("Sent transaction: {tx_hash}");

    Ok(())
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="anvil"><a class="header" href="#anvil">Anvil</a></h2>
<ul>
<li><a href="examples/anvil/deploy_contract_anvil.html">部署合约</a></li>
<li><a href="examples/anvil/fork_anvil.html">分叉</a></li>
<li><a href="examples/anvil/local_anvil.html">本地</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><!-- DO NOT EDIT THIS FILE. IT IS GENERATED BY RUNNING `./scripts/update.sh` -->
<!-- ANY CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN -->
<!-- EDIT OR CREATE THIS TEMPLATE INSTEAD: ./src/templates/anvil/deploy_contract_anvil.md -->
<!-- LATEST UPDATE: https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="示例-deploy_contract_anvil"><a class="header" href="#示例-deploy_contract_anvil">示例: <code>deploy_contract_anvil</code></a></h2>
<h3 id="示例-23"><a class="header" href="#示例-23">示例</a></h3>
<p>要运行这个示例:</p>
<ul>
<li>克隆 <a href="https://github.com/alloy-rs/examples" title="" target="_blank">examples</a> 仓库: <code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>运行: <code>cargo run --example deploy_contract_anvil</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example of deploying a contract to Anvil and interacting with it.

use alloy::{
    network::EthereumWallet, node_bindings::Anvil, primitives::U256, providers::ProviderBuilder,
    signers::local::PrivateKeySigner, sol,
};
use eyre::Result;

// Codegen from embedded Solidity code and precompiled bytecode.
sol! {
    #[allow(missing_docs)]
    // solc v0.8.26; solc Counter.sol --via-ir --optimize --bin
    #[sol(rpc, bytecode="6080806040523460135760df908160198239f35b600080fdfe6080806040526004361015601257600080fd5b60003560e01c9081633fb5c1cb1460925781638381f58a146079575063d09de08a14603c57600080fd5b3460745760003660031901126074576000546000198114605e57600101600055005b634e487b7160e01b600052601160045260246000fd5b600080fd5b3460745760003660031901126074576020906000548152f35b34607457602036600319011260745760043560005500fea2646970667358221220e978270883b7baed10810c4079c941512e93a7ba1cd1108c781d4bc738d9090564736f6c634300081a0033")]
    contract Counter {
        uint256 public number;

        function setNumber(uint256 newNumber) public {
            number = newNumber;
        }

        function increment() public {
            number++;
        }
    }
}

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    // Spin up a local Anvil node.
    // Ensure `anvil` is available in $PATH.
    let anvil = Anvil::new().try_spawn()?;

    // Set up signer from the first default Anvil account (Alice).
    let signer: PrivateKeySigner = anvil.keys()[0].clone().into();
    let wallet = EthereumWallet::from(signer);

    // Create a provider with the wallet.
    let rpc_url = anvil.endpoint().parse()?;
    let provider =
        ProviderBuilder::new().with_recommended_fillers().wallet(wallet).on_http(rpc_url);

    println!("Anvil running at `{}`", anvil.endpoint());

    // Deploy the `Counter` contract.
    let contract = Counter::deploy(&amp;provider).await?;

    println!("Deployed contract at address: {}", contract.address());

    // Set the number to 42.
    let builder = contract.setNumber(U256::from(42));
    let tx_hash = builder.send().await?.watch().await?;

    println!("Set number to 42: {tx_hash}");

    // Increment the number to 43.
    let builder = contract.increment();
    let tx_hash = builder.send().await?.watch().await?;

    println!("Incremented number: {tx_hash}");

    // Retrieve the number, which should be 43.
    let builder = contract.number();
    let number = builder.call().await?.number.to_string();

    println!("Retrieved number: {number}");

    Ok(())
}</code></pre>
<p>可以在 Github 上的<a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/anvil/examples/deploy_contract_anvil.rs" title="" target="_blank">这里</a>找到源码。</p>
<div style="break-before: page; page-break-before: always;"></div><!-- DO NOT EDIT THIS FILE. IT IS GENERATED BY RUNNING `./scripts/update.sh` -->
<!-- ANY CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN -->
<!-- EDIT OR CREATE THIS TEMPLATE INSTEAD: ./src/templates/anvil/fork_anvil.md -->
<!-- LATEST UPDATE: https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="示例-fork_anvil"><a class="header" href="#示例-fork_anvil">示例: <code>fork_anvil</code></a></h2>
<h3 id="示例-24"><a class="header" href="#示例-24">示例</a></h3>
<p>要运行此示例：</p>
<ul>
<li>克隆<a href="https://github.com/alloy-rs/examples" title="" target="_blank">examples</a> 仓库: <code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>运行: <code>cargo run --example fork_anvil</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example of spinning up a forked Anvil node.

use alloy::node_bindings::Anvil;
use eyre::Result;

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    // Spin up a forked Anvil node.
    // Ensure `anvil` is available in $PATH.
    let anvil = Anvil::new().fork("https://eth.merkle.io").try_spawn()?;

    println!("Anvil running at `{}`", anvil.endpoint());

    Ok(())
}</code></pre>
<p>在 Github 上查看源代码<a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/anvil/examples/fork_anvil.rs" title="" target="_blank">这里</a>。</p>
<div style="break-before: page; page-break-before: always;"></div><!-- DO NOT EDIT THIS FILE. IT IS GENERATED BY RUNNING `./scripts/update.sh` -->
<!-- ANY CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN -->
<!-- EDIT OR CREATE THIS TEMPLATE INSTEAD: ./src/templates/anvil/local_anvil.md -->
<!-- LATEST UPDATE: https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="示例-local_anvil"><a class="header" href="#示例-local_anvil">示例: <code>local_anvil</code></a></h2>
<h3 id="示例-25"><a class="header" href="#示例-25">示例</a></h3>
<p>要运行此示例:</p>
<ul>
<li>克隆 <a href="https://github.com/alloy-rs/examples" title="" target="_blank">examples</a> 仓库: <code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>运行: <code>cargo run --example local_anvil</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example of spinning up a local Anvil node.

use alloy::node_bindings::Anvil;
use eyre::Result;

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    // Spin up a local Anvil node.
    // Ensure `anvil` is available in $PATH.
    let anvil = Anvil::new().block_time(1).chain_id(1337).try_spawn()?;

    println!("Anvil running at `{}`", anvil.endpoint());

    Ok(())
}</code></pre>
<p>在 Github 上可以找到源码 <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/anvil/examples/local_anvil.rs" title="" target="_blank">here</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="大数"><a class="header" href="#大数">大数</a></h2>
<ul>
<li><a href="examples/big-numbers/comparison_equivalence.html">比较和等价</a></li>
<li><a href="examples/big-numbers/conversion.html">类型转换</a></li>
<li><a href="examples/big-numbers/create_instances.html">实例创建</a></li>
<li><a href="examples/big-numbers/math_operations.html">数学运算</a></li>
<li><a href="examples/big-numbers/math_utilities.html">数学工具</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><!-- 请不要编辑此文件。它是通过运行 `./scripts/update.sh` 生成的 -->
<!-- 对此文件做的任何更改都会被覆盖 -->
<!-- 请改编辑或创建这个模板：./src/templates/big-numbers/comparison_equivalence.md -->
<!-- 最新更新： https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="示例comparison_equivalence-1"><a class="header" href="#示例comparison_equivalence-1">示例：<code>comparison_equivalence</code></a></h2>
<h3 id="示例-26"><a class="header" href="#示例-26">示例</a></h3>
<p>要运行此示例：</p>
<ul>
<li>克隆 <a href="https://github.com/alloy-rs/examples" title="" target="_blank">examples</a> 仓库：<code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>运行：<code>cargo run --example comparison_equivalence</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example of comparison and equivalence of `U256` instances.

use alloy::primitives::U256;

/// `U256` implements traits in `std::cmp`, that means `U256` instances
/// can be easily compared using standard Rust operators.
fn main() {
    // a == b
    let a = U256::from(100_u32);
    let b = U256::from(100_u32);
    assert!(a == b);

    // a &lt; b
    let a = U256::from(1_u32);
    let b = U256::from(100_u32);
    assert!(a &lt; b);

    // a &lt;= b
    let a = U256::from(100_u32);
    let b = U256::from(100_u32);
    assert!(a &lt;= b);

    // a &gt; b
    let a = U256::from(100_u32);
    let b = U256::from(1_u32);
    assert!(a &gt; b);

    // a &gt;= b
    let a = U256::from(100_u32);
    let b = U256::from(100_u32);
    assert!(a &gt;= b);

    // a == 0
    let a = U256::ZERO;
    assert!(a.is_zero());
}</code></pre>
<p>在 Github 上可以找到源码：<a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/big-numbers/examples/comparison_equivalence.rs" title="" target="_blank">这里</a>。</p>
<div style="break-before: page; page-break-before: always;"></div><!-- DO NOT EDIT THIS FILE. IT IS GENERATED BY RUNNING `./scripts/update.sh` -->
<!-- ANY CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN -->
<!-- EDIT OR CREATE THIS TEMPLATE INSTEAD: ./src/templates/big-numbers/conversion.md -->
<!-- LATEST UPDATE: https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="示例-conversion-1"><a class="header" href="#示例-conversion-1">示例: <code>conversion</code></a></h2>
<h3 id="示例-27"><a class="header" href="#示例-27">示例</a></h3>
<p>运行这个示例:</p>
<ul>
<li>克隆 <a href="https://github.com/alloy-rs/examples" title="" target="_blank">examples</a> 仓库: <code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>运行: <code>cargo run --example conversion</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example of converting `U256` to native Rust types.

use alloy::primitives::{utils::format_units, U256};
use eyre::Result;

/// `U256` provides useful conversion functions to enable transformation into native Rust types.
///
/// It is important to note that converting a big-number to a floating point type (such as a `f32`
/// or `f64`) can result in a loss of precision, since you cannot fit 256 bits of information into
/// 64 bits.
///
/// However, there may be cases where you want to perform conversions for presentation purposes.
/// For example, you may want to display a large number to the user in a more readable format.
fn main() -&gt; Result&lt;()&gt; {
    let num = U256::from(42_u8);

    let a: u128 = num.to::&lt;u128&gt;();
    assert_eq!(a, 42);

    let b: u64 = num.to::&lt;u64&gt;();
    assert_eq!(b, 42);

    let c: u32 = num.to::&lt;u32&gt;();
    assert_eq!(c, 42);

    let d: usize = num.to::&lt;usize&gt;();
    assert_eq!(d, 42);

    let e: String = num.to_string();
    assert_eq!(e, "42");

    let f: String = format_units(num, 4)?;
    assert_eq!(f, "0.0042");

    Ok(())
}</code></pre>
<p>在 Github 上找到源代码 <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/big-numbers/examples/conversion.rs" title="" target="_blank">here</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><!-- DO NOT EDIT THIS FILE. IT IS GENERATED BY RUNNING `./scripts/update.sh` -->
<!-- ANY CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN -->
<!-- EDIT OR CREATE THIS TEMPLATE INSTEAD: ./src/templates/big-numbers/create_instances.md -->
<!-- LATEST UPDATE: https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="示例-create_instances-1"><a class="header" href="#示例-create_instances-1">示例: <code>create_instances</code></a></h2>
<h3 id="例子-1"><a class="header" href="#例子-1">例子</a></h3>
<p>运行此示例：</p>
<ul>
<li>克隆 <a href="https://github.com/alloy-rs/examples" title="" target="_blank">examples</a> 仓库: <code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>运行: <code>cargo run --example create_instances</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example of creating instances of `U256` from strings and numbers.

use alloy::primitives::{
    utils::{parse_units, ParseUnits},
    U256,
};
use eyre::Result;
use std::str::FromStr;

fn main() -&gt; Result&lt;()&gt; {
    // From strings
    let a = U256::from_str("42")?;
    assert_eq!(a.to_string(), "42");

    let amount = "42";
    let units = 4;
    let b: ParseUnits = parse_units(amount, units)?;
    assert_eq!(b.to_string(), "420000");

    // From numbers
    let c = U256::from(42_u8);
    assert_eq!(c.to_string(), "42");

    let d = U256::from(42_u16);
    assert_eq!(d.to_string(), "42");

    let e = U256::from(42_u32);
    assert_eq!(e.to_string(), "42");

    let f = U256::from(42_u64);
    assert_eq!(f.to_string(), "42");

    let g = U256::from(42_u128);
    assert_eq!(g.to_string(), "42");

    let h = U256::from(0x2a);
    assert_eq!(h.to_string(), "42");

    let i = U256::from(42);
    assert_eq!(i.to_string(), "42");

    Ok(())
}</code></pre>
<p>在 Github 上查看源代码 <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/big-numbers/examples/create_instances.rs" title="" target="_blank">here</a>。</p>
<div style="break-before: page; page-break-before: always;"></div><!-- DO NOT EDIT THIS FILE. IT IS GENERATED BY RUNNING `./scripts/update.sh` -->
<!-- ANY CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN -->
<!-- EDIT OR CREATE THIS TEMPLATE INSTEAD: ./src/templates/big-numbers/math_operations.md -->
<!-- LATEST UPDATE: https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="示例-math_operations数学运算-1"><a class="header" href="#示例-math_operations数学运算-1">示例: <code>math_operations</code>（数学运算）</a></h2>
<h3 id="示例-28"><a class="header" href="#示例-28">示例</a></h3>
<p>要运行此示例：</p>
<ul>
<li>克隆 <a href="https://github.com/alloy-rs/examples" title="" target="_blank">examples</a> 仓库: <code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>运行: <code>cargo run --example math_operations</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example of performing arithmetic operations with `U256`.

use alloy::primitives::{utils::format_units, U256};
use eyre::Result;
use std::ops::{Div, Mul};

/// `U256` implements traits in `std::ops`, that means it supports arithmetic operations
/// using standard Rust operators `+`, `-`. `*`, `/`, `%`, along with additional utilities to
/// perform common mathematical tasks.
fn main() -&gt; Result&lt;()&gt; {
    let a = U256::from(10);
    let b = U256::from(2);

    // addition
    let sum = a + b;
    assert_eq!(sum, U256::from(12));

    // subtraction
    let difference = a - b;
    assert_eq!(difference, U256::from(8));

    // multiplication
    let product = a * b;
    assert_eq!(product, U256::from(20));

    // division
    let quotient = a / b;
    assert_eq!(quotient, U256::from(5));

    // modulo
    let remainder = a % b;
    assert_eq!(remainder, U256::ZERO); // equivalent to `U256::from(0)`

    // exponentiation
    let power = a.pow(b);
    assert_eq!(power, U256::from(100));

    // Multiply two 'ether' numbers:
    // Big numbers are integers, that can represent fixed point numbers.
    // For instance, 1 ether has 18 fixed
    // decimal places (1.000000000000000000), and its big number
    // representation is 10^18 = 1000000000000000000.
    // When we multiply such numbers we are summing up their exponents.
    // So if we multiply 10^18 * 10^18 we get 10^36, that is obviously incorrect.
    // In order to get the correct result we need to divide by 10^18.
    let eth1 = U256::from(10_000000000000000000_u128); // 10 ether
    let eth2 = U256::from(20_000000000000000000_u128); // 20 ether
    let base = U256::from(10).pow(U256::from(18));
    let mul = eth1.mul(eth2).div(base); // We also divide by 10^18
    let s: String = format_units(mul, "ether")?;
    assert_eq!(s, "200.000000000000000000"); // 200

    Ok(())
}</code></pre>
<p>在 Github 上找到源码 <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/big-numbers/examples/math_operations.rs" title="" target="_blank">here</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><!-- DO NOT EDIT THIS FILE. IT IS GENERATED BY RUNNING `./scripts/update.sh` -->
<!-- ANY CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN -->
<!-- EDIT OR CREATE THIS TEMPLATE INSTEAD: ./src/templates/big-numbers/math_utilities.md -->
<!-- LATEST UPDATE: https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="示例math_utilities-1"><a class="header" href="#示例math_utilities-1">示例：<code>math_utilities</code></a></h2>
<h3 id="示例-29"><a class="header" href="#示例-29">示例</a></h3>
<p>运行此示例：</p>
<ul>
<li>克隆 <a href="https://github.com/alloy-rs/examples" title="" target="_blank">examples</a> 仓库：<code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>运行：<code>cargo run --example math_utilities</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example of using math utilities to handle big numbers in 'wei' units.

use alloy::primitives::{
    utils::{format_units, parse_units},
    U256,
};
use eyre::Result;

fn main() -&gt; Result&lt;()&gt; {
    parse_units_example()?;
    format_units_example()?;

    Ok(())
}

/// dApps business logics handle big numbers in 'wei' units (i.e. sending transactions, on-chain
/// math, etc.). We provide convenient methods to map user inputs (usually in 'ether' or 'gwei')
/// into 'wei' format.
fn parse_units_example() -&gt; Result&lt;()&gt; {
    let pu = parse_units("1.0", "wei")?;
    let num: U256 = pu.into();
    assert_eq!(num, U256::from(1));

    let pu = parse_units("1.0", "kwei")?;
    let num: U256 = pu.into();
    assert_eq!(num, U256::from(1000));

    let pu = parse_units("1.0", "mwei")?;
    let num: U256 = pu.into();
    assert_eq!(num, U256::from(1000000));

    let pu = parse_units("1.0", "gwei")?;
    let num: U256 = pu.into();
    assert_eq!(num, U256::from(1000000000));

    let pu = parse_units("1.0", "szabo")?;
    let num: U256 = pu.into();
    assert_eq!(num, U256::from(1000000000000_u128));

    let pu = parse_units("1.0", "finney")?;
    let num: U256 = pu.into();
    assert_eq!(num, U256::from(1000000000000000_u128));

    let pu = parse_units("1.0", "ether")?;
    let num: U256 = pu.into();
    assert_eq!(num, U256::from(1000000000000000000_u128));

    let pu = parse_units("1.0", 18)?;
    let num: U256 = pu.into();
    assert_eq!(num, U256::from(1000000000000000000_u128));

    Ok(())
}

/// dApps business logics handle big numbers in 'wei' units (i.e. sending transactions, on-chain
/// math, etc.). On the other hand it is useful to convert big numbers into user readable formats
/// when displaying on a UI. Generally dApps display numbers in 'ether' and 'gwei' units,
/// respectively for displaying amounts and gas. The `format_units` function will format a big
/// number into a user readable string.
fn format_units_example() -&gt; Result&lt;()&gt; {
    // 1 ETHER = 10^18 WEI
    let one_ether = U256::from(1000000000000000000_u128);

    let num: String = format_units(one_ether, "wei")?;
    assert_eq!(num, "1000000000000000000.0");

    let num: String = format_units(one_ether, "gwei")?;
    assert_eq!(num, "1000000000.000000000");

    let num: String = format_units(one_ether, "ether")?;
    assert_eq!(num, "1.000000000000000000");

    // 1 GWEI = 10^9 WEI
    let one_gwei = U256::from(1000000000_u128);

    let num: String = format_units(one_gwei, 0)?;
    assert_eq!(num, "1000000000.0");

    let num: String = format_units(one_gwei, "wei")?;
    assert_eq!(num, "1000000000.0");

    let num: String = format_units(one_gwei, "kwei")?;
    assert_eq!(num, "1000000.000");

    let num: String = format_units(one_gwei, "mwei")?;
    assert_eq!(num, "1000.000000");

    let num: String = format_units(one_gwei, "gwei")?;
    assert_eq!(num, "1.000000000");

    let num: String = format_units(one_gwei, "szabo")?;
    assert_eq!(num, "0.001000000000");

    let num: String = format_units(one_gwei, "finney")?;
    assert_eq!(num, "0.000001000000000");

    let num: String = format_units(one_gwei, "ether")?;
    assert_eq!(num, "0.000000001000000000");

    Ok(())
}</code></pre>
<p>在 Github 上找到源代码 <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/big-numbers/examples/math_utilities.rs" title="" target="_blank">here</a>。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="合约"><a class="header" href="#合约">合约</a></h2>
<ul>
<li><a href="examples/contracts/deploy_from_artifact.html">从 artifact 部署</a></li>
<li><a href="examples/contracts/deploy_from_bytecode.html">从字节码部署</a></li>
<li><a href="examples/contracts/deploy_from_contract.html">从合约部署</a></li>
<li><a href="examples/contracts/interact_with_abi.html">与 ABI 交互</a></li>
<li><a href="examples/contracts/interact_with_contract_instance.html">与合约实例交互</a></li>
<li><a href="examples/contracts/unknown_return_types.html">处理未知返回类型</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><!-- DO NOT EDIT THIS FILE. IT IS GENERATED BY RUNNING `./scripts/update.sh` -->
<!-- ANY CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN -->
<!-- EDIT OR CREATE THIS TEMPLATE INSTEAD: ./src/templates/contracts/deploy_from_artifact.md -->
<!-- LATEST UPDATE: https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="示例-deploy_from_artifact"><a class="header" href="#示例-deploy_from_artifact">示例: <code>deploy_from_artifact</code></a></h2>
<h3 id="示例-30"><a class="header" href="#示例-30">示例</a></h3>
<p>运行此示例:</p>
<ul>
<li>克隆 <a href="https://github.com/alloy-rs/examples" title="" target="_blank">examples</a> 仓库: <code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>运行: <code>cargo run --example deploy_from_artifact</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example of deploying a contract from an artifact using the `sol!` macro to Anvil and interacting
//! with it.

use alloy::{
    network::EthereumWallet, node_bindings::Anvil, primitives::U256, providers::ProviderBuilder,
    signers::local::PrivateKeySigner, sol,
};
use eyre::Result;

// Codegen from artifact.
sol!(
    #[allow(missing_docs)]
    #[sol(rpc)]
    Counter,
    "examples/artifacts/Counter.json"
);

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    // Spin up a local Anvil node.
    // Ensure `anvil` is available in $PATH.
    let anvil = Anvil::new().try_spawn()?;

    // Set up signer from the first default Anvil account (Alice).
    let signer: PrivateKeySigner = anvil.keys()[0].clone().into();
    let wallet = EthereumWallet::from(signer);

    // Create a provider with the wallet.
    let rpc_url = anvil.endpoint().parse()?;
    let provider =
        ProviderBuilder::new().with_recommended_fillers().wallet(wallet).on_http(rpc_url);

    println!("Anvil running at `{}`", anvil.endpoint());

    // Deploy the `Counter` contract.
    let contract = Counter::deploy(&amp;provider).await?;

    println!("Deployed contract at address: {}", contract.address());

    // Set the number to 42.
    let builder = contract.setNumber(U256::from(42));
    let tx_hash = builder.send().await?.watch().await?;

    println!("Set number to 42: {tx_hash}");

    // Increment the number to 43.
    let builder = contract.increment();
    let tx_hash = builder.send().await?.watch().await?;

    println!("Incremented number: {tx_hash}");

    // Retrieve the number, which should be 43.
    let builder = contract.number();

    // Note: because the artifact generated by `solc` does not include named return values it is
    // not possible to derive the return value name `number` from the artifact. This means that the
    // return value must be accessed by index - as if it is an unnamed value.
    // If you prefer to use named return values, it is recommended to embed the Solidity code
    // directly in the `sol!` macro as shown in `deploy_from_contract.rs`.
    let number = builder.call().await?._0;

    println!("Retrieved number: {number}");

    Ok(())
}</code></pre>
<p>在 Github 上查找源代码 <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/contracts/examples/deploy_from_artifact.rs" title="" target="_blank">这里</a>。</p>
<div style="break-before: page; page-break-before: always;"></div><!-- DO NOT EDIT THIS FILE. IT IS GENERATED BY RUNNING `./scripts/update.sh` -->
<!-- ANY CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN -->
<!-- EDIT OR CREATE THIS TEMPLATE INSTEAD: ./src/templates/contracts/deploy_from_bytecode.md -->
<!-- LATEST UPDATE: https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="示例-deploy_from_bytecode"><a class="header" href="#示例-deploy_from_bytecode">示例: <code>deploy_from_bytecode</code></a></h2>
<h3 id="示例-31"><a class="header" href="#示例-31">示例</a></h3>
<p>运行这个示例:</p>
<ul>
<li>克隆这个 <a href="https://github.com/alloy-rs/examples" title="" target="_blank">示例</a> 仓库: <code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>运行: <code>cargo run --example deploy_from_bytecode</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example of deploying a contract at runtime from Solidity bytecode to Anvil and interacting with
//! it.

use alloy::{
    hex,
    network::{EthereumWallet, ReceiptResponse, TransactionBuilder},
    node_bindings::Anvil,
    primitives::U256,
    providers::{Provider, ProviderBuilder},
    rpc::types::TransactionRequest,
    signers::local::PrivateKeySigner,
    sol,
};
use eyre::Result;

// If you have the bytecode known at build time, use the `deploy_from_contract` example.
// This method benefits from using bytecode at runtime, e.g., from newly deployed contracts, to
// analyze the behavior.
sol! {
    #[allow(missing_docs)]
    #[sol(rpc)]
    contract Counter {
        uint256 public number;

        function setNumber(uint256 newNumber) public {
            number = newNumber;
        }

        function increment() public {
            number++;
        }
    }
}

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    // Spin up a local Anvil node.
    // Ensure `anvil` is available in $PATH.
    let anvil = Anvil::new().try_spawn()?;

    // Set up signer from the first default Anvil account (Alice).
    let signer: PrivateKeySigner = anvil.keys()[0].clone().into();
    let wallet = EthereumWallet::from(signer);

    println!("Anvil running at `{}`", anvil.endpoint());

    // Create a provider with the wallet.
    let rpc_url = anvil.endpoint().parse()?;
    let provider =
        ProviderBuilder::new().with_recommended_fillers().wallet(wallet).on_http(rpc_url);

    // Deploy the `Counter` contract from bytecode at runtime.
    let bytecode = hex::decode(
        // solc v0.8.26; solc Counter.sol --via-ir --optimize --bin
        "6080806040523460135760df908160198239f35b600080fdfe6080806040526004361015601257600080fd5b60003560e01c9081633fb5c1cb1460925781638381f58a146079575063d09de08a14603c57600080fd5b3460745760003660031901126074576000546000198114605e57600101600055005b634e487b7160e01b600052601160045260246000fd5b600080fd5b3460745760003660031901126074576020906000548152f35b34607457602036600319011260745760043560005500fea2646970667358221220e978270883b7baed10810c4079c941512e93a7ba1cd1108c781d4bc738d9090564736f6c634300081a0033"
    )?;
    let tx = TransactionRequest::default().with_deploy_code(bytecode);

    // Deploy the contract.
    let receipt = provider.send_transaction(tx).await?.get_receipt().await?;

    let contract_address = receipt.contract_address().expect("Failed to get contract address");
    let contract = Counter::new(contract_address, &amp;provider);
    println!("Deployed contract at address: {}", contract.address());

    // Set number
    let builder = contract.setNumber(U256::from(42));
    let tx_hash = builder.send().await?.watch().await?;

    println!("Set number to 42: {tx_hash}");

    // Increment the number to 43.
    let builder = contract.increment();
    let tx_hash = builder.send().await?.watch().await?;

    println!("Incremented number: {tx_hash}");

    // Retrieve the number, which should be 43.
    let builder = contract.number();
    let number = builder.call().await?.number.to_string();

    println!("Retrieved number: {number}");

    Ok(())
}</code></pre>
<p>在 Github 上查找源代码 <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/contracts/examples/deploy_from_bytecode.rs" title="" target="_blank">这里</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><!-- 请勿编辑此文件。它是通过运行 `./scripts/update.sh` 自动生成的 -->
<!-- 对该文件的任何更改都将被覆盖 -->
<!-- 请编辑或创建该模板：./src/templates/contracts/deploy_from_contract.md -->
<!-- 最新更新：https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="示例-deploy_from_contract"><a class="header" href="#示例-deploy_from_contract">示例: <code>deploy_from_contract</code></a></h2>
<h3 id="示例-32"><a class="header" href="#示例-32">示例</a></h3>
<p>要运行此示例：</p>
<ul>
<li>克隆 <a href="https://github.com/alloy-rs/examples" title="" target="_blank">examples</a> 仓库: <code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>运行: <code>cargo run --example deploy_from_contract</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example of deploying a contract from Solidity code using the `sol!` macro to Anvil and
//! interacting with it.

use alloy::{
    network::EthereumWallet, node_bindings::Anvil, primitives::U256, providers::ProviderBuilder,
    signers::local::PrivateKeySigner, sol,
};
use eyre::Result;

// Codegen from embedded Solidity code and precompiled bytecode.
sol! {
    #[allow(missing_docs)]
    // solc v0.8.26; solc Counter.sol --via-ir --optimize --bin
    #[sol(rpc, bytecode="6080806040523460135760df908160198239f35b600080fdfe6080806040526004361015601257600080fd5b60003560e01c9081633fb5c1cb1460925781638381f58a146079575063d09de08a14603c57600080fd5b3460745760003660031901126074576000546000198114605e57600101600055005b634e487b7160e01b600052601160045260246000fd5b600080fd5b3460745760003660031901126074576020906000548152f35b34607457602036600319011260745760043560005500fea2646970667358221220e978270883b7baed10810c4079c941512e93a7ba1cd1108c781d4bc738d9090564736f6c634300081a0033")]
    contract Counter {
        uint256 public number;

        function setNumber(uint256 newNumber) public {
            number = newNumber;
        }

        function increment() public {
            number++;
        }
    }
}

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    // Spin up a local Anvil node.
    // Ensure `anvil` is available in $PATH.
    let anvil = Anvil::new().try_spawn()?;

    // Set up signer from the first default Anvil account (Alice).
    let signer: PrivateKeySigner = anvil.keys()[0].clone().into();
    let wallet = EthereumWallet::from(signer);

    // Create a provider with the wallet.
    let rpc_url = anvil.endpoint().parse()?;
    let provider =
        ProviderBuilder::new().with_recommended_fillers().wallet(wallet).on_http(rpc_url);

    println!("Anvil running at `{}`", anvil.endpoint());

    // Deploy the `Counter` contract.
    let contract = Counter::deploy(&amp;provider).await?;

    println!("Deployed contract at address: {}", contract.address());

    let builder = contract.setNumber(U256::from(42));
    let tx_hash = builder.send().await?.watch().await?;

    println!("Set number to 42: {tx_hash}");

    // Increment the number to 43.
    let builder = contract.increment();
    let tx_hash = builder.send().await?.watch().await?;

    println!("Incremented number: {tx_hash}");

    // Retrieve the number, which should be 43.
    let builder = contract.number();
    let number = builder.call().await?.number.to_string();

    println!("Retrieved number: {number}");

    Ok(())
}</code></pre>
<p>在 Github 上可以找到源代码 <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/contracts/examples/deploy_from_contract.rs" title="" target="_blank">here</a>。</p>
<div style="break-before: page; page-break-before: always;"></div><!-- DO NOT EDIT THIS FILE. IT IS GENERATED BY RUNNING `./scripts/update.sh` -->
<!-- ANY CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN -->
<!-- EDIT OR CREATE THIS TEMPLATE INSTEAD: ./src/templates/contracts/interact_with_abi.md -->
<!-- LATEST UPDATE: https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="示例-interact_with_abi"><a class="header" href="#示例-interact_with_abi">示例: <code>interact_with_abi</code></a></h2>
<h3 id="示例-33"><a class="header" href="#示例-33">示例</a></h3>
<p>要运行这个示例:</p>
<ul>
<li>克隆 <a href="https://github.com/alloy-rs/examples" title="" target="_blank">examples</a> 仓库: <code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>运行: <code>cargo run --example interact_with_abi</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example of generating code from ABI file using the `sol!` macro to interact with the contract.

use alloy::{node_bindings::Anvil, providers::ProviderBuilder, sol};
use eyre::Result;

// Codegen from ABI file to interact with the contract.
sol!(
    #[allow(missing_docs)]
    #[sol(rpc)]
    IWETH9,
    "examples/abi/IWETH9.json"
);

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    // Spin up a forked Anvil node.
    // Ensure `anvil` is available in $PATH.
    let anvil = Anvil::new().fork("https://eth.merkle.io").try_spawn()?;

    // Create a provider.
    let rpc_url = anvil.endpoint().parse()?;
    let provider = ProviderBuilder::new().on_http(rpc_url);

    // Create a contract instance.
    let contract = IWETH9::new("0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2".parse()?, provider);

    // Call the contract, retrieve the total supply.
    let IWETH9::totalSupplyReturn { _0 } = contract.totalSupply().call().await?;

    println!("WETH total supply is {_0}");

    Ok(())
}</code></pre>
<p>在 Github 上找到源代码 <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/contracts/examples/interact_with_abi.rs" title="" target="_blank">here</a>。</p>
<div style="break-before: page; page-break-before: always;"></div><!-- DO NOT EDIT THIS FILE. IT IS GENERATED BY RUNNING `./scripts/update.sh` -->
<!-- ANY CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN -->
<!-- EDIT OR CREATE THIS TEMPLATE INSTEAD: ./src/templates/contracts/interact_with_contract_instance.md -->
<!-- LATEST UPDATE: https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="示例-interact_with_contract_instance"><a class="header" href="#示例-interact_with_contract_instance">示例: <code>interact_with_contract_instance</code></a></h2>
<h3 id="示例-34"><a class="header" href="#示例-34">示例</a></h3>
<p>要运行这个示例：</p>
<ul>
<li>克隆 <a href="https://github.com/alloy-rs/examples" title="" target="_blank">examples</a> 代码库: <code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>运行: <code>cargo run --example interact_with_contract_instance</code></li>
</ul>
<pre><code class="language-rust ignore">//! This example demonstrates how to interact with a contract that is already deployed onchain using
//! the `ContractInstance` interface.

use alloy::{
    contract::{ContractInstance, Interface},
    dyn_abi::DynSolValue,
    network::{Ethereum, TransactionBuilder},
    primitives::{hex, U256},
    providers::{Provider, ProviderBuilder},
    rpc::types::TransactionRequest,
    transports::http::{Client, Http},
};
use eyre::Result;

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    let provider = ProviderBuilder::new().with_recommended_fillers().on_anvil_with_wallet();

    // Deploy the `Counter` contract from bytecode at runtime.
    let bytecode = hex::decode(
        // solc v0.8.26; solc Counter.sol --via-ir --optimize --bin
        //
        // contract Counter {
        //     uint256 public number;
        //
        //     function setNumber(uint256 newNumber) public {
        //         number = newNumber;
        //     }
        //
        //     function increment() public {
        //         number++;
        //     }
        // }
        "6080806040523460135760df908160198239f35b600080fdfe6080806040526004361015601257600080fd5b60003560e01c9081633fb5c1cb1460925781638381f58a146079575063d09de08a14603c57600080fd5b3460745760003660031901126074576000546000198114605e57600101600055005b634e487b7160e01b600052601160045260246000fd5b600080fd5b3460745760003660031901126074576020906000548152f35b34607457602036600319011260745760043560005500fea2646970667358221220e978270883b7baed10810c4079c941512e93a7ba1cd1108c781d4bc738d9090564736f6c634300081a0033"
    )?;
    let tx = TransactionRequest::default().with_deploy_code(bytecode);

    let contract_address = provider
        .send_transaction(tx)
        .await?
        .get_receipt()
        .await?
        .contract_address
        .expect("Failed to get contract address");

    // Get the contract ABI.
    let path = std::env::current_dir()?.join("examples/contracts/examples/artifacts/Counter.json");

    // Read the artifact which contains `abi`, `bytecode`, `deployedBytecode` and `metadata`.
    let artifact = std::fs::read(path).expect("Failed to read artifact");
    let json: serde_json::Value = serde_json::from_slice(&amp;artifact)?;

    // Get `abi` from the artifact.
    let abi_value = json.get("abi").expect("Failed to get ABI from artifact");
    let abi = serde_json::from_str(&amp;abi_value.to_string())?;

    // Create a new `ContractInstance` of the `Counter` contract from the abi
    let contract: ContractInstance&lt;Http&lt;Client&gt;, _, Ethereum&gt; =
        ContractInstance::new(contract_address, provider.clone(), Interface::new(abi));

    // Set the number to 42.
    let number_value = DynSolValue::from(U256::from(42));
    let tx_hash = contract.function("setNumber", &amp;[number_value])?.send().await?.watch().await?;

    println!("Set number to 42: {tx_hash}");

    // Increment the number to 43.
    let tx_hash = contract.function("increment", &amp;[])?.send().await?.watch().await?;

    println!("Incremented number: {tx_hash}");

    // Retrieve the number, which should be 43.
    let number_value = contract.function("number", &amp;[])?.call().await?;
    let number = number_value.first().unwrap().as_uint().unwrap().0;
    assert_eq!(U256::from(43), number);

    println!("Retrieved number: {number}");

    // Try calling a function that does not exist
    let unknown_function = contract.function("decrement", &amp;[]).unwrap_err();
    assert!(unknown_function.to_string().contains("function decrement does not exist"));

    Ok(())
}</code></pre>
<p>在 Github 上查看源代码 <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/contracts/examples/interact_with_contract_instance.rs" title="" target="_blank">这里</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><!-- DO NOT EDIT THIS FILE. IT IS GENERATED BY RUNNING `./scripts/update.sh` -->
<!-- ANY CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN -->
<!-- EDIT OR CREATE THIS TEMPLATE INSTEAD: ./src/templates/contracts/unknown_return_types.md -->
<!-- LATEST UPDATE: https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="示例unknown_return_types"><a class="header" href="#示例unknown_return_types">示例：<code>unknown_return_types</code></a></h2>
<h3 id="示例-35"><a class="header" href="#示例-35">示例</a></h3>
<p>运行此示例：</p>
<ul>
<li>克隆 <a href="https://github.com/alloy-rs/examples" title="" target="_blank">examples</a> 仓库：<code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>运行：<code>cargo run --example unknown_return_types</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example demonstrating how one can handle unknown / complex return types using `DynSol`.

use alloy::{
    contract::{ContractInstance, Interface},
    dyn_abi::DynSolValue,
    json_abi::JsonAbi,
    network::{Ethereum, TransactionBuilder},
    primitives::{hex, U256},
    providers::{Provider, ProviderBuilder},
    rpc::types::TransactionRequest,
    transports::http::{Client, Http},
};
use eyre::Result;

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    let provider = ProviderBuilder::new().with_recommended_fillers().on_anvil_with_wallet();

    let from = provider.get_accounts().await?[0];

    let bytecode = hex::decode(
        // contract Colors {
        //     struct Color {
        //         uint8 r;
        //         uint8 g;
        //         uint8 b;
        //     }
        //
        //     mapping(address =&gt; Color) public colors;
        //
        //     function setColor(uint8 r, uint8 g, uint8 b) public {
        //         colors[msg.sender] = Color(r, g, b);
        //     }
        //
        //     function getColor(address user) public view returns (Color memory) {
        //         return colors[user];
        //     }
        //
        //     function getColorAsTuple(
        //         address user
        //     ) public view returns (uint8, uint8, uint8) {
        //         return (colors[user].r, colors[user].g, colors[user].b);
        //     }
        // }
        "6080604052348015600f57600080fd5b506105fb8061001f6000396000f3fe608060405234801561001057600080fd5b506004361061004c5760003560e01c8063610c76f01461005157806384b5e5961461006d57806399efff171461009d578063befdb4f6146100cf575b600080fd5b61006b60048036038101906100669190610435565b610101565b005b610087600480360381019061008291906104e6565b6101ce565b6040516100949190610564565b60405180910390f35b6100b760048036038101906100b291906104e6565b61027d565b6040516100c69392919061058e565b60405180910390f35b6100e960048036038101906100e491906104e6565b61037c565b6040516100f89392919061058e565b60405180910390f35b60405180606001604052808460ff1681526020018360ff1681526020018260ff168152506000803373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008201518160000160006101000a81548160ff021916908360ff16021790555060208201518160000160016101000a81548160ff021916908360ff16021790555060408201518160000160026101000a81548160ff021916908360ff160217905550905050505050565b6101d66103cd565b6000808373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206040518060600160405290816000820160009054906101000a900460ff1660ff1660ff1681526020016000820160019054906101000a900460ff1660ff1660ff1681526020016000820160029054906101000a900460ff1660ff1660ff16815250509050919050565b60008060008060008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060000160009054906101000a900460ff166000808673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060000160019054906101000a900460ff166000808773ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060000160029054906101000a900460ff169250925092509193909250565b60006020528060005260406000206000915090508060000160009054906101000a900460ff16908060000160019054906101000a900460ff16908060000160029054906101000a900460ff16905083565b6040518060600160405280600060ff168152602001600060ff168152602001600060ff1681525090565b600080fd5b600060ff82169050919050565b610412816103fc565b811461041d57600080fd5b50565b60008135905061042f81610409565b92915050565b60008060006060848603121561044e5761044d6103f7565b5b600061045c86828701610420565b935050602061046d86828701610420565b925050604061047e86828701610420565b9150509250925092565b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b60006104b382610488565b9050919050565b6104c3816104a8565b81146104ce57600080fd5b50565b6000813590506104e0816104ba565b92915050565b6000602082840312156104fc576104fb6103f7565b5b600061050a848285016104d1565b91505092915050565b61051c816103fc565b82525050565b6060820160008201516105386000850182610513565b50602082015161054b6020850182610513565b50604082015161055e6040850182610513565b50505050565b60006060820190506105796000830184610522565b92915050565b610588816103fc565b82525050565b60006060820190506105a3600083018661057f565b6105b0602083018561057f565b6105bd604083018461057f565b94935050505056fea2646970667358221220ce426adf2fbf80a861f23a5eb1e99a281bb07e427b9beed059e09c285f16db6c64736f6c634300081a0033"
    )?;
    let deploy_tx = TransactionRequest::default().from(from).with_deploy_code(bytecode);

    let contract_address = provider
        .send_transaction(deploy_tx)
        .await?
        .get_receipt()
        .await?
        .contract_address
        .expect("Failed to get contract address");

    // Get the contract abi.
    let path = std::env::current_dir()?.join("examples/contracts/examples/abi/Colors.json");
    let contents = std::fs::read(path)?;
    let abi: JsonAbi = serde_json::from_slice(&amp;contents)?;

    // Create a new `ContractInstance` of the Counter contract from the abi.
    let counter_instance: ContractInstance&lt;Http&lt;Client&gt;, _, Ethereum&gt; =
        ContractInstance::new(contract_address, provider.clone(), Interface::new(abi));

    // Interact with the contract.
    assert_eq!(counter_instance.abi().functions().count(), 4);

    // Set color to white.
    let r = DynSolValue::Uint(U256::from(255), 8); // uint8
    let g = DynSolValue::Uint(U256::from(255), 8); // uint8
    let b = DynSolValue::Uint(U256::from(255), 8); // uint8
    let set_color_func = counter_instance.function("setColor", &amp;[r, g, b])?;
    let set_color_receipt = set_color_func.send().await?.get_receipt().await?;
    assert!(set_color_receipt.status());

    // Get the color.
    let get_color_func = counter_instance.function("getColor", &amp;[DynSolValue::Address(from)])?;
    let get_color_result = get_color_func.call().await?;

    // The `r`, `g`, `b` values in the `Color` struct get converted to a `DynSolValue::Tuple`.
    assert!(get_color_result.len() == 1);
    for value in get_color_result {
        if let DynSolValue::Tuple(struct_as_tuple) = value {
            println!("{struct_as_tuple:?}");
        }
    }

    // Get the color as tuple.
    let get_color_tuple =
        counter_instance.function("getColorAsTuple", &amp;[DynSolValue::Address(from)])?;
    let get_color_tuple_result = get_color_tuple.call().await?;

    // The `r`, `g`, `b` are returned as a solidity tuple and hence represented as individual
    // `DynSolValue::Uint`.
    assert!(get_color_tuple_result.len() == 3);
    for value in get_color_tuple_result {
        println!("{value:?}");
    }

    Ok(())
}</code></pre>
<p>在 Github 上找到源码 <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/contracts/examples/unknown_return_types.rs" title="" target="_blank">here</a>。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="填充程序"><a class="header" href="#填充程序">填充程序</a></h2>
<ul>
<li><a href="examples/fillers/gas_filler.html">Gas 估算填充程序</a></li>
<li><a href="examples/fillers/nonce_filler.html">Nonce 管理填充程序</a></li>
<li><a href="examples/fillers/recommended_fillers.html">推荐的填充程序</a></li>
<li><a href="examples/fillers/wallet_filler.html">钱包管理填充程序</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><!-- DO NOT EDIT THIS FILE. IT IS GENERATED BY RUNNING `./scripts/update.sh` -->
<!-- ANY CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN -->
<!-- EDIT OR CREATE THIS TEMPLATE INSTEAD: ./src/templates/fillers/gas_filler.md -->
<!-- LATEST UPDATE: https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="示例gas_filler-1"><a class="header" href="#示例gas_filler-1">示例：<code>gas_filler</code></a></h2>
<h3 id="示例-36"><a class="header" href="#示例-36">示例</a></h3>
<p>要运行此示例：</p>
<ul>
<li>克隆 <a href="https://github.com/alloy-rs/examples" title="" target="_blank">examples</a> 仓库：<code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>运行：<code>cargo run --example gas_filler</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example of using the `GasFiller` in the provider.

use alloy::{
    network::{EthereumWallet, TransactionBuilder},
    node_bindings::Anvil,
    primitives::{address, U256},
    providers::{Provider, ProviderBuilder},
    rpc::types::request::TransactionRequest,
    signers::local::PrivateKeySigner,
};
use eyre::Result;

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    // Spin up a local Anvil node.
    // Ensure `anvil` is available in $PATH.
    let anvil = Anvil::new().try_spawn()?;

    // Set up signer from the first default Anvil account (Alice).
    let signer: PrivateKeySigner = anvil.keys()[0].clone().into();
    let wallet = EthereumWallet::from(signer);

    // Create a provider with the wallet.
    let rpc_url = anvil.endpoint().parse()?;
    let provider = ProviderBuilder::new()
        // Add the `GasFiller` to the provider.
        // It is generally recommended to use the `.with_recommended_fillers()` method, which
        // includes the `GasFiller`.
        .with_gas_estimation()
        .wallet(wallet)
        .on_http(rpc_url);

    // Build an EIP-1559 type transaction to send 100 wei to Vitalik.
    let vitalik = address!("d8dA6BF26964aF9D7eEd9e03E53415D37aA96045");
    let tx = TransactionRequest::default()
        .with_to(vitalik)
        .with_value(U256::from(100))
        // Notice that without the `NonceFiller`, you need to set `nonce` field.
        .with_nonce(0)
        // Notice that without the `ChainIdFiller`, you need to set the `chain_id` field.
        .with_chain_id(anvil.chain_id());

    // Send the transaction, the nonce (0) is automatically managed by the provider.
    let builder = provider.send_transaction(tx.clone()).await?;
    let node_hash = *builder.tx_hash();
    let pending_tx =
        provider.get_transaction_by_hash(node_hash).await?.expect("Pending transaction not found");
    assert_eq!(pending_tx.nonce, 0);

    println!("Transaction sent with nonce: {}", pending_tx.nonce);

    // Update the nonce and send the transaction again.
    let tx = tx.with_nonce(1);

    // Send the transaction, the nonce (1) is automatically managed by the provider.
    let builder = provider.send_transaction(tx).await?;
    let node_hash = *builder.tx_hash();
    let pending_tx =
        provider.get_transaction_by_hash(node_hash).await?.expect("Pending transaction not found");
    assert_eq!(pending_tx.nonce, 1);

    println!("Transaction sent with nonce: {}", pending_tx.nonce);

    Ok(())
}</code></pre>
<p>在 Github 上找到源代码 <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/fillers/examples/gas_filler.rs" title="" target="_blank">here</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><!-- DO NOT EDIT THIS FILE. IT IS GENERATED BY RUNNING `./scripts/update.sh` -->
<!-- ANY CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN -->
<!-- EDIT OR CREATE THIS TEMPLATE INSTEAD: ./src/templates/fillers/nonce_filler.md -->
<!-- LATEST UPDATE: https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="示例-nonce_filler-1"><a class="header" href="#示例-nonce_filler-1">示例: <code>nonce_filler</code></a></h2>
<h3 id="示例-37"><a class="header" href="#示例-37">示例</a></h3>
<p>运行此示例:</p>
<ul>
<li>克隆 <a href="https://github.com/alloy-rs/examples" title="" target="_blank">examples</a> 仓库: <code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>运行: <code>cargo run --example nonce_filler</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example of using the `NonceFiller` in the provider.

use alloy::{
    network::{EthereumWallet, TransactionBuilder},
    node_bindings::Anvil,
    primitives::{address, U256},
    providers::{Provider, ProviderBuilder},
    rpc::types::request::TransactionRequest,
    signers::local::PrivateKeySigner,
};
use eyre::Result;

/// In Ethereum, the nonce of a transaction is a number that represents the number of transactions
/// that have been sent from a particular account. The nonce is used to ensure that transactions are
/// processed in the order they are intended, and to prevent the same transaction from being
/// processed multiple times.
///
/// The nonce manager in Alloy is a layer that helps you manage the nonce
/// of transactions by keeping track of the current nonce for a given account and automatically
/// incrementing it as needed. This can be useful if you want to ensure that transactions are sent
/// in the correct order, or if you want to avoid having to manually manage the nonce yourself.
#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    // Spin up a local Anvil node.
    // Ensure `anvil` is available in $PATH.
    let anvil = Anvil::new().try_spawn()?;

    // Set up signer from the first default Anvil account (Alice).
    let signer: PrivateKeySigner = anvil.keys()[0].clone().into();
    let wallet = EthereumWallet::from(signer);

    // Create a provider with the wallet.
    let rpc_url = anvil.endpoint().parse()?;
    let provider = ProviderBuilder::new()
        // Add the `NonceFiller` to the provider.
        // It is generally recommended to use the `.with_recommended_fillers()` method, which
        // includes the `NonceFiller`.
        .with_nonce_management()
        .wallet(wallet)
        .on_http(rpc_url);

    // Build an EIP-1559 type transaction to send 100 wei to Vitalik.
    let vitalik = address!("d8dA6BF26964aF9D7eEd9e03E53415D37aA96045");
    let tx = TransactionRequest::default()
        .with_to(vitalik)
        .with_value(U256::from(100))
        // Notice that without the `GasFiller`, you need to set the gas related fields.
        .with_gas_limit(21_000)
        .with_max_fee_per_gas(20_000_000_000)
        .with_max_priority_fee_per_gas(1_000_000_000)
        // Notice that without the `ChainIdFiller`, you need to set the `chain_id` field.
        .with_chain_id(anvil.chain_id());

    // Send the transaction, the nonce (0) is automatically managed by the provider.
    let builder = provider.send_transaction(tx.clone()).await?;
    let node_hash = *builder.tx_hash();
    let pending_tx =
        provider.get_transaction_by_hash(node_hash).await?.expect("Transaction not found");
    assert_eq!(pending_tx.nonce, 0);

    println!("Transaction sent with nonce: {}", pending_tx.nonce);

    // Send the transaction, the nonce (1) is automatically managed by the provider.
    let builder = provider.send_transaction(tx).await?;
    let node_hash = *builder.tx_hash();
    let pending_tx =
        provider.get_transaction_by_hash(node_hash).await?.expect("Transaction not found");
    assert_eq!(pending_tx.nonce, 1);

    println!("Transaction sent with nonce: {}", pending_tx.nonce);

    Ok(())
}</code></pre>
<p>在 Github 上查看源代码 <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/fillers/examples/nonce_filler.rs" title="" target="_blank">此处</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><!-- DO NOT EDIT THIS FILE. IT IS GENERATED BY RUNNING `./scripts/update.sh` -->
<!-- ANY CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN -->
<!-- EDIT OR CREATE THIS TEMPLATE INSTEAD: ./src/templates/fillers/recommended_fillers.md -->
<!-- LATEST UPDATE: https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="示例-recommended_fillers-2"><a class="header" href="#示例-recommended_fillers-2">示例: <code>recommended_fillers</code></a></h2>
<h3 id="示例-38"><a class="header" href="#示例-38">示例</a></h3>
<p>要运行这个示例:</p>
<ul>
<li>克隆 <a href="https://github.com/alloy-rs/examples" title="" target="_blank">examples</a> 仓库: <code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>运行: <code>cargo run --example recommended_fillers</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example of using the `.with_recommended_fillers()` method in the provider.

use alloy::{
    network::{EthereumWallet, TransactionBuilder},
    node_bindings::Anvil,
    primitives::{address, U256},
    providers::{Provider, ProviderBuilder},
    rpc::types::request::TransactionRequest,
    signers::local::PrivateKeySigner,
};
use eyre::Result;

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    // Spin up a local Anvil node.
    // Ensure `anvil` is available in $PATH.
    let anvil = Anvil::new().try_spawn()?;

    // Set up signer from the first default Anvil account (Alice).
    let signer: PrivateKeySigner = anvil.keys()[0].clone().into();
    let wallet = EthereumWallet::from(signer);

    // Create a provider with the wallet.
    let rpc_url = anvil.endpoint().parse()?;
    let provider = ProviderBuilder::new()
        // Adds the `ChainIdFiller`, `GasFiller` and the `NonceFiller` layers.
        .with_recommended_fillers()
        .wallet(wallet)
        .on_http(rpc_url);

    // Build an EIP-1559 type transaction to send 100 wei to Vitalik.
    // Notice that the `nonce` field is set by the `NonceFiller`.
    // Notice that the gas related fields are set by the `GasFiller`.
    // Notice that the `chain_id` field is set by the `ChainIdFiller`.
    let vitalik = address!("d8dA6BF26964aF9D7eEd9e03E53415D37aA96045");
    let tx = TransactionRequest::default().with_to(vitalik).with_value(U256::from(100));

    // Send the transaction, the nonce (0) is automatically managed by the provider.
    let builder = provider.send_transaction(tx.clone()).await?;
    let node_hash = *builder.tx_hash();
    let pending_tx =
        provider.get_transaction_by_hash(node_hash).await?.expect("Pending transaction not found");
    assert_eq!(pending_tx.nonce, 0);

    println!("Transaction sent with nonce: {}", pending_tx.nonce);

    // Send the transaction, the nonce (1) is automatically managed by the provider.
    let builder = provider.send_transaction(tx).await?;
    let node_hash = *builder.tx_hash();
    let pending_tx =
        provider.get_transaction_by_hash(node_hash).await?.expect("Pending transaction not found");
    assert_eq!(pending_tx.nonce, 1);

    println!("Transaction sent with nonce: {}", pending_tx.nonce);

    Ok(())
}</code></pre>
<p>在 Github 上找到源代码 <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/fillers/examples/recommended_fillers.rs" title="" target="_blank">here</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><!-- DO NOT EDIT THIS FILE. IT IS GENERATED BY RUNNING `./scripts/update.sh` -->
<!-- ANY CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN -->
<!-- EDIT OR CREATE THIS TEMPLATE INSTEAD: ./src/templates/fillers/wallet_filler.md -->
<!-- LATEST UPDATE: https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="示例-wallet_filler-1"><a class="header" href="#示例-wallet_filler-1">示例: <code>wallet_filler</code></a></h2>
<h3 id="示例-39"><a class="header" href="#示例-39">示例</a></h3>
<p>要运行此示例：</p>
<ul>
<li>克隆 <a href="https://github.com/alloy-rs/examples" title="" target="_blank">examples</a> 仓库：<code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>运行：<code>cargo run --example wallet_filler</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example of using the `WalletFiller` in the provider.

use alloy::{
    network::{EthereumWallet, TransactionBuilder},
    node_bindings::Anvil,
    primitives::{address, b256, U256},
    providers::{Provider, ProviderBuilder},
    rpc::types::request::TransactionRequest,
    signers::local::PrivateKeySigner,
};
use eyre::Result;

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    // Spin up a local Anvil node.
    // Ensure `anvil` is available in $PATH.
    let anvil = Anvil::new().try_spawn()?;

    // Set up signer from the first default Anvil account (Alice).
    let signer: PrivateKeySigner = anvil.keys()[0].clone().into();
    let wallet = EthereumWallet::from(signer);

    // Create a provider with the wallet.
    let rpc_url = anvil.endpoint().parse()?;
    let provider = ProviderBuilder::new()
        // Add the `WalletFiller` to the provider
        .wallet(wallet)
        .on_http(rpc_url);

    // Build a legacy type transaction to send 100 wei to Vitalik.
    let vitalik = address!("d8dA6BF26964aF9D7eEd9e03E53415D37aA96045");
    let tx = TransactionRequest::default()
        .with_to(vitalik)
        .with_value(U256::from(100))
        // Notice that without the `NonceFiller`, you need to manually set the nonce field.
        .with_nonce(0)
        // Notice that without the `GasFiller`, you need to set the gas related fields.
        .with_gas_price(20_000_000_000)
        .with_gas_limit(21_000);

    let builder = provider.send_transaction(tx).await?;
    let node_hash = *builder.tx_hash();

    println!(
        "Node hash matches expected hash: {}",
        node_hash == b256!("eb56033eab0279c6e9b685a5ec55ea0ff8d06056b62b7f36974898d4fbb57e64")
    );

    // Send the transaction and wait for the broadcast.
    let pending_tx = builder.register().await?;

    println!("Pending transaction hash matches node hash: {}", *pending_tx.tx_hash() == node_hash);

    let tx_hash = pending_tx.await?;
    assert_eq!(tx_hash, node_hash);

    println!("Transaction hash matches node hash: {}", tx_hash == node_hash);

    // Wait for the transaction to be included and get the receipt.
    let receipt =
        provider.get_transaction_receipt(tx_hash).await?.expect("Transaction receipt not found");
    let receipt_hash = receipt.transaction_hash;
    assert_eq!(receipt_hash, node_hash);

    println!("Transaction receipt hash matches node hash: {}", receipt_hash == node_hash);

    Ok(())
}</code></pre>
<p>在 Github 上可以找到源代码 <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/fillers/examples/wallet_filler.rs" title="" target="_blank">here</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="层"><a class="header" href="#层">层</a></h2>
<ul>
<li><a href="examples/layers/logging_layer.html">日志层</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><!-- DO NOT EDIT THIS FILE. IT IS GENERATED BY RUNNING `./scripts/update.sh` -->
<!-- ANY CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN -->
<!-- EDIT OR CREATE THIS TEMPLATE INSTEAD: ./src/templates/layers/logging_layer.md -->
<!-- LATEST UPDATE: https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="示例-logging_layer"><a class="header" href="#示例-logging_layer">示例: <code>logging_layer</code></a></h2>
<h3 id="示例-40"><a class="header" href="#示例-40">示例</a></h3>
<p>运行这个例子:</p>
<ul>
<li>克隆 <a href="https://github.com/alloy-rs/examples" title="" target="_blank">examples</a> 仓库: <code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>运行: <code>cargo run --example logging_layer</code></li>
</ul>
<pre><code class="language-rust ignore">//! This examples demonstrates how to implement your own custom transport layer.
//! As a demonstration we implement a simple request / response logging layer.

use alloy::{
    node_bindings::Anvil,
    providers::{Provider, ProviderBuilder},
    rpc::{
        client::ClientBuilder,
        json_rpc::{RequestPacket, ResponsePacket},
    },
    transports::TransportError,
};
use eyre::Result;
use std::{
    fmt::Debug,
    future::{Future, IntoFuture},
    pin::Pin,
    task::{Context, Poll},
};
use tower::{Layer, Service};

struct LoggingLayer;

// Implement tower::Layer for LoggingLayer.
impl&lt;S&gt; Layer&lt;S&gt; for LoggingLayer {
    type Service = LoggingService&lt;S&gt;;

    fn layer(&amp;self, inner: S) -&gt; Self::Service {
        LoggingService { inner }
    }
}

// A logging service that wraps an inner service.
#[derive(Debug, Clone)]
struct LoggingService&lt;S&gt; {
    inner: S,
}

// Implement tower::Service for LoggingService.
impl&lt;S&gt; Service&lt;RequestPacket&gt; for LoggingService&lt;S&gt;
where
    // Constraints on the service.
    S: Service&lt;RequestPacket, Response = ResponsePacket, Error = TransportError&gt;,
    S::Future: Send + 'static,
    S::Response: Send + 'static + Debug,
    S::Error: Send + 'static + Debug,
{
    type Response = S::Response;
    type Error = S::Error;
    type Future = Pin&lt;Box&lt;dyn Future&lt;Output = Result&lt;Self::Response, Self::Error&gt;&gt; + Send&gt;&gt;;

    fn poll_ready(&amp;mut self, cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;Result&lt;(), Self::Error&gt;&gt; {
        self.inner.poll_ready(cx)
    }

    fn call(&amp;mut self, req: RequestPacket) -&gt; Self::Future {
        println!("Request: {req:?}");

        let fut = self.inner.call(req);

        Box::pin(async move {
            let res = fut.await;

            println!("Response: {res:?}");

            res
        })
    }
}

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    let anvil = Anvil::new().spawn();
    let client = ClientBuilder::default().layer(LoggingLayer).http(anvil.endpoint_url());

    let provider = ProviderBuilder::new().on_client(client);

    for _ in 0..10 {
        let _block_number = provider.get_block_number().into_future().await?;
    }

    Ok(())
}</code></pre>
<p>在 Github 上可以找到源码 <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/layers/examples/logging_layer.rs" title="" target="_blank">here</a>。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="原始数据类型"><a class="header" href="#原始数据类型">原始数据类型</a></h2>
<ul>
<li><a href="examples/primitives/bytes_and_address_types.html">字节和地址类型</a></li>
<li><a href="examples/primitives/hashing_functions.html">哈希函数</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><!-- DO NOT EDIT THIS FILE. IT IS GENERATED BY RUNNING `./scripts/update.sh` -->
<!-- ANY CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN -->
<!-- EDIT OR CREATE THIS TEMPLATE INSTEAD: ./src/templates/primitives/bytes_and_address_types.md -->
<!-- LATEST UPDATE: https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="示例-bytes_and_address_types-1"><a class="header" href="#示例-bytes_and_address_types-1">示例: <code>bytes_and_address_types</code></a></h2>
<h3 id="示例-41"><a class="header" href="#示例-41">示例</a></h3>
<p>要运行此示例：</p>
<ul>
<li>克隆 <a href="https://github.com/alloy-rs/examples" title="" target="_blank">examples</a> 仓库：<code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>运行：<code>cargo run --example bytes_and_address_types</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example of basic usage of bytes and address types and macros.

use alloy::primitives::{
    address, b128, b256, b512, b64, bytes, fixed_bytes, Address, Bytes, FixedBytes,
};
use eyre::Result;

fn main() -&gt; Result&lt;()&gt; {
    // Bytes type
    let a = bytes!("0123abcd");
    assert_eq!(a, Bytes::from(&amp;[0x01, 0x23, 0xab, 0xcd]));
    assert_eq!(a.len(), 4);

    // Address type
    let b = address!("f39Fd6e51aad88F6F4ce6aB8827279cffFb92266");
    assert_eq!(
        b,
        Address::from(&amp;[
            0xf3, 0x9f, 0xd6, 0xe5, 0x1a, 0xad, 0x88, 0xf6, 0xf4, 0xce, 0x6a, 0xb8, 0x82, 0x72,
            0x79, 0xcf, 0xff, 0xb9, 0x22, 0x66
        ])
    );
    assert_eq!(b.len(), 20);

    // FixedBytes&lt;8&gt; type
    let c = b64!("0102030405060708");
    assert_eq!(c, FixedBytes::from(&amp;[0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08]));
    assert_eq!(c.len(), 8);

    // FixedBytes&lt;16&gt; type
    let d = b128!("0102030405060708090a0b0c0d0e0f10");
    assert_eq!(
        d,
        FixedBytes::from(&amp;[
            0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e,
            0x0f, 0x10,
        ])
    );
    assert_eq!(d.len(), 16);

    // FixedBytes&lt;32&gt; type
    let e = b256!("0102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f20");
    assert_eq!(
        e,
        FixedBytes::from(&amp;[
            0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e,
            0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c,
            0x1d, 0x1e, 0x1f, 0x20,
        ]),
    );
    assert_eq!(e.len(), 32);

    // FixedBytes&lt;64&gt; type
    let f = b512!("0102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f202122232425262728292a2b2c2d2e2f303132333435363738393a3b3c3d3e3f40");
    assert_eq!(
        f,
        FixedBytes::from(&amp;[
            0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e,
            0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c,
            0x1d, 0x1e, 0x1f, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a,
            0x2b, 0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38,
            0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f, 0x40,
        ]),
    );
    assert_eq!(f.len(), 64);

    // FixedBytes&lt;20&gt; type, determined by the length of the input
    let g = fixed_bytes!("0102030405060708090a0b0c0d0e0f1011121314");
    assert_eq!(
        g,
        FixedBytes::from(&amp;[
            0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e,
            0x0f, 0x10, 0x11, 0x12, 0x13, 0x14,
        ]),
    );
    assert_eq!(g.len(), 20);

    Ok(())
}</code></pre>
<p>在 Github 上可以找到源码 <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/primitives/examples/bytes_and_address_types.rs" title="" target="_blank">here</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><!-- DO NOT EDIT THIS FILE. IT IS GENERATED BY RUNNING `./scripts/update.sh` -->
<!-- ANY CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN -->
<!-- EDIT OR CREATE THIS TEMPLATE INSTEAD: ./src/templates/primitives/hashing_functions.md -->
<!-- LATEST UPDATE: https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="示例-hashing_functions-哈希函数-1"><a class="header" href="#示例-hashing_functions-哈希函数-1">示例: <code>hashing_functions</code> 哈希函数</a></h2>
<h3 id="示例-42"><a class="header" href="#示例-42">示例</a></h3>
<p>要运行这个示例：</p>
<ul>
<li>克隆 <a href="https://github.com/alloy-rs/examples" title="" target="_blank">examples</a> 代码库: <code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>运行: <code>cargo run --example hashing_functions</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example of basic usage of hashing functions.

use alloy::primitives::{eip191_hash_message, keccak256};
use eyre::{Ok, Result};

fn main() -&gt; Result&lt;()&gt; {
    // [`Keccak-256`]: https://en.wikipedia.org/wiki/SHA-3
    let hash = keccak256(b"hello world");
    assert_eq!(
        hash.to_string(),
        "0x47173285a8d7341e5e972fc677286384f802f8ef42a5ec5f03bbfa254cb01fad"
    );
    assert_eq!(hash.len(), 32);

    // Hash a message according to [EIP-191] (version `0x01`).
    //
    // The final message is a UTF-8 string, encoded as follows:
    // `"\x19Ethereum Signed Message:\n" + message.length + message`
    //
    // This message is then hashed using [`Keccak-256`]: https://en.wikipedia.org/wiki/SHA-3.
    //
    // [EIP-191]: https://eips.ethereum.org/EIPS/eip-191
    let eip191_hash = eip191_hash_message(b"hello_world");
    assert_eq!(
        eip191_hash.to_string(),
        "0xd52de6e039c023a7c77752126e4d9d99e2a7dacea3d19e97e9c2ebcb3ecf1c00"
    );
    assert_eq!(eip191_hash.len(), 32);

    Ok(())
}</code></pre>
<p>在 Github 上找到源码 <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/primitives/examples/hashing_functions.rs" title="" target="_blank">这里</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="providers"><a class="header" href="#providers">Providers</a></h2>
<ul>
<li><a href="examples/providers/builder.html">Builder</a></li>
<li><a href="examples/providers/builtin.html">Builtin</a></li>
<li><a href="examples/providers/http.html" title="" target="_blank">HTTP</a></li>
<li><a href="examples/providers/ws.html">WS</a></li>
<li><a href="examples/providers/ws_with_auth.html">WS with authentication</a></li>
<li><a href="examples/providers/ipc.html">IPC</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><!-- DO NOT EDIT THIS FILE. IT IS GENERATED BY RUNNING `./scripts/update.sh` -->
<!-- ANY CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN -->
<!-- EDIT OR CREATE THIS TEMPLATE INSTEAD: ./src/templates/providers/builder.md -->
<!-- LATEST UPDATE: https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="示例builder"><a class="header" href="#示例builder">示例：<code>builder</code></a></h2>
<h3 id="示例-43"><a class="header" href="#示例-43">示例</a></h3>
<p>要运行这个示例：</p>
<ul>
<li>克隆 <a href="https://github.com/alloy-rs/examples" title="" target="_blank">examples</a> 仓库：<code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>执行：<code>cargo run --example builder</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example of using the `ProviderBuilder` to create a provider with a signer and network.

use alloy::{
    network::{EthereumWallet, TransactionBuilder},
    node_bindings::Anvil,
    primitives::U256,
    providers::{Provider, ProviderBuilder},
    rpc::types::TransactionRequest,
    signers::local::PrivateKeySigner,
};
use eyre::Result;

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    // Spin up a local Anvil node.
    // Ensure `anvil` is available in $PATH.
    let anvil = Anvil::new().block_time(1).try_spawn()?;

    // Set up signer from the first default Anvil account (Alice).
    let signer: PrivateKeySigner = anvil.keys()[0].clone().into();
    let wallet = EthereumWallet::from(signer.clone());

    // Create two users, Alice and Bob.
    let alice = signer.address();
    let bob = anvil.addresses()[1];

    // Set up the HTTP provider with the `reqwest` crate.
    let rpc_url = anvil.endpoint().parse()?;
    let provider =
        ProviderBuilder::new().with_recommended_fillers().wallet(wallet).on_http(rpc_url);

    // Create a transaction.
    let tx = TransactionRequest::default().with_to(bob).with_value(U256::from(100));

    // Send the transaction and wait for the broadcast.
    let pending_tx = provider.send_transaction(tx).await?;

    println!("Pending transaction... {}", pending_tx.tx_hash());

    // Wait for the transaction to be included and get the receipt.
    let receipt = pending_tx.get_receipt().await?;

    println!(
        "Transaction included in block {}",
        receipt.block_number.expect("Failed to get block number")
    );

    assert_eq!(receipt.from, alice);
    assert_eq!(receipt.to, Some(bob));

    Ok(())
}</code></pre>
<p>在 Github 上查看源代码 <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/providers/examples/builder.rs" title="" target="_blank">这里</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><!-- DO NOT EDIT THIS FILE. IT IS GENERATED BY RUNNING `./scripts/update.sh` -->
<!-- ANY CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN -->
<!-- EDIT OR CREATE THIS TEMPLATE INSTEAD: ./src/templates/providers/builtin.md -->
<!-- LATEST UPDATE: https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="示例-builtin"><a class="header" href="#示例-builtin">示例: <code>builtin</code></a></h2>
<h3 id="示例-44"><a class="header" href="#示例-44">示例</a></h3>
<p>运行此示例:</p>
<ul>
<li>克隆 <a href="https://github.com/alloy-rs/examples" title="" target="_blank">examples</a> 仓库: <code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>运行: <code>cargo run --example builtin</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example of using the `on_builtin` method in the provider.

use alloy::{
    node_bindings::Anvil,
    providers::{Provider, ProviderBuilder},
};
use eyre::Result;
use futures_util::StreamExt;

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    let anvil = Anvil::new().block_time(1).try_spawn()?;

    // Instantiate a HTTP transport provider by passing the HTTP endpoint url
    let http_rpc_url = anvil.endpoint();
    let http_provider = ProviderBuilder::new().on_builtin(&amp;http_rpc_url).await?;

    // Get latest block number
    let block_number = http_provider.get_block_number().await?;

    println!("Latest block number: {block_number:?}");

    // This requires the `pubsub` and `ws` features to be enabled on alloy-provider
    let ws_rpc_url = anvil.ws_endpoint();
    let ws_provider = ProviderBuilder::new().on_builtin(&amp;ws_rpc_url).await?;

    let sub = ws_provider.subscribe_blocks().await?;

    let mut stream = sub.into_stream().take(2);

    println!("Awaiting blocks...");

    let handle = tokio::spawn(async move {
        while let Some(block) = stream.next().await {
            println!("{}", block.header.number.expect("Failed to get block number"));
        }
    });

    handle.await?;

    // This requires the `pubsub` and `ipc` features to be enabled on alloy-provider
    // This would throw a runtime error if the ipc does not exist
    let ipc_path = "/tmp/reth.ipc";
    let ipc_provider = ProviderBuilder::new().on_builtin(ipc_path).await?;

    let _block_number = ipc_provider.get_block_number().await?;

    Ok(())
}</code></pre>
<p>在 Github 上找到源代码 <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/providers/examples/builtin.rs" title="" target="_blank">here</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><!-- 请勿编辑此文件。它是通过运行 `./scripts/update.sh` 生成的 -->
<!-- 对此文件的任何更改都将被覆盖 -->
<!-- 请改为编辑或创建此模板: ./src/templates/providers/http.md -->
<!-- 最新更新: https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="示例-http-1"><a class="header" href="#示例-http-1">示例: <code>http</code></a></h2>
<h3 id="示例-45"><a class="header" href="#示例-45">示例</a></h3>
<p>要运行此示例：</p>
<ul>
<li>克隆 <a href="https://github.com/alloy-rs/examples" title="" target="_blank">examples</a> 仓库: <code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>运行: <code>cargo run --example http</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example of using the HTTP provider with the `reqwest` crate to get the latest block number.

use alloy::providers::{Provider, ProviderBuilder};
use eyre::Result;

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    // Set up the HTTP transport which is consumed by the RPC client.
    let rpc_url = "https://eth.merkle.io".parse()?;

    // Create a provider with the HTTP transport using the `reqwest` crate.
    let provider = ProviderBuilder::new().on_http(rpc_url);

    // Get latest block number.
    let latest_block = provider.get_block_number().await?;

    println!("Latest block number: {latest_block}");

    Ok(())
}</code></pre>
<p>在 Github 上找到源代码 <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/providers/examples/http.rs" title="" target="_blank">here</a>。</p>
<div style="break-before: page; page-break-before: always;"></div><!-- DO NOT EDIT THIS FILE. IT IS GENERATED BY RUNNING `./scripts/update.sh` -->
<!-- ANY CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN -->
<!-- EDIT OR CREATE THIS TEMPLATE INSTEAD: ./src/templates/providers/ws.md -->
<!-- LATEST UPDATE: https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="示例-ws-1"><a class="header" href="#示例-ws-1">示例: <code>ws</code></a></h2>
<h3 id="示例-46"><a class="header" href="#示例-46">示例</a></h3>
<p>要运行这个示例：</p>
<ul>
<li>克隆 <a href="https://github.com/alloy-rs/examples" title="" target="_blank">examples</a> 仓库：<code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>运行：<code>cargo run --example ws</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example of using the WS provider to subscribe to new blocks.

use alloy::providers::{Provider, ProviderBuilder, WsConnect};
use eyre::Result;
use futures_util::StreamExt;

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    // Set up the WS transport which is consumed by the RPC client.
    let rpc_url = "wss://eth-mainnet.g.alchemy.com/v2/your-api-key";

    // Create the provider.
    let ws = WsConnect::new(rpc_url);
    let provider = ProviderBuilder::new().on_ws(ws).await?;

    // Subscribe to new blocks.
    let sub = provider.subscribe_blocks().await?;

    // Wait and take the next 4 blocks.
    let mut stream = sub.into_stream().take(4);

    println!("Awaiting blocks...");

    // Take the stream and print the block number upon receiving a new block.
    let handle = tokio::spawn(async move {
        while let Some(block) = stream.next().await {
            println!(
                "Latest block number: {}",
                block.header.number.expect("Failed to get block number")
            );
        }
    });

    handle.await?;

    Ok(())
}</code></pre>
<p>在 Github 上找到源代码 <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/providers/examples/ws.rs" title="" target="_blank">这里</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><!-- DO NOT EDIT THIS FILE. IT IS GENERATED BY RUNNING `./scripts/update.sh` -->
<!-- ANY CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN -->
<!-- EDIT OR CREATE THIS TEMPLATE INSTEAD: ./src/templates/providers/ws_with_auth.md -->
<!-- LATEST UPDATE: https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="示例ws_with_auth-1"><a class="header" href="#示例ws_with_auth-1">示例：<code>ws_with_auth</code></a></h2>
<h3 id="示例-47"><a class="header" href="#示例-47">示例</a></h3>
<p>运行此示例：</p>
<ul>
<li>克隆 <a href="https://github.com/alloy-rs/examples" title="" target="_blank">examples</a> 仓库：<code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>运行：<code>cargo run --example ws_with_auth</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example of using the WS provider with auth to subscribe to new blocks.

use alloy::{
    providers::{Provider, ProviderBuilder, WsConnect},
    transports::Authorization,
};
use eyre::Result;
use futures_util::StreamExt;

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    // Set up the WS transport which is consumed by the RPC client.
    let rpc_url = "wss://your-ws-endpoint.com/";

    // Create authorization methods.
    let auth = Authorization::basic("username", "password");
    let auth_bearer = Authorization::bearer("bearer-token");

    // Create the WS connection object with authentication.
    let ws_basic = WsConnect::with_auth(rpc_url, Some(auth));
    let ws_bearer = WsConnect::with_auth(rpc_url, Some(auth_bearer));

    // Create the provider.
    let provider_basic = ProviderBuilder::new().on_ws(ws_basic).await?;
    let provider_bearer = ProviderBuilder::new().on_ws(ws_bearer).await?;

    // Subscribe to new blocks.
    let sub_basic = provider_basic.subscribe_blocks();
    let sub_bearer = provider_bearer.subscribe_blocks();

    // Wait and take the next 4 blocks.
    let mut stream_basic = sub_basic.await?.into_stream().take(4);
    let mut stream_bearer = sub_bearer.await?.into_stream().take(4);

    println!("Awaiting blocks...");

    // Take the basic stream and print the block number upon receiving a new block.
    let basic_handle = tokio::spawn(async move {
        while let Some(block) = stream_basic.next().await {
            println!(
                "Latest block number (basic): {}",
                block.header.number.expect("Failed to get block number")
            );
        }
    });

    // Take the bearer stream and print the block number upon receiving a new block.
    let bearer_handle = tokio::spawn(async move {
        while let Some(block) = stream_bearer.next().await {
            println!(
                "Latest block number (bearer): {}",
                block.header.number.expect("Failed to get block number")
            );
        }
    });

    // Wait for both tasks to complete.
    let _ = tokio::try_join!(basic_handle, bearer_handle)?;

    Ok(())
}</code></pre>
<p>可以在 Github 上找到源码 <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/providers/examples/ws_with_auth.rs" title="" target="_blank">here</a>。</p>
<div style="break-before: page; page-break-before: always;"></div><!-- 请勿编辑此文件。它是通过运行 `./scripts/update.sh` 自动生成的 -->
<!-- 对该文件进行的任何更改都会被覆盖 -->
<!-- 请编辑或创建以下模板来替代：./src/templates/providers/ipc.md -->
<!-- 最新更新： https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="示例ipc-1"><a class="header" href="#示例ipc-1">示例：<code>ipc</code></a></h2>
<h3 id="示例-48"><a class="header" href="#示例-48">示例</a></h3>
<p>运行此示例：</p>
<ul>
<li>克隆 <a href="https://github.com/alloy-rs/examples" title="" target="_blank">examples</a> 仓库: <code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>运行: <code>cargo run --example ipc</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example of using the IPC provider to get the latest block number.

use alloy::providers::{IpcConnect, Provider, ProviderBuilder};
use eyre::Result;

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    // Set up the IPC transport which is consumed by the RPC client.
    let ipc_path = "/tmp/reth.ipc";

    // Create the provider.
    let ipc = IpcConnect::new(ipc_path.to_string());
    let provider = ProviderBuilder::new().on_ipc(ipc).await?;

    let latest_block = provider.get_block_number().await?;

    println!("Latest block: {latest_block}");

    Ok(())
}</code></pre>
<p>在 Github 上查看源代码 <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/providers/examples/ipc.rs" title="" target="_blank">这里</a>。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="queries"><a class="header" href="#queries">Queries</a></h2>
<ul>
<li><a href="examples/queries/query_contract_storage.html">查询合约存储</a></li>
<li><a href="examples/queries/query_deployed_bytecode.html">查询合约已部署的字节码</a></li>
<li><a href="examples/queries/query_logs.html">查询日志</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><!-- 请勿编辑此文件。它是通过运行 `./scripts/update.sh` 生成的 -->
<!-- 对此文件所做的任何更改都将被覆盖 -->
<!-- 请编辑或创建这个模板: ./src/templates/queries/query_contract_storage.md -->
<!-- 最新更新: https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="示例query_contract_storage-1"><a class="header" href="#示例query_contract_storage-1">示例：<code>query_contract_storage</code></a></h2>
<h3 id="示例-49"><a class="header" href="#示例-49">示例</a></h3>
<p>要运行此示例：</p>
<ul>
<li>克隆 <a href="https://github.com/alloy-rs/examples" title="" target="_blank">examples</a> 仓库: <code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>运行: <code>cargo run --example query_contract_storage</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example of querying contract storage from the Ethereum network.

use alloy::{
    primitives::{address, U256},
    providers::{Provider, ProviderBuilder},
};
use eyre::Result;

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    // Create a provider.
    let rpc_url = "https://eth.merkle.io".parse()?;
    let provider = ProviderBuilder::new().on_http(rpc_url);

    // Get storage slot 0 from the Uniswap V3 USDC-ETH pool on Ethereum mainnet.
    let pool_address = address!("88e6A0c2dDD26FEEb64F039a2c41296FcB3f5640");
    let storage_slot = U256::from(0);
    // The provider calls the RPC at the latest block by default. A block can exlpicitly be set
    // using `.block()`.
    let storage = provider.get_storage_at(pool_address, storage_slot).await?;

    println!("Slot 0: {storage:?}");

    Ok(())
}</code></pre>
<p>在 Github 上查看源代码 <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/queries/examples/query_contract_storage.rs" title="" target="_blank">此处</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><!-- DO NOT EDIT THIS FILE. IT IS GENERATED BY RUNNING `./scripts/update.sh` -->
<!-- ANY CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN -->
<!-- EDIT OR CREATE THIS TEMPLATE INSTEAD: ./src/templates/queries/query_deployed_bytecode.md -->
<!-- LATEST UPDATE: https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="示例query_deployed_bytecode-1"><a class="header" href="#示例query_deployed_bytecode-1">示例：<code>query_deployed_bytecode</code></a></h2>
<h3 id="示例-50"><a class="header" href="#示例-50">示例</a></h3>
<p>运行此示例:</p>
<ul>
<li>克隆 <a href="https://github.com/alloy-rs/examples" title="" target="_blank">examples</a> 仓库: <code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>运行: <code>cargo run --example query_deployed_bytecode</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example of querying deployed bytecode of a contract on the Ethereum network.

use alloy::{
    primitives::address,
    providers::{Provider, ProviderBuilder},
};
use eyre::Result;

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    // Create a provider.
    let rpc_url = "https://eth.merkle.io".parse()?;
    let provider = ProviderBuilder::new().on_http(rpc_url);

    // Get the bytecode of the Uniswap V3 USDC-ETH pool on Ethereum mainnet.
    let pool_address = address!("88e6A0c2dDD26FEEb64F039a2c41296FcB3f5640");
    let bytecode = provider.get_code_at(pool_address).await?;

    println!("Bytecode: {bytecode:?}");

    Ok(())
}</code></pre>
<p>在 Github 上找到源代码 <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/queries/examples/query_deployed_bytecode.rs" title="" target="_blank">here</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><!-- DO NOT EDIT THIS FILE. IT IS GENERATED BY RUNNING `./scripts/update.sh` -->
<!-- ANY CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN -->
<!-- EDIT OR CREATE THIS TEMPLATE INSTEAD: ./src/templates/queries/query_logs.md -->
<!-- LATEST UPDATE: https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="示例-query_logs-1"><a class="header" href="#示例-query_logs-1">示例: <code>query_logs</code></a></h2>
<h3 id="示例-51"><a class="header" href="#示例-51">示例</a></h3>
<p>要运行此示例：</p>
<ul>
<li>克隆 <a href="https://github.com/alloy-rs/examples" title="" target="_blank">examples</a> 仓库: <code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>运行: <code>cargo run --example query_logs</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example of querying logs from the Ethereum network.

use alloy::{
    primitives::{address, b256},
    providers::{Provider, ProviderBuilder},
    rpc::types::Filter,
};
use eyre::Result;

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    // Create a provider.
    let rpc_url = "https://eth.merkle.io".parse()?;
    let provider = ProviderBuilder::new().on_http(rpc_url);

    // Get logs from the latest block
    let latest_block = provider.get_block_number().await?;

    // Create a filter to get all logs from the latest block.
    let filter = Filter::new().from_block(latest_block);

    // Get all logs from the latest block that match the filter.
    let logs = provider.get_logs(&amp;filter).await?;

    for log in logs {
        println!("{log:?}");
    }

    // Get all logs from the latest block that match the transfer event signature/topic.
    let transfer_event_signature =
        b256!("ddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef");
    let filter = Filter::new().event_signature(transfer_event_signature).from_block(latest_block);
    // You could also use the event name instead of the event signature like so:
    // .event("Transfer(address,address,uint256)")

    // Get all logs from the latest block that match the filter.
    let logs = provider.get_logs(&amp;filter).await?;

    for log in logs {
        println!("Transfer event: {log:?}");
    }

    // Get all logs from the latest block emitted by the UNI token address.
    let uniswap_token_address = address!("1f9840a85d5aF5bf1D1762F925BDADdC4201F984");
    let filter = Filter::new().address(uniswap_token_address).from_block(latest_block);

    // Get all logs from the latest block that match the filter.
    let logs = provider.get_logs(&amp;filter).await?;

    for log in logs {
        println!("Uniswap token logs: {log:?}");
    }

    Ok(())
}</code></pre>
<p>在 Github 上查看源代码 <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/queries/examples/query_logs.rs" title="" target="_blank">here</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="sol-宏"><a class="header" href="#sol-宏"><code>sol!</code> 宏</a></h2>
<ul>
<li><a href="examples/sol-macro/contract.html">合约</a></li>
<li><a href="examples/sol-macro/events_errors.html">事件和错误</a></li>
<li><a href="examples/sol-macro/structs_enums.html">结构体和枚举</a></li>
<li><a href="examples/sol-macro/user_defined_types.html">用户定义类型</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><!-- DO NOT EDIT THIS FILE. IT IS GENERATED BY RUNNING `./scripts/update.sh` -->
<!-- ANY CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN -->
<!-- EDIT OR CREATE THIS TEMPLATE INSTEAD: ./src/templates/contracts/deploy_from_contract.md -->
<!-- LATEST UPDATE: https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="示例-deploy_from_contract-1"><a class="header" href="#示例-deploy_from_contract-1">示例： <code>deploy_from_contract</code></a></h2>
<h3 id="示例-52"><a class="header" href="#示例-52">示例</a></h3>
<p>要运行这个示例：</p>
<ul>
<li>克隆 <a href="https://github.com/alloy-rs/examples" title="" target="_blank">examples</a> 仓库：<code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>运行：<code>cargo run --example deploy_from_contract</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example of deploying a contract from Solidity code using the `sol!` macro to Anvil and
//! interacting with it.

use alloy::{
    network::EthereumWallet, node_bindings::Anvil, primitives::U256, providers::ProviderBuilder,
    signers::local::PrivateKeySigner, sol,
};
use eyre::Result;

// Codegen from embedded Solidity code and precompiled bytecode.
sol! {
    #[allow(missing_docs)]
    // solc v0.8.26; solc Counter.sol --via-ir --optimize --bin
    #[sol(rpc, bytecode="6080806040523460135760df908160198239f35b600080fdfe6080806040526004361015601257600080fd5b60003560e01c9081633fb5c1cb1460925781638381f58a146079575063d09de08a14603c57600080fd5b3460745760003660031901126074576000546000198114605e57600101600055005b634e487b7160e01b600052601160045260246000fd5b600080fd5b3460745760003660031901126074576020906000548152f35b34607457602036600319011260745760043560005500fea2646970667358221220e978270883b7baed10810c4079c941512e93a7ba1cd1108c781d4bc738d9090564736f6c634300081a0033")]
    contract Counter {
        uint256 public number;

        function setNumber(uint256 newNumber) public {
            number = newNumber;
        }

        function increment() public {
            number++;
        }
    }
}

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    // Spin up a local Anvil node.
    // Ensure `anvil` is available in $PATH.
    let anvil = Anvil::new().try_spawn()?;

    // Set up signer from the first default Anvil account (Alice).
    let signer: PrivateKeySigner = anvil.keys()[0].clone().into();
    let wallet = EthereumWallet::from(signer);

    // Create a provider with the wallet.
    let rpc_url = anvil.endpoint().parse()?;
    let provider =
        ProviderBuilder::new().with_recommended_fillers().wallet(wallet).on_http(rpc_url);

    println!("Anvil running at `{}`", anvil.endpoint());

    // Deploy the `Counter` contract.
    let contract = Counter::deploy(&amp;provider).await?;

    println!("Deployed contract at address: {}", contract.address());

    let builder = contract.setNumber(U256::from(42));
    let tx_hash = builder.send().await?.watch().await?;

    println!("Set number to 42: {tx_hash}");

    // Increment the number to 43.
    let builder = contract.increment();
    let tx_hash = builder.send().await?.watch().await?;

    println!("Incremented number: {tx_hash}");

    // Retrieve the number, which should be 43.
    let builder = contract.number();
    let number = builder.call().await?.number.to_string();

    println!("Retrieved number: {number}");

    Ok(())
}</code></pre>
<p>在 Github 上找到源代码 <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/contracts/examples/deploy_from_contract.rs" title="" target="_blank">这里</a>。</p>
<div style="break-before: page; page-break-before: always;"></div><!-- DO NOT EDIT THIS FILE. IT IS GENERATED BY RUNNING `./scripts/update.sh` -->
<!-- ANY CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN -->
<!-- EDIT OR CREATE THIS TEMPLATE INSTEAD: ./src/templates/sol-macro/decode_returns.md -->
<!-- LATEST UPDATE: https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="示例decode_returns"><a class="header" href="#示例decode_returns">示例：<code>decode_returns</code></a></h2>
<h3 id="示例-53"><a class="header" href="#示例-53">示例</a></h3>
<p>要运行此示例：</p>
<ul>
<li>克隆 <a href="https://github.com/alloy-rs/examples" title="" target="_blank">examples</a> 仓库: <code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>运行: <code>cargo run --example decode_returns</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example showing how to decode return values from a call to a contract using the `sol!` macro.

use alloy::{
    hex,
    primitives::{I256, U256},
    sol,
    sol_types::SolCall,
};
use eyre::Result;

// Codegen from excerpt of Chainlink Aggregator interface.
// See: https://etherscan.io/address/0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419#code
sol!(
    #[allow(missing_docs)]
    #[derive(Debug, PartialEq, Eq)]
    function getRoundData(uint80 _roundId) external view returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);
);

fn main() -&gt; Result&lt;()&gt; {
    let result = getRoundDataCall::abi_decode_returns(
        &amp;hex!(
            "0000000000000000000000000000000000000000000000060000000000004716
             00000000000000000000000000000000000000000000000000000051faad1c80
             000000000000000000000000000000000000000000000000000000006669627b
             000000000000000000000000000000000000000000000000000000006669627b
             0000000000000000000000000000000000000000000000060000000000004716"
        ),
        true,
    );

    assert_eq!(
        result,
        Ok(getRoundDataReturn {
            roundId: 110680464442257327894_u128,
            answer: I256::from_dec_str("352098000000")?,
            startedAt: U256::from(1718182523),
            updatedAt: U256::from(1718182523),
            answeredInRound: 110680464442257327894_u128,
        })
    );

    Ok(())
}</code></pre>
<p>在 Github 上找到源代码 <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/sol-macro/examples/decode_returns.rs" title="" target="_blank">这里</a>。</p>
<div style="break-before: page; page-break-before: always;"></div><!-- 不要编辑此文件。它是通过运行 `./scripts/update.sh` 生成的 -->
<!-- 对此文件的任何更改都将被覆盖 -->
<!-- 请改为编辑或创建此模板：./src/templates/sol-macro/events_errors.md -->
<!-- 最新更新: https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="示例-events_errors"><a class="header" href="#示例-events_errors">示例: <code>events_errors</code></a></h2>
<h3 id="示例-54"><a class="header" href="#示例-54">示例</a></h3>
<p>要运行此示例：</p>
<ul>
<li>克隆 <a href="https://github.com/alloy-rs/examples" title="" target="_blank">examples</a> 仓库：<code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>运行：<code>cargo run --example events_errors</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example showing how to decode events and errors from a contract using the `sol!` macro.

use alloy::{node_bindings::Anvil, providers::ProviderBuilder, sol};
use eyre::Result;
use futures_util::StreamExt;

// Generate a contract instance from Solidity.
sol!(
    #[allow(missing_docs)]
    #[sol(rpc, bytecode = "608060405260008055348015601357600080fd5b506103e9806100236000396000f3fe608060405234801561001057600080fd5b50600436106100575760003560e01c80632baeceb71461005c5780632ccbdbca1461006657806361bc221a14610070578063c3e8b5ca1461008e578063d09de08a14610098575b600080fd5b6100646100a2565b005b61006e610103565b005b61007861013e565b60405161008591906101f9565b60405180910390f35b610096610144565b005b6100a061017f565b005b60016000808282546100b49190610243565b925050819055506000543373ffffffffffffffffffffffffffffffffffffffff167fdc69c403b972fc566a14058b3b18e1513da476de6ac475716e489fae0cbe4a2660405160405180910390a3565b6040517f23b0db14000000000000000000000000000000000000000000000000000000008152600401610135906102e3565b60405180910390fd5b60005481565b6040517fa5f9ec670000000000000000000000000000000000000000000000000000000081526004016101769061034f565b60405180910390fd5b6001600080828254610191919061036f565b925050819055506000543373ffffffffffffffffffffffffffffffffffffffff167ff6d1d8d205b41f9fb9549900a8dba5d669d68117a3a2b88c1ebc61163e8117ba60405160405180910390a3565b6000819050919050565b6101f3816101e0565b82525050565b600060208201905061020e60008301846101ea565b92915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b600061024e826101e0565b9150610259836101e0565b92508282039050818112600084121682821360008512151617156102805761027f610214565b5b92915050565b600082825260208201905092915050565b7f4572726f72204100000000000000000000000000000000000000000000000000600082015250565b60006102cd600783610286565b91506102d882610297565b602082019050919050565b600060208201905081810360008301526102fc816102c0565b9050919050565b7f4572726f72204200000000000000000000000000000000000000000000000000600082015250565b6000610339600783610286565b915061034482610303565b602082019050919050565b600060208201905081810360008301526103688161032c565b9050919050565b600061037a826101e0565b9150610385836101e0565b9250828201905082811215600083121683821260008412151617156103ad576103ac610214565b5b9291505056fea2646970667358221220a878a3c1da1a1170e4496cdbc63bd5ed1587374bcd6cf6d4f1d5b88fa981795d64736f6c63430008190033")]
    contract CounterWithError {
        int256 public counter = 0;

        // Events - using `Debug` to print the events
        #[derive(Debug)]
        event Increment(address indexed by, int256 indexed value);
        #[derive(Debug)]
        event Decrement(address indexed by, int256 indexed value);

        // Custom Error
        error ErrorA(string message);
        error ErrorB(string message);

        // Functions
        function increment() public {
            counter += 1;
            emit Increment(msg.sender, counter);
        }

        function decrement() public {
            counter -= 1;
            emit Decrement(msg.sender, counter);
        }

        function revertA() public pure {
            revert ErrorA("Error A");
        }

        function revertB() public pure {
            revert ErrorB("Error B");
        }
    }
);

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    // Spin up a local Anvil node.
    let anvil = Anvil::new().try_spawn()?;

    // Create a provider with gas estimation.
    let rpc_url = anvil.endpoint().parse()?;
    let provider = ProviderBuilder::new().with_gas_estimation().on_http(rpc_url);

    // Deploy the `Counter` contract.
    let contract = CounterWithError::deploy(provider.clone()).await?;

    // Setup a filter for the Increment and Decrement events.
    let increment_filter = contract.Increment_filter().watch().await?;
    let decrement_filter = contract.Decrement_filter().watch().await?;

    // Convert to streams.
    let mut increment_stream = increment_filter.into_stream();
    let mut decrement_stream = decrement_filter.into_stream();

    // Call the increment and decrement functions.
    let increment_call = contract.increment();
    let decrement_call = contract.decrement();

    // Wait for the calls to be included.
    let _increment_res = increment_call.send().await?;
    let _decrement_res = decrement_call.send().await?;

    // Catch the events.
    for _ in 0..2 {
        let log = tokio::select! {
            Some(Ok((incr, log))) = increment_stream.next() =&gt; {
                println!("Increment: {incr:#?}");
                // Return raw log
                log
            }
            Some(Ok((decr, log))) = decrement_stream.next() =&gt; {
                println!("Decrement: {decr:#?}");
                // Return raw log
                log
            }
        };
        println!("Log: {log:#?}");
    }

    // Call the `revertA` function.
    let err_call = contract.revertA();
    let err_result = err_call.send().await;

    if let Err(err) = err_result {
        println!("Error A: {err:#?}");
    }

    // Call the `revertB` function.
    let err_call = contract.revertB();
    let err_result = err_call.send().await;

    if let Err(err) = err_result {
        println!("Error B: {err:#?}");
    }

    Ok(())
}</code></pre>
<p>在 Github 上找到源代码 <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/sol-macro/examples/events_errors.rs" title="" target="_blank">here</a>。</p>
<div style="break-before: page; page-break-before: always;"></div><!-- DO NOT EDIT THIS FILE. IT IS GENERATED BY RUNNING `./scripts/update.sh` -->
<!-- ANY CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN -->
<!-- EDIT OR CREATE THIS TEMPLATE INSTEAD: ./src/templates/sol-macro/structs_enums.md -->
<!-- LATEST UPDATE: https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="example-structs_enums"><a class="header" href="#example-structs_enums">Example: <code>structs_enums</code></a></h2>
<h3 id="示例-55"><a class="header" href="#示例-55">示例</a></h3>
<p>要运行此示例：</p>
<ul>
<li>克隆 <a href="https://github.com/alloy-rs/examples" title="" target="_blank">examples</a> 仓库：<code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>运行：<code>cargo run --example structs_enums</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example showing how to use the `sol!` macro to generate Rust bindings for Solidity structs and
//! enums.

use alloy::{primitives::U256, sol};
use eyre::Result;

// Generates Rust bindings for Solidity structs, enums and type aliases.
sol! {
    #[allow(missing_docs)]
    #[derive(Debug)]
    /// Foo
    struct Foo {
        uint256 a;
        uint64 b;
        Bar greater;
    }

    #[allow(missing_docs)]
    #[derive(Debug)]
    /// Bar
    enum Bar {
        A,
        B,
    }
}

fn main() -&gt; Result&lt;()&gt; {
    // Create an instance of the struct.
    let foo = Foo { a: U256::from(1), b: 2_u64, greater: Bar::A };

    println!("{foo:?}");

    Ok(())
}</code></pre>
<p>在 Github 上找到源代码 <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/sol-macro/examples/structs_enums.rs" title="" target="_blank">here</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><!-- DO NOT EDIT THIS FILE. IT IS GENERATED BY RUNNING `./scripts/update.sh` -->
<!-- ANY CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN -->
<!-- EDIT OR CREATE THIS TEMPLATE INSTEAD: ./src/templates/sol-macro/user_defined_types.md -->
<!-- LATEST UPDATE: https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="示例-user_defined_types"><a class="header" href="#示例-user_defined_types">示例: <code>user_defined_types</code></a></h2>
<h3 id="示例-56"><a class="header" href="#示例-56">示例</a></h3>
<p>运行此示例:</p>
<ul>
<li>克隆 <a href="https://github.com/alloy-rs/examples" title="" target="_blank">examples</a> 仓库: <code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>运行: <code>cargo run --example user_defined_types</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example showing defining user defined value types and type aliases using the `sol!` macro.

use alloy::{
    primitives::{Address, U256},
    sol,
    sol_types::SolType,
};
use eyre::Result;

// Type definition: generates a new struct that implements `SolType`
sol! {
   /// Equivalent to `struct CustomType(U256)` in Rust
   type CustomType is uint256;
}

// Type aliases
type B32 = sol! { bytes32 };

// This is equivalent to the following:
// type B32 = alloy_sol_types::sol_data::FixedBytes&lt;32&gt;;

// User defined types
type CustomArrayOf&lt;T&gt; = sol! { T[] };
type CustomTuple = sol! { tuple(address, bytes, string) };

fn main() -&gt; Result&lt;()&gt; {
    let _b32_type = B32::abi_encode(&amp;[0; 32]);

    let _custom_type = CustomType(U256::from(1));

    let _custom_array_of_type = CustomArrayOf::&lt;sol!(bool)&gt;::abi_encode(&amp;vec![true, false]);

    let _custom_tuple_type =
        CustomTuple::abi_encode(&amp;(Address::ZERO, vec![0; 32], "hello".to_string()));

    Ok(())
}</code></pre>
<p>在 Github 上找到源码 <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/sol-macro/examples/user_defined_types.rs" title="" target="_blank">here</a>。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="订阅"><a class="header" href="#订阅">订阅</a></h2>
<ul>
<li><a href="examples/subscriptions/poll_logs.html">监控和轮询合约事件日志</a></li>
<li><a href="examples/subscriptions/subscribe_blocks.html">订阅和监控区块</a></li>
<li><a href="examples/subscriptions/subscribe_logs.html">订阅并监听特定的合约事件日志</a></li>
<li><a href="examples/subscriptions/subscribe_all_logs.html">订阅并监听所有合约事件日志</a></li>
<li><a href="examples/subscriptions/subscribe_pending_transactions.html">订阅并监听公共内存池中的待处理交易</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><!-- DO NOT EDIT THIS FILE. IT IS GENERATED BY RUNNING `./scripts/update.sh` -->
<!-- ANY CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN -->
<!-- EDIT OR CREATE THIS TEMPLATE INSTEAD: ./src/templates/subscriptions/poll_logs.md -->
<!-- LATEST UPDATE: https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="示例-poll_logs"><a class="header" href="#示例-poll_logs">示例: <code>poll_logs</code></a></h2>
<h3 id="示例-57"><a class="header" href="#示例-57">示例</a></h3>
<p>运行此示例：</p>
<ul>
<li>克隆 <a href="https://github.com/alloy-rs/examples" title="" target="_blank">examples</a> 仓库：<code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>运行：<code>cargo run --example poll_logs</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example of watching and polling for contract events by `WebSocket` subscription.

use alloy::{
    node_bindings::Anvil,
    providers::{ProviderBuilder, WsConnect},
    sol,
};
use eyre::Result;
use futures_util::StreamExt;

// Codegen from embedded Solidity code and precompiled bytecode.
// solc v0.8.26; solc Counter.sol --via-ir --optimize --bin
sol!(
    #[allow(missing_docs)]
    #[sol(rpc, bytecode = "6080806040523460195760008055610155908161001f8239f35b600080fdfe6080604052600436101561001257600080fd5b60003560e01c80632baeceb7146100d057806361bc221a146100b25763d09de08a1461003d57600080fd5b346100ad5760003660031901126100ad57600054600181019060006001831291129080158216911516176100975780600055337ff6d1d8d205b41f9fb9549900a8dba5d669d68117a3a2b88c1ebc61163e8117ba600080a3005b634e487b7160e01b600052601160045260246000fd5b600080fd5b346100ad5760003660031901126100ad576020600054604051908152f35b346100ad5760003660031901126100ad5760005460001981019081136001166100975780600055337fdc69c403b972fc566a14058b3b18e1513da476de6ac475716e489fae0cbe4a26600080a300fea26469706673582212200d333e08e1230b0b9919825888e587a45c68e2aa2f7f58752712491e2201da9c64736f6c634300081a0033")]
    contract Counter {
        int256 public counter = 0;

        event Increment(address indexed by, int256 indexed value);
        event Decrement(address indexed by, int256 indexed value);

        function increment() public {
            counter += 1;
            emit Increment(msg.sender, counter);
        }

        function decrement() public {
            counter -= 1;
            emit Decrement(msg.sender, counter);
        }
    }
);

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    // Spin up a local Anvil node.
    // Ensure `anvil` is available in $PATH.
    let anvil = Anvil::new().block_time(1).try_spawn()?;

    // Create a WebSocket provider.
    let ws = WsConnect::new(anvil.ws_endpoint());
    let provider = ProviderBuilder::new().on_ws(ws).await?;

    // Deploy the `Counter` contract.
    let contract = Counter::deploy(provider.clone()).await?;

    println!("Deployed contract at: {}", contract.address());

    // Create filters for each event.
    let increment_filter = contract.Increment_filter().watch().await?;
    let decrement_filter = contract.Decrement_filter().watch().await?;

    // Build a call to increment the counter.
    let increment_call = contract.increment();

    // Build a call to decrement the counter.
    let decrement_call = contract.decrement();

    // Send the transaction call twice for each event.
    for _ in 0..2 {
        let _ = increment_call.send().await?;
        let _ = decrement_call.send().await?;
    }

    // Poll for logs.
    increment_filter
        .into_stream()
        .take(2)
        .for_each(|log| async {
            match log {
                Ok((_event, log)) =&gt; {
                    println!("Received Increment: {log:?}");
                }
                Err(e) =&gt; {
                    println!("Error: {e:?}");
                }
            }
        })
        .await;

    decrement_filter
        .into_stream()
        .take(2)
        .for_each(|log| async {
            match log {
                Ok((_event, log)) =&gt; {
                    println!("Received Decrement: {log:?}");
                }
                Err(e) =&gt; {
                    println!("Error: {e:?}");
                }
            }
        })
        .await;

    Ok(())
}</code></pre>
<p>在 Github 上找到源代码 <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/subscriptions/examples/poll_logs.rs" title="" target="_blank">点击这里</a>。</p>
<div style="break-before: page; page-break-before: always;"></div><!-- DO NOT EDIT THIS FILE. IT IS GENERATED BY RUNNING `./scripts/update.sh` -->
<!-- ANY CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN -->
<!-- EDIT OR CREATE THIS TEMPLATE INSTEAD: ./src/templates/subscriptions/subscribe_blocks.md -->
<!-- LATEST UPDATE: https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="示例subscribe_blocks"><a class="header" href="#示例subscribe_blocks">示例：<code>subscribe_blocks</code></a></h2>
<h3 id="示例-58"><a class="header" href="#示例-58">示例</a></h3>
<p>运行此示例：</p>
<ul>
<li>克隆 <a href="https://github.com/alloy-rs/examples" title="" target="_blank">examples</a> 仓库：<code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>运行：<code>cargo run --example subscribe_blocks</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example of subscribing to blocks and watching block headers by polling.

use alloy::{
    node_bindings::Anvil,
    providers::{Provider, ProviderBuilder, WsConnect},
};
use eyre::Result;
use futures_util::{stream, StreamExt};

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    // Spin up a local Anvil node.
    // Ensure `anvil` is available in $PATH.
    let anvil = Anvil::new().block_time(1).try_spawn()?;

    // Create a provider.
    let ws = WsConnect::new(anvil.ws_endpoint());
    let provider = ProviderBuilder::new().on_ws(ws).await?;

    // Subscribe to blocks.
    let subscription = provider.subscribe_blocks().await?;
    let mut stream = subscription.into_stream().take(2);

    while let Some(block) = stream.next().await {
        println!(
            "Received block number: {}",
            block.header.number.expect("Failed to get block number")
        );
    }

    // Poll for block headers.
    let poller = provider.watch_blocks().await?;
    let mut stream = poller.into_stream().flat_map(stream::iter).take(2);

    while let Some(block_hash) = stream.next().await {
        println!("Polled for block header: {block_hash:?}");
    }

    Ok(())
}</code></pre>
<p>你可以在 Github 上找到源码 <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/subscriptions/examples/subscribe_blocks.rs" title="" target="_blank">here</a>。</p>
<div style="break-before: page; page-break-before: always;"></div><!-- DO NOT EDIT THIS FILE. IT IS GENERATED BY RUNNING `./scripts/update.sh` -->
<!-- ANY CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN -->
<!-- EDIT OR CREATE THIS TEMPLATE INSTEAD: ./src/templates/subscriptions/subscribe_logs.md -->
<!-- LATEST UPDATE: https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="示例-subscribe_logs"><a class="header" href="#示例-subscribe_logs">示例: <code>subscribe_logs</code></a></h2>
<h3 id="示例-59"><a class="header" href="#示例-59">示例</a></h3>
<p>运行此示例：</p>
<ul>
<li>克隆 <a href="https://github.com/alloy-rs/examples" title="" target="_blank">examples</a> 仓库: <code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>运行: <code>cargo run --example subscribe_logs</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example of subscribing and listening for specific contract events by `WebSocket` subscription.

use alloy::{
    primitives::address,
    providers::{Provider, ProviderBuilder, WsConnect},
    rpc::types::{BlockNumberOrTag, Filter},
};
use eyre::Result;
use futures_util::stream::StreamExt;

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    // Set up the WS transport which is consumed by the RPC client.
    let rpc_url = "wss://eth-mainnet.g.alchemy.com/v2/your-api-key";

    // Create the provider.
    let ws = WsConnect::new(rpc_url);
    let provider = ProviderBuilder::new().on_ws(ws).await?;

    // Create a filter to watch for UNI token transfers.
    let uniswap_token_address = address!("1f9840a85d5aF5bf1D1762F925BDADdC4201F984");
    let filter = Filter::new()
        .address(uniswap_token_address)
        // By specifying an `event` or `event_signature` we listen for a specific event of the
        // contract. In this case the `Transfer(address,address,uint256)` event.
        .event("Transfer(address,address,uint256)")
        .from_block(BlockNumberOrTag::Latest);

    // Subscribe to logs.
    let sub = provider.subscribe_logs(&amp;filter).await?;
    let mut stream = sub.into_stream();

    while let Some(log) = stream.next().await {
        println!("Uniswap token logs: {log:?}");
    }

    Ok(())
}</code></pre>
<p>在 Github 上查看源代码 <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/subscriptions/examples/subscribe_logs.rs" title="" target="_blank">here</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><!-- DO NOT EDIT THIS FILE. IT IS GENERATED BY RUNNING `./scripts/update.sh` -->
<!-- ANY CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN -->
<!-- EDIT OR CREATE THIS TEMPLATE INSTEAD: ./src/templates/subscriptions/subscribe_all_logs.md -->
<!-- LATEST UPDATE: https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="示例-subscribe_all_logs"><a class="header" href="#示例-subscribe_all_logs">示例: <code>subscribe_all_logs</code></a></h2>
<h3 id="示例-60"><a class="header" href="#示例-60">示例</a></h3>
<p>要运行这个示例:</p>
<ul>
<li>克隆 <a href="https://github.com/alloy-rs/examples" title="" target="_blank">examples</a> 仓库: <code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>运行: <code>cargo run --example subscribe_all_logs</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example of subscribing and listening for all contract events by `WebSocket` subscription.

use alloy::{
    primitives::address,
    providers::{Provider, ProviderBuilder, WsConnect},
    rpc::types::{BlockNumberOrTag, Filter},
    sol,
    sol_types::SolEvent,
};
use eyre::Result;
use futures_util::stream::StreamExt;

// Codegen from ABI file to interact with the contract.
sol!(
    #[allow(missing_docs)]
    #[sol(rpc)]
    IWETH9,
    "examples/abi/IWETH9.json"
);

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    // Set up the WS transport which is consumed by the RPC client.
    let rpc_url = "wss://eth-mainnet.g.alchemy.com/v2/your-api-key";

    // Create the provider.
    let ws = WsConnect::new(rpc_url);
    let provider = ProviderBuilder::new().on_ws(ws).await?;

    // Create a filter to watch for all WETH9 events.
    let weth9_token_address = address!("C02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2");
    let filter = Filter::new()
        // By NOT specifying an `event` or `event_signature` we listen to ALL events of the
        // contract.
        .address(weth9_token_address)
        .from_block(BlockNumberOrTag::Latest);

    // Subscribe to logs.
    let sub = provider.subscribe_logs(&amp;filter).await?;
    let mut stream = sub.into_stream();

    while let Some(log) = stream.next().await {
        // Match on topic 0, the hash of the signature of the event.
        match log.topic0() {
            // Match the `Approval(address,address,uint256)` event.
            Some(&amp;IWETH9::Approval::SIGNATURE_HASH) =&gt; {
                let IWETH9::Approval { src, guy, wad } = log.log_decode()?.inner.data;
                println!("Approval from {src} to {guy} of value {wad}");
            }
            // Match the `Transfer(address,address,uint256)` event.
            Some(&amp;IWETH9::Transfer::SIGNATURE_HASH) =&gt; {
                let IWETH9::Transfer { src, dst, wad } = log.log_decode()?.inner.data;
                println!("Transfer from {src} to {dst} of value {wad}");
            }
            // WETH9's `Deposit(address,uint256)` and `Withdrawal(address,uint256)` events are not
            // handled here.
            _ =&gt; (),
        }
    }

    Ok(())
}</code></pre>
<p>在 Github 上查看源代码 <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/subscriptions/examples/subscribe_all_logs.rs" title="" target="_blank">这里</a>。</p>
<div style="break-before: page; page-break-before: always;"></div><!-- DO NOT EDIT THIS FILE. IT IS GENERATED BY RUNNING `./scripts/update.sh` -->
<!-- ANY CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN -->
<!-- EDIT OR CREATE THIS TEMPLATE INSTEAD: ./src/templates/subscriptions/subscribe_pending_transactions.md -->
<!-- LATEST UPDATE: https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="示例-subscribe_pending_transactions"><a class="header" href="#示例-subscribe_pending_transactions">示例: <code>subscribe_pending_transactions</code></a></h2>
<h3 id="示例-61"><a class="header" href="#示例-61">示例</a></h3>
<p>运行该示例：</p>
<ul>
<li>克隆 <a href="https://github.com/alloy-rs/examples" title="" target="_blank">examples</a> 仓库: <code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>运行: <code>cargo run --example subscribe_pending_transactions</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example of subscribing and listening for pending transactions in the public mempool by
//! `WebSocket` subscription.

use alloy::providers::{Provider, ProviderBuilder, WsConnect};
use eyre::Result;
use futures_util::StreamExt;

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    // Set up the WS transport which is consumed by the RPC client.
    let rpc_url = "wss://eth-mainnet.g.alchemy.com/v2/your-api-key";

    // Create the provider.
    let ws = WsConnect::new(rpc_url);
    let provider = ProviderBuilder::new().on_ws(ws).await?;

    // Subscribe to pending transactions.
    // Alteratively use `subscribe_full_pending_transactions` to get the full transaction details
    // directly if supported by the RPC provider.
    let sub = provider.subscribe_pending_transactions().await?;

    // Wait and take the next 3 transactions.
    let mut stream = sub.into_stream().take(3);

    println!("Awaiting pending transactions...");

    // Take the stream and print the pending transaction.
    let handle = tokio::spawn(async move {
        while let Some(tx_hash) = stream.next().await {
            // Get the transaction details.
            if let Ok(tx) = provider.get_transaction_by_hash(tx_hash).await {
                println!("Transaction details: {tx:#?}");
            }
        }
    });

    handle.await?;

    Ok(())
}</code></pre>
<p>在 Github 上找到源代码 <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/subscriptions/examples/subscribe_pending_transactions.rs" title="" target="_blank">这里</a>。</p>
<div style="break-before: page; page-break-before: always;"></div><!-- DO NOT EDIT THIS FILE. IT IS GENERATED BY RUNNING `./scripts/update.sh` -->
<!-- ANY CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN -->
<!-- EDIT OR CREATE THIS TEMPLATE INSTEAD: ./src/templates/subscriptions/event_multiplexer.md -->
<!-- LATEST UPDATE: https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="示例-event_multiplexer"><a class="header" href="#示例-event_multiplexer">示例: <code>event_multiplexer</code></a></h2>
<h3 id="示例-62"><a class="header" href="#示例-62">示例</a></h3>
<p>运行本示例：</p>
<ul>
<li>克隆 <a href="https://github.com/alloy-rs/examples" title="" target="_blank">examples</a> 仓库: <code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>运行: <code>cargo run --example event_multiplexer</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example of multiplexing the watching of event logs.

use alloy::{
    node_bindings::Anvil,
    primitives::I256,
    providers::{ProviderBuilder, WsConnect},
    sol,
    sol_types::SolEvent,
};
use eyre::Result;
use futures_util::StreamExt;
use std::str::FromStr;

// Codegen from embedded Solidity code and precompiled bytecode.
// solc v0.8.26; solc EventMultiplexer.sol --via-ir --optimize --bin
sol!(
    #[allow(missing_docs)]
    #[sol(rpc, bytecode = "60808060405234601557610207908161001b8239f35b600080fdfe6080604052600436101561001257600080fd5b60003560e01c80634350913814610156578063a5f3c23b14610108578063adefc37b146100ba5763bbe93d911461004857600080fd5b346100b557610056366101bb565b818102919060008212600160ff1b82141661009f57818305149015171561009f57337fd7a123d4c8e44db3186e04b9c96c102287276929c930f2e8abcaa555ef5dcacc600080a3005b634e487b7160e01b600052601160045260246000fd5b600080fd5b346100b5576100c8366101bb565b906000828203921281831281169183139015161761009f57337f32e913bf2ad35da1e845597618bb9f3f80642a68dd39f30a093a7838aa61fb27600080a3005b346100b557610116366101bb565b906000828201928312911290801582169115161761009f57337f6da406ea462447ed7804b4a4dc69c67b53d3d45a50381ae3e9cf878c9d7c23df600080a3005b346100b557610164366101bb565b9081156101a557600160ff1b811460001983141661009f5705337f1c1e8bbe327890ea8d3f5b22370a56c3fcef7ff82f306161f64647fe5d285881600080a3005b634e487b7160e01b600052601260045260246000fd5b60409060031901126100b557600435906024359056fea2646970667358221220d876fbacf1e90fc174532f3525420c446351b467f788f9d7a726a7d55045909664736f6c634300081a0033")]
    contract EventMultiplexer {
        event Add(address indexed sender, int256 indexed value);
        event Sub(address indexed sender, int256 indexed value);
        event Mul(address indexed sender, int256 indexed value);
        event Div(address indexed sender, int256 indexed value);

        function add(int256 a, int256 b) public {
            emit Add(msg.sender, a + b);
        }

        function sub(int256 a, int256 b) public {
            emit Sub(msg.sender, a - b);
        }

        function mul(int256 a, int256 b) public {
            emit Mul(msg.sender, a * b);
        }

        function div(int256 a, int256 b) public {
            emit Div(msg.sender, a / b);
        }
    }
);

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    // Spin up a local Anvil node.
    // Ensure `anvil` is available in $PATH.
    let anvil = Anvil::new().block_time(1).try_spawn()?;

    // Create a provider.
    let ws = WsConnect::new(anvil.ws_endpoint());
    let provider = ProviderBuilder::new().on_ws(ws).await?;

    // Deploy the `EventExample` contract.
    let contract = EventMultiplexer::deploy(provider).await?;

    println!("Deployed contract at: {}", contract.address());

    // Create filters for each event.
    let add_filter = contract.Add_filter().watch().await?;
    let sub_filter = contract.Sub_filter().watch().await?;
    let mul_filter = contract.Mul_filter().watch().await?;
    let div_filter = contract.Div_filter().watch().await?;

    let a = I256::from_str("1")?;
    let b = I256::from_str("1")?;

    // Build the transaction calls.
    let add_call = contract.add(a, b);
    let sub_call = contract.sub(a, b);
    let mul_call = contract.mul(a, b);
    let div_call = contract.div(a, b);

    // Send the transaction calls.
    let _ = add_call.send().await?;
    let _ = sub_call.send().await?;
    let _ = mul_call.send().await?;
    let _ = div_call.send().await?;

    // Convert the filters into streams.
    let mut add_stream = add_filter.into_stream();
    let mut sub_stream = sub_filter.into_stream();
    let mut mul_stream = mul_filter.into_stream();
    let mut div_stream = div_filter.into_stream();

    let add_log = &amp;EventMultiplexer::Add::SIGNATURE_HASH;
    let sub_log = &amp;EventMultiplexer::Sub::SIGNATURE_HASH;
    let mul_log = &amp;EventMultiplexer::Mul::SIGNATURE_HASH;
    let div_log = &amp;EventMultiplexer::Div::SIGNATURE_HASH;

    // Use tokio::select! to multiplex the streams and capture the log
    // tokio::select! will return the first event that arrives from any of the streams
    // The for loop helps capture all the logs.
    for _ in 0..4 {
        let log = tokio::select! {
            Some(log) = add_stream.next() =&gt; {
                log?.1
            }
            Some(log) = sub_stream.next() =&gt; {
                log?.1
            }
            Some(log) = mul_stream.next() =&gt; {
                log?.1
            }
            Some(log) = div_stream.next() =&gt; {
                log?.1
            }
        };

        let topic = &amp;log.topics()[0];

        if topic == add_log {
            println!("Received Add: {log:?}");
        } else if topic == sub_log {
            println!("Received Sub: {log:?}");
        } else if topic == mul_log {
            println!("Received Mul: {log:?}");
        } else if topic == div_log {
            println!("Received Div: {log:?}");
        }
    }

    Ok(())
}</code></pre>
<p>可以在 Github 上找到源代码 <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/subscriptions/examples/event_multiplexer.rs" title="" target="_blank">here</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="交易-1"><a class="header" href="#交易-1">交易</a></h2>
<ul>
<li><a href="examples/transactions/decode_input.html">解码输入</a></li>
<li><a href="examples/transactions/encode_decode_eip1559.html">编码和解码 EIP-1559 交易</a></li>
<li><a href="examples/transactions/gas_price_usd.html">获取以美元计价的 gas 价格</a></li>
<li><a href="examples/transactions/trace_call.html">调用跟踪</a></li>
<li><a href="examples/transactions/trace_transaction.html">交易跟踪</a></li>
<li><a href="examples/transactions/transfer_erc20.html">转账 ERC20 代币</a></li>
<li><a href="examples/transactions/transfer_eth.html">转账 ETH</a></li>
<li><a href="examples/transactions/send_raw_transaction.html">签署并发送原始交易</a></li>
<li><a href="examples/transactions/with_access_list.html">发送带访问列表的交易</a></li>
<li><a href="examples/transactions/send_eip1559_transaction.html">发送 EIP-1559 交易</a></li>
<li><a href="examples/transactions/send_legacy_transaction.html">发送传统交易</a></li>
<li><a href="examples/transactions/send_eip4844_transaction.html">发送 EIP-4844 交易</a></li>
<li><a href="examples/transactions/send_private_transaction.html">使用 Flashbots Protect 发送私密交易</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><!-- DO NOT EDIT THIS FILE. IT IS GENERATED BY RUNNING `./scripts/update.sh` -->
<!-- ANY CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN -->
<!-- EDIT OR CREATE THIS TEMPLATE INSTEAD: ./src/templates/transactions/decode_input.md -->
<!-- LATEST UPDATE: https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="示例decode_input"><a class="header" href="#示例decode_input">示例：<code>decode_input</code></a></h2>
<h3 id="示例-63"><a class="header" href="#示例-63">示例</a></h3>
<p>要运行此示例：</p>
<ul>
<li>克隆 <a href="https://github.com/alloy-rs/examples" title="" target="_blank">examples</a> 仓库: <code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>运行: <code>cargo run --example decode_input</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example of how to decode the input of a transaction.

use alloy::{primitives::hex, sol, sol_types::SolCall};
use eyre::Result;

// Codegen from excerpt of Uniswap V2 Router interface.
// See: https://docs.uniswap.org/contracts/v2/reference/smart-contracts/router-02
sol!(
    #[allow(missing_docs)]
    function swapExactTokensForTokens(
        uint256 amountIn,
        uint256 amountOutMin,
        address[] calldata path,
        address to,
        uint256 deadline
      ) external returns (uint256[] memory amounts);
);

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    println!("Decoding https://etherscan.io/tx/0xd1b449d8b1552156957309bffb988924569de34fbf21b51e7af31070cc80fe9a");

    let input = "0x38ed173900000000000000000000000000000000000000000001a717cc0a3e4f84c00000000000000000000000000000000000000000000000000000000000000283568400000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000201f129111c60401630932d9f9811bd5b5fff34e000000000000000000000000000000000000000000000000000000006227723d000000000000000000000000000000000000000000000000000000000000000200000000000000000000000095ad61b0a150d79219dcf64e1e6cc01f0b64c4ce000000000000000000000000dac17f958d2ee523a2206206994597c13d831ec7";
    let input = hex::decode(input)?;

    // Decode the input using the generated `swapExactTokensForTokens` bindings.
    let decoded = swapExactTokensForTokensCall::abi_decode(&amp;input, false);

    match decoded {
        Ok(decoded) =&gt; {
            let path = decoded.path;

            println!(
                "Swap {} of token {} to {} of token {}",
                decoded.amountIn,
                path.first().expect("Path is empty"),
                decoded.amountOutMin,
                path.last().expect("Path is empty")
            );
        }
        Err(e) =&gt; {
            println!("Error decoding input: {e:?}");
        }
    }

    Ok(())
}</code></pre>
<p>可以在 Github 上找到源代码 <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/transactions/examples/decode_input.rs" title="" target="_blank">here</a>。</p>
<div style="break-before: page; page-break-before: always;"></div><!-- 请勿编辑此文件。它是通过运行 `./scripts/update.sh` 生成的 -->
<!-- 对这个文件的任何更改都将被覆盖 -->
<!-- 请编辑或创建此模板：./src/templates/transactions/encode_decode_eip1559.md -->
<!-- 最新更新： https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="示例-encode_decode_eip1559"><a class="header" href="#示例-encode_decode_eip1559">示例: <code>encode_decode_eip1559</code></a></h2>
<h3 id="示例-64"><a class="header" href="#示例-64">示例</a></h3>
<p>要运行此示例：</p>
<ul>
<li>克隆 <a href="https://github.com/alloy-rs/examples" title="" target="_blank">examples</a> 仓库：<code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>运行：<code>cargo run --example encode_decode_eip1559</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example showing how to encode and decode an [EIP-1559](https://eips.ethereum.org/EIPS/eip-1559) transaction.

use alloy::{
    consensus::{SignableTransaction, TxEip1559},
    eips::eip2930::AccessList,
    primitives::{address, b256, hex, Signature, TxKind, U256},
};
use eyre::Result;

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    // EIP1559 transaction: &lt;https://etherscan.io/tx/0x0ec0b6a2df4d87424e5f6ad2a654e27aaeb7dac20ae9e8385cc09087ad532ee0&gt;
    let tx_hash = b256!("0ec0b6a2df4d87424e5f6ad2a654e27aaeb7dac20ae9e8385cc09087ad532ee0");

    // Signer of the transaction.
    let signer = address!("DD6B8b3dC6B7AD97db52F08a275FF4483e024CEa");

    // Construct the EIP-1559 transaction.
    let tx = TxEip1559 {
        chain_id: 1,
        nonce: 0x42,
        gas_limit: 44386,
        to: TxKind::Call( address!("6069a6c32cf691f5982febae4faf8a6f3ab2f0f6")),
        value: U256::from(0_u64),
        input: hex!("a22cb4650000000000000000000000005eee75727d804a2b13038928d36f8b188945a57a0000000000000000000000000000000000000000000000000000000000000000").into(),
        max_fee_per_gas: 0x4a817c800,
        max_priority_fee_per_gas: 0x3b9aca00,
        access_list: AccessList::default(),
    };

    // Construct the signature of the transaction.
    let signature = Signature::from_scalars_and_parity(
        b256!("840cfc572845f5786e702984c2a582528cad4b49b2a10b9db1be7fca90058565"),
        b256!("25e7109ceb98168d95b09b18bbf6b685130e0562f233877d492b94eee0c5b6d1"),
        false,
    )?;

    // Convert the transaction into a signed transaction.
    let signed_tx = tx.into_signed(signature);
    assert_eq!(*signed_tx.hash(), tx_hash);

    // Recover the signer from the signed transaction to ensure it matches the expected signer.
    let recovered_signer = signed_tx.recover_signer()?;
    assert_eq!(recovered_signer, signer);

    Ok(())
}</code></pre>
<p>在 Github 上可以找到源码 <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/transactions/examples/encode_decode_eip1559.rs" title="" target="_blank">这里</a>。</p>
<div style="break-before: page; page-break-before: always;"></div><!-- DO NOT EDIT THIS FILE. IT IS GENERATED BY RUNNING `./scripts/update.sh` -->
<!-- ANY CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN -->
<!-- EDIT OR CREATE THIS TEMPLATE INSTEAD: ./src/templates/transactions/gas_price_usd.md -->
<!-- LATEST UPDATE: https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="示例-gas_price_usd"><a class="header" href="#示例-gas_price_usd">示例: <code>gas_price_usd</code></a></h2>
<h3 id="示例-65"><a class="header" href="#示例-65">示例</a></h3>
<p>运行这个示例:</p>
<ul>
<li>克隆 <a href="https://github.com/alloy-rs/examples" title="" target="_blank">examples</a> 仓库: <code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>运行: <code>cargo run --example gas_price_usd</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example of how to get the gas price in USD using the Chainlink ETH/USD feed.

use alloy::{
    network::TransactionBuilder,
    node_bindings::Anvil,
    primitives::{address, utils::format_units, Address, Bytes, U256},
    providers::{Provider, ProviderBuilder},
    rpc::types::TransactionRequest,
    sol,
    sol_types::SolCall,
};
use eyre::Result;
use std::str::FromStr;

const ETH_USD_FEED: Address = address!("5f4eC3Df9cbd43714FE2740f5E3616155c5b8419");
const ETH_USD_FEED_DECIMALS: u8 = 8;
const ETH_DECIMALS: u32 = 18;

// Codegen from excerpt of Chainlink Aggregator interface.
// See: https://etherscan.io/address/0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419#code
sol!(
    #[allow(missing_docs)]
    function latestAnswer() external view returns (int256);
);

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    // Spin up a forked Anvil node.
    // Ensure `anvil` is available in $PATH.
    let anvil = Anvil::new().fork("https://eth.merkle.io").try_spawn()?;

    // Create a provider.
    let rpc_url = anvil.endpoint().parse()?;
    let provider = ProviderBuilder::new().on_http(rpc_url);

    // Create a call to get the latest answer from the Chainlink ETH/USD feed.
    let call = latestAnswerCall {}.abi_encode();
    let input = Bytes::from(call);

    // Call the Chainlink ETH/USD feed contract.
    let tx = TransactionRequest::default().with_to(ETH_USD_FEED).with_input(input);

    let response = provider.call(&amp;tx).await?;
    let result = U256::from_str(&amp;response.to_string())?;

    // Get the gas price of the network.
    let wei_per_gas = provider.get_gas_price().await?;

    // Convert the gas price to Gwei and USD.
    let gwei = format_units(wei_per_gas, "gwei")?.parse::&lt;f64&gt;()?;
    let usd = get_usd_value(wei_per_gas, result)?;

    println!("Gas price in Gwei: {gwei}");
    println!("Gas price in USD: {usd}");

    Ok(())
}

fn get_usd_value(amount: u128, price_usd: U256) -&gt; Result&lt;f64&gt; {
    let base = U256::from(10).pow(U256::from(ETH_DECIMALS));
    let value = U256::from(amount) * price_usd / base;
    let formatted = format_units(value, ETH_USD_FEED_DECIMALS)?.parse::&lt;f64&gt;()?;

    Ok(formatted)
}</code></pre>
<p>在 Github 上找到源码 <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/transactions/examples/gas_price_usd.rs" title="" target="_blank">here</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><!-- 不要编辑此文件。它是通过运行 `./scripts/update.sh` 生成的 -->
<!-- 对此文件所做的任何更改将被覆盖 -->
<!-- 请编辑或创建此模板： ./src/templates/transactions/trace_call.md -->
<!-- 最新更新：https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="示例trace_call"><a class="header" href="#示例trace_call">示例：<code>trace_call</code></a></h2>
<h3 id="示例-66"><a class="header" href="#示例-66">示例</a></h3>
<p>要运行此示例：</p>
<ul>
<li>克隆 <a href="https://github.com/alloy-rs/examples" title="" target="_blank">examples</a> 仓库：<code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>运行：<code>cargo run --example trace_call</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example of how to trace a transaction using `trace_call`.

use alloy::{
    network::TransactionBuilder,
    primitives::{address, U256},
    providers::{ext::TraceApi, ProviderBuilder},
    rpc::types::{trace::parity::TraceType, TransactionRequest},
};
use eyre::Result;

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    // Create a provider.
    let rpc_url = "https://eth.merkle.io".parse()?;
    let provider = ProviderBuilder::new().on_http(rpc_url);

    // Build a transaction to send 100 wei from Alice to Vitalik.
    let alice = address!("f39Fd6e51aad88F6F4ce6aB8827279cffFb92266");
    let vitalik = address!("d8dA6BF26964aF9D7eEd9e03E53415D37aA96045");
    let tx =
        TransactionRequest::default().with_from(alice).with_to(vitalik).with_value(U256::from(100));

    // Trace the transaction on top of the latest block.
    let trace_type = [TraceType::Trace];
    let result = provider.trace_call(&amp;tx, &amp;trace_type).await?;

    println!("{:?}", result.trace);

    Ok(())
}</code></pre>
<p>在 Github 上可以找到源代码 <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/transactions/examples/trace_call.rs" title="" target="_blank">这里</a>。</p>
<div style="break-before: page; page-break-before: always;"></div><!-- DO NOT EDIT THIS FILE. IT IS GENERATED BY RUNNING `./scripts/update.sh` -->
<!-- ANY CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN -->
<!-- EDIT OR CREATE THIS TEMPLATE INSTEAD: ./src/templates/transactions/trace_transaction.md -->
<!-- LATEST UPDATE: https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="示例-trace_transaction"><a class="header" href="#示例-trace_transaction">示例: <code>trace_transaction</code></a></h2>
<h3 id="示例-67"><a class="header" href="#示例-67">示例</a></h3>
<p>要运行此示例：</p>
<ul>
<li>克隆 <a href="https://github.com/alloy-rs/examples" title="" target="_blank">examples</a> 仓库: <code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>运行: <code>cargo run --example trace_transaction</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example of how to trace a transaction using `trace_transaction`.

use alloy::{
    node_bindings::Anvil,
    primitives::b256,
    providers::{ext::DebugApi, ProviderBuilder},
    rpc::types::trace::geth::{
        GethDebugBuiltInTracerType, GethDebugTracerType, GethDebugTracingOptions,
        GethDefaultTracingOptions,
    },
};
use eyre::Result;

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    // Spin up a forked Anvil node.
    // Ensure `anvil` is available in $PATH.
    let anvil = Anvil::new().fork("https://eth.merkle.io").try_spawn()?;

    // Create a provider.
    let rpc_url = anvil.endpoint().parse()?;
    let provider = ProviderBuilder::new().on_http(rpc_url);

    // Hash of the tx we want to trace.
    let hash = b256!("97a02abf405d36939e5b232a5d4ef5206980c5a6661845436058f30600c52df7");

    // Trace with the default tracer.
    let default_options = GethDebugTracingOptions::default();
    let result = provider.debug_trace_transaction(hash, default_options).await?;

    println!("DEFAULT_TRACE: {result:?}");

    // Trace with built-in call tracer.
    let call_options = GethDebugTracingOptions {
        config: GethDefaultTracingOptions {
            disable_storage: Some(true),
            enable_memory: Some(false),
            ..Default::default()
        },
        tracer: Some(GethDebugTracerType::BuiltInTracer(GethDebugBuiltInTracerType::CallTracer)),
        ..Default::default()
    };
    let result = provider.debug_trace_transaction(hash, call_options).await?;

    println!("CALL_TRACE: {result:?}");

    // Trace using a custom JavaScript tracer.
    let js_options = GethDebugTracingOptions {
        tracer: Some(GethDebugTracerType::JsTracer("{data: [], fault: function(log) {}, step: function(log) { if(log.op.toString() == \"DELEGATECALL\") this.data.push(log.stack.peek(0)); }, result: function() { return this.data; }}".into())),
        ..Default::default()
    };
    let result = provider.debug_trace_transaction(hash, js_options).await?;

    println!("JS_TRACER: {result:?}");

    Ok(())
}</code></pre>
<p>在 Github 上可以找到源码 <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/transactions/examples/trace_transaction.rs" title="" target="_blank">这里</a>。</p>
<div style="break-before: page; page-break-before: always;"></div><!-- DO NOT EDIT THIS FILE. IT IS GENERATED BY RUNNING `./scripts/update.sh` -->
<!-- ANY CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN -->
<!-- EDIT OR CREATE THIS TEMPLATE INSTEAD: ./src/templates/transactions/transfer_erc20.md -->
<!-- LATEST UPDATE: https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="示例-transfer_erc20"><a class="header" href="#示例-transfer_erc20">示例: <code>transfer_erc20</code></a></h2>
<h3 id="示例-68"><a class="header" href="#示例-68">示例</a></h3>
<p>要运行此示例:</p>
<ul>
<li>克隆 <a href="https://github.com/alloy-rs/examples" title="" target="_blank">examples</a> 仓库：<code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>运行：<code>cargo run --example transfer_erc20</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example of how to transfer ERC20 tokens from one account to another.

use alloy::{node_bindings::Anvil, primitives::U256, providers::ProviderBuilder, sol};
use eyre::Result;

// Codegen from artifact.
sol!(
    #[allow(missing_docs)]
    #[sol(rpc)]
    ERC20Example,
    "examples/artifacts/ERC20Example.json"
);

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    // Spin up a forked Anvil node.
    // Ensure `anvil` is available in $PATH.
    let anvil = Anvil::new().fork("https://eth.merkle.io").try_spawn()?;

    // Create a provider.
    let rpc_url = anvil.endpoint().parse()?;
    let provider = ProviderBuilder::new().on_http(rpc_url);

    // Create two users, Alice and Bob.
    let alice = anvil.addresses()[0];
    let bob = anvil.addresses()[1];

    // Deploy the `ERC20Example` contract.
    let contract = ERC20Example::deploy(provider).await?;

    // Register the balances of Alice and Bob before the transfer.
    let alice_before_balance = contract.balanceOf(alice).call().await?._0;
    let bob_before_balance = contract.balanceOf(bob).call().await?._0;

    // Transfer and wait for inclusion.
    let amount = U256::from(100);
    let tx_hash = contract.transfer(bob, amount).send().await?.watch().await?;

    println!("Sent transaction: {tx_hash}");

    // Register the balances of Alice and Bob after the transfer.
    let alice_after_balance = contract.balanceOf(alice).call().await?._0;
    let bob_after_balance = contract.balanceOf(bob).call().await?._0;

    // Check the balances of Alice and Bob after the transfer.
    assert_eq!(alice_before_balance - alice_after_balance, amount);
    assert_eq!(bob_after_balance - bob_before_balance, amount);

    Ok(())
}</code></pre>
<p>在 Github 上查看源代码 <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/transactions/examples/transfer_erc20.rs" title="" target="_blank">这里</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><!-- 请勿编辑此文件。它是通过运行 `./scripts/update.sh` 生成的。-->
<!-- 对该文件所做的任何更改都将被覆盖。-->
<!-- 请编辑或创建此模板： ./src/templates/transactions/transfer_eth.md -->
<!-- 最新更新： https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="示例transfer_eth"><a class="header" href="#示例transfer_eth">示例：<code>transfer_eth</code></a></h2>
<h3 id="示例-69"><a class="header" href="#示例-69">示例</a></h3>
<p>要运行此示例：</p>
<ul>
<li>克隆 <a href="https://github.com/alloy-rs/examples" title="" target="_blank">examples</a> 仓库: <code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>运行: <code>cargo run --example transfer_eth</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example of how to transfer ETH from one account to another.

use alloy::{
    network::{EthereumWallet, TransactionBuilder},
    node_bindings::Anvil,
    primitives::U256,
    providers::{Provider, ProviderBuilder},
    rpc::types::TransactionRequest,
    signers::local::PrivateKeySigner,
};
use eyre::Result;

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    // Spin up a local Anvil node.
    // Ensure `anvil` is available in $PATH.
    let anvil = Anvil::new().try_spawn()?;

    // Get the RPC URL.
    let rpc_url = anvil.endpoint().parse()?;

    // Set up signer from the first default Anvil account (Alice).
    let signer: PrivateKeySigner = anvil.keys()[0].clone().into();
    let wallet = EthereumWallet::from(signer);

    // Create a provider with the wallet.
    let provider =
        ProviderBuilder::new().with_recommended_fillers().wallet(wallet).on_http(rpc_url);

    // Build a transaction to send 100 wei from Alice to Bob.
    // The `from` field is automatically filled to the first signer's address (Alice).
    let bob = anvil.addresses()[1];
    let tx = TransactionRequest::default().with_to(bob).with_value(U256::from(100));

    // Send the transaction and listen for the transaction to be included.
    let tx_hash = provider.send_transaction(tx).await?.watch().await?;

    println!("Sent transaction: {tx_hash}");

    Ok(())
}</code></pre>
<p>在 Github 上可以找到源码 <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/transactions/examples/transfer_eth.rs" title="" target="_blank">这里</a>。</p>
<div style="break-before: page; page-break-before: always;"></div><!-- DO NOT EDIT THIS FILE. IT IS GENERATED BY RUNNING `./scripts/update.sh` -->
<!-- ANY CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN -->
<!-- EDIT OR CREATE THIS TEMPLATE INSTEAD: ./src/templates/transactions/send_raw_transaction.md -->
<!-- LATEST UPDATE: https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="示例-send_raw_transaction"><a class="header" href="#示例-send_raw_transaction">示例: <code>send_raw_transaction</code></a></h2>
<h3 id="示例-70"><a class="header" href="#示例-70">示例</a></h3>
<p>运行此示例的方法：</p>
<ul>
<li>克隆 <a href="https://github.com/alloy-rs/examples" title="" target="_blank">examples</a> 仓库: <code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>运行: <code>cargo run --example send_raw_transaction</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example of signing, encoding and sending a raw transaction using a wallet.

use alloy::{
    network::{EthereumWallet, TransactionBuilder},
    node_bindings::Anvil,
    primitives::U256,
    providers::{Provider, ProviderBuilder},
    rpc::types::TransactionRequest,
    signers::local::PrivateKeySigner,
};
use eyre::Result;

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    // Spin up a forked Anvil node.
    // Ensure `anvil` is available in $PATH.
    let anvil = Anvil::new().try_spawn()?;

    // Create a provider.
    let rpc_url = anvil.endpoint().parse()?;
    let provider = ProviderBuilder::new().on_http(rpc_url);

    // Set up signer from the first default Anvil account (Alice).
    let signer: PrivateKeySigner = anvil.keys()[0].clone().into();
    let wallet = EthereumWallet::from(signer);

    // Create two users, Alice and Bob.
    let alice = anvil.addresses()[0];
    let bob = anvil.addresses()[1];

    // Build a transaction to send 100 wei from Alice to Bob.
    // The `from` field is automatically filled to the first signer's address (Alice).
    let tx = TransactionRequest::default()
        .with_to(bob)
        .with_nonce(0)
        .with_chain_id(anvil.chain_id())
        .with_value(U256::from(100))
        .with_gas_limit(21_000)
        .with_max_priority_fee_per_gas(1_000_000_000)
        .with_max_fee_per_gas(20_000_000_000);

    // Build and sign the transaction using the `EthereumWallet` with the provided wallet.
    let tx_envelope = tx.build(&amp;wallet).await?;

    // Send the raw transaction and retrieve the transaction receipt.
    // [Provider::send_tx_envelope] is a convenience method that encodes the transaction using
    // EIP-2718 encoding and broadcasts it to the network using [Provider::send_raw_transaction].
    let receipt = provider.send_tx_envelope(tx_envelope).await?.get_receipt().await?;

    println!("Sent transaction: {}", receipt.transaction_hash);

    assert_eq!(receipt.from, alice);
    assert_eq!(receipt.to, Some(bob));

    Ok(())
}</code></pre>
<p>在 Github 上查看源码 <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/transactions/examples/send_raw_transaction.rs" title="" target="_blank">这里</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><!-- DO NOT EDIT THIS FILE. IT IS GENERATED BY RUNNING `./scripts/update.sh` -->
<!-- ANY CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN -->
<!-- EDIT OR CREATE THIS TEMPLATE INSTEAD: ./src/templates/transactions/with_access_list.md -->
<!-- LATEST UPDATE: https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="示例-with_access_list-1"><a class="header" href="#示例-with_access_list-1">示例: <code>with_access_list</code></a></h2>
<h3 id="示例-71"><a class="header" href="#示例-71">示例</a></h3>
<p>运行本示例：</p>
<ul>
<li>克隆 <a href="https://github.com/alloy-rs/examples" title="" target="_blank">examples</a> 仓库: <code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>运行: <code>cargo run --example with_access_list</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example of sending a EIP-1559 transaction with access list.

use alloy::{
    node_bindings::Anvil,
    providers::{Provider, ProviderBuilder},
    rpc::types::TransactionRequest,
    sol,
};
use eyre::Result;

// Codegen from artifact.
sol!(
    #[allow(missing_docs)]
    #[sol(rpc)]
    SimpleStorage,
    "examples/artifacts/SimpleStorage.json"
);

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    // Spin up a local Anvil node.
    // Ensure `anvil` is available in $PATH.
    let anvil = Anvil::new().try_spawn()?;

    // Create a provider.
    let provider =
        ProviderBuilder::new().with_recommended_fillers().on_builtin(&amp;anvil.endpoint()).await?;

    // Deploy the `SimpleStorage` contract.
    let alice = anvil.addresses()[0];
    let contract_address = SimpleStorage::deploy_builder(provider.clone(), "initial".to_string())
        .from(alice)
        .deploy()
        .await?;
    let contract = SimpleStorage::new(contract_address, provider.clone());

    // Build a transaction to set the values of the contract.
    // The `from` field is automatically filled to the first signer's address (Alice).
    let set_value_call = contract.setValues("hello".to_string(), "world".to_string());
    let calldata = set_value_call.calldata().to_owned();
    let bob = anvil.addresses()[1];
    let tx = TransactionRequest::default().from(bob).to(contract_address).input(calldata.into());

    // Create an access list for the transaction.
    let access_list_with_gas_used = provider.create_access_list(&amp;tx).await?;

    // Add the access list to the transaction.
    let tx_with_access_list = tx.access_list(access_list_with_gas_used.access_list);

    // Send the transaction with the access list.
    let tx_hash = provider.send_transaction(tx_with_access_list).await?.watch().await?;

    println!("Transaction hash: {tx_hash}");

    // Check the value of the contract.
    let value = contract.getValue().call().await?;

    assert_eq!(value._0, "hello".to_string());

    Ok(())
}</code></pre>
<p>在 Github 上查看源码 <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/transactions/examples/with_access_list.rs" title="" target="_blank">here</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><!-- DO NOT EDIT THIS FILE. IT IS GENERATED BY RUNNING `./scripts/update.sh` -->
<!-- ANY CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN -->
<!-- EDIT OR CREATE THIS TEMPLATE INSTEAD: ./src/templates/transactions/send_eip1559_transaction.md -->
<!-- LATEST UPDATE: https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="示例-send_eip1559_transaction-1"><a class="header" href="#示例-send_eip1559_transaction-1">示例: <code>send_eip1559_transaction</code></a></h2>
<h3 id="示例-72"><a class="header" href="#示例-72">示例</a></h3>
<p>要运行这个示例：</p>
<ul>
<li>克隆 <a href="https://github.com/alloy-rs/examples" title="" target="_blank">examples</a> 仓库：<code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>运行：<code>cargo run --example send_eip1559_transaction</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example showing how to send an [EIP-1559](https://eips.ethereum.org/EIPS/eip-1559) transaction.

use alloy::{
    network::TransactionBuilder,
    node_bindings::Anvil,
    primitives::U256,
    providers::{Provider, ProviderBuilder},
    rpc::types::TransactionRequest,
};
use eyre::Result;

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    // Spin up a local Anvil node.
    // Ensure `anvil` is available in $PATH.
    let anvil = Anvil::new().try_spawn()?;

    // Create a provider.
    let rpc_url = anvil.endpoint().parse()?;
    let provider = ProviderBuilder::new().on_http(rpc_url);

    // Create two users, Alice and Bob.
    let alice = anvil.addresses()[0];
    let bob = anvil.addresses()[1];

    // Build a transaction to send 100 wei from Alice to Bob.
    // The `from` field is automatically filled to the first signer's address (Alice).
    let tx = TransactionRequest::default()
        .with_to(bob)
        .with_nonce(0)
        .with_chain_id(anvil.chain_id())
        .with_value(U256::from(100))
        .with_gas_limit(21_000)
        .with_max_priority_fee_per_gas(1_000_000_000)
        .with_max_fee_per_gas(20_000_000_000);

    // Send the transaction and wait for the broadcast.
    let pending_tx = provider.send_transaction(tx).await?;

    println!("Pending transaction... {}", pending_tx.tx_hash());

    // Wait for the transaction to be included and get the receipt.
    let receipt = pending_tx.get_receipt().await?;

    println!(
        "Transaction included in block {}",
        receipt.block_number.expect("Failed to get block number")
    );

    assert_eq!(receipt.from, alice);
    assert_eq!(receipt.to, Some(bob));

    Ok(())
}</code></pre>
<p>在 Github 上可以找到源代码 <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/transactions/examples/send_eip1559_transaction.rs" title="" target="_blank">这里</a>。</p>
<div style="break-before: page; page-break-before: always;"></div><!-- DO NOT EDIT THIS FILE. IT IS GENERATED BY RUNNING `./scripts/update.sh` -->
<!-- ANY CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN -->
<!-- EDIT OR CREATE THIS TEMPLATE INSTEAD: ./src/templates/transactions/send_legacy_transaction.md -->
<!-- LATEST UPDATE: https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="示例-send_legacy_transaction-1"><a class="header" href="#示例-send_legacy_transaction-1">示例: <code>send_legacy_transaction</code></a></h2>
<h3 id="示例-73"><a class="header" href="#示例-73">示例</a></h3>
<p>要运行此示例：</p>
<ul>
<li>克隆 <a href="https://github.com/alloy-rs/examples" title="" target="_blank">examples</a> 仓库: <code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>运行: <code>cargo run --example send_legacy_transaction</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example showing how to send a legacy transaction.

use alloy::{
    network::TransactionBuilder,
    node_bindings::Anvil,
    primitives::U256,
    providers::{Provider, ProviderBuilder},
    rpc::types::TransactionRequest,
};
use eyre::Result;

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    // Spin up a local Anvil node.
    // Ensure `anvil` is available in $PATH.
    let anvil = Anvil::new().try_spawn()?;

    // Create a provider.
    let rpc_url = anvil.endpoint().parse()?;
    let provider = ProviderBuilder::new().on_http(rpc_url);

    // Create two users, Alice and Bob.
    let alice = anvil.addresses()[0];
    let bob = anvil.addresses()[1];

    // Build a transaction to send 100 wei from Alice to Bob.
    // The `from` field is automatically filled to the first signer's address (Alice).
    let tx = TransactionRequest::default()
        .with_to(bob)
        .with_nonce(0)
        .with_value(U256::from(100))
        .with_gas_price(20_000_000_000)
        .with_gas_limit(21_000);

    // Send the transaction and wait for the broadcast.
    let pending_tx = provider.send_transaction(tx).await?;

    println!("Pending transaction... {}", pending_tx.tx_hash());

    // Wait for the transaction to be included and get the receipt.
    let receipt = pending_tx.get_receipt().await?;

    println!(
        "Transaction included in block {}",
        receipt.block_number.expect("Failed to get block number")
    );

    assert_eq!(receipt.from, alice);
    assert_eq!(receipt.to, Some(bob));

    Ok(())
}</code></pre>
<p>在 Github 上查看源代码 <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/transactions/examples/send_legacy_transaction.rs" title="" target="_blank">这里</a>。</p>
<div style="break-before: page; page-break-before: always;"></div><!-- DO NOT EDIT THIS FILE. IT IS GENERATED BY RUNNING `./scripts/update.sh` -->
<!-- ANY CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN -->
<!-- EDIT OR CREATE THIS TEMPLATE INSTEAD: ./src/templates/transactions/send_eip4844_transaction.md -->
<!-- LATEST UPDATE: https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="示例-send_eip4844_transaction-1"><a class="header" href="#示例-send_eip4844_transaction-1">示例: <code>send_eip4844_transaction</code></a></h2>
<h3 id="示例-74"><a class="header" href="#示例-74">示例</a></h3>
<p>运行此示例:</p>
<ul>
<li>克隆 <a href="https://github.com/alloy-rs/examples" title="" target="_blank">examples</a> 仓库: <code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>运行: <code>cargo run --example send_eip4844_transaction</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example showing how to send an [EIP-4844](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-4844.md) transaction.

use alloy::{
    consensus::{SidecarBuilder, SimpleCoder},
    eips::eip4844::DATA_GAS_PER_BLOB,
    network::TransactionBuilder,
    node_bindings::Anvil,
    providers::{Provider, ProviderBuilder},
    rpc::types::TransactionRequest,
};
use eyre::Result;

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    // Spin up a local Anvil node with the Cancun hardfork enabled.
    // Ensure `anvil` is available in $PATH.
    let anvil = Anvil::new().args(["--hardfork", "cancun"]).try_spawn()?;

    // Create a provider.
    let provider = ProviderBuilder::new().on_builtin(&amp;anvil.endpoint()).await?;

    // Create two users, Alice and Bob.
    let alice = anvil.addresses()[0];
    let bob = anvil.addresses()[1];

    // Create a sidecar with some data.
    let sidecar: SidecarBuilder&lt;SimpleCoder&gt; = SidecarBuilder::from_slice(b"Blobs are fun!");
    let sidecar = sidecar.build()?;

    // Build a transaction to send the sidecar from Alice to Bob.
    // The `from` field is automatically filled to the first signer's address (Alice).
    let gas_price = provider.get_gas_price().await?;
    let eip1559_est = provider.estimate_eip1559_fees(None).await?;
    let tx = TransactionRequest::default()
        .with_to(bob)
        .with_nonce(0)
        .with_max_fee_per_blob_gas(gas_price)
        .with_max_fee_per_gas(eip1559_est.max_fee_per_gas)
        .with_max_priority_fee_per_gas(eip1559_est.max_priority_fee_per_gas)
        .with_blob_sidecar(sidecar);

    // Send the transaction and wait for the broadcast.
    let pending_tx = provider.send_transaction(tx).await?;

    println!("Pending transaction... {}", pending_tx.tx_hash());

    // Wait for the transaction to be included and get the receipt.
    let receipt = pending_tx.get_receipt().await?;

    println!(
        "Transaction included in block {}",
        receipt.block_number.expect("Failed to get block number")
    );

    assert_eq!(receipt.from, alice);
    assert_eq!(receipt.to, Some(bob));
    assert_eq!(
        receipt.blob_gas_used.expect("Expected to be EIP-4844 transaction"),
        DATA_GAS_PER_BLOB as u128
    );

    Ok(())
}</code></pre>
<p>在 Github 上可以找到源码 <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/transactions/examples/send_eip4844_transaction.rs" title="" target="_blank">这里</a>。</p>
<div style="break-before: page; page-break-before: always;"></div><!-- DO NOT EDIT THIS FILE. IT IS GENERATED BY RUNNING `./scripts/update.sh` -->
<!-- ANY CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN -->
<!-- EDIT OR CREATE THIS TEMPLATE INSTEAD: ./src/templates/transactions/send_private_transaction.md -->
<!-- LATEST UPDATE: https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="示例-send_private_transaction"><a class="header" href="#示例-send_private_transaction">示例: <code>send_private_transaction</code></a></h2>
<h3 id="示例-75"><a class="header" href="#示例-75">示例</a></h3>
<p>运行此示例步骤：</p>
<ul>
<li>克隆 <a href="https://github.com/alloy-rs/examples" title="" target="_blank">examples</a> 仓库: <code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>运行: <code>cargo run --example send_private_transaction</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example of sending a private transaction using Flashbots Protect.

use alloy::{
    network::{eip2718::Encodable2718, EthereumWallet, TransactionBuilder},
    primitives::U256,
    providers::{Provider, ProviderBuilder},
    rpc::types::TransactionRequest,
    signers::local::PrivateKeySigner,
};
use eyre::Result;

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    // Set up the HTTP transport which is consumed by the RPC client.
    //
    // By default, Flashbots Protect transactions are only shared with the Flashbots Builder, which
    // builds only a subset of all Ethereum blocks. In `fast` mode, transactions are shared with
    // all registered builders no less than one block after they are received to increase the
    // number of blocks the user's transaction can be included in.
    //
    // Fast mode has 2 key differences from the default Protect experience:
    // - Shared with all builders: By default, Flashbots Protect transactions are only shared with
    //   the Flashbots Builder, which builds only a subset of all Ethereum blocks. In fast mode,
    //   transactions are shared with all registered builders no less than one block after they are
    //   received to increase the number of blocks the user's transaction can be included in.
    // - Larger refund paid to validator: By default, only 10% of MEV-Share refunds are paid to
    //   validators. In fast mode, validators receive 50% of refunds which makes it more likely that
    //   the user’s transactions will be chosen in a given block.
    //
    // For more information, see the [Flashbots documentation](https://docs.flashbots.net/flashbots-protect/overview).
    //
    // To use `fast` mode change the URL to `https://rpc.flashbots.net/fast`.
    let flashbots_url = "https://rpc.flashbots.net".parse()?;

    // Create a provider.
    let provider = ProviderBuilder::new().on_http(flashbots_url);

    // Create a signer from a random private key.
    let signer = PrivateKeySigner::random();
    let wallet = EthereumWallet::from(signer);

    // Build a transaction to send 100 wei from Alice to Bob.
    // The `from` field is automatically filled to the first signer's address (Alice).
    let bob = PrivateKeySigner::random().address();
    let tx = TransactionRequest::default()
        .with_to(bob)
        .with_nonce(0)
        .with_chain_id(1)
        .with_value(U256::from(100))
        .with_gas_limit(21_000)
        .with_max_priority_fee_per_gas(1_000_000_000)
        .with_max_fee_per_gas(20_000_000_000);

    // Build the transaction with the provided wallet. Flashbots Protect requires the transaction to
    // be signed locally and send using `eth_sendRawTransaction`.
    let tx_envelope = tx.build(&amp;wallet).await?;

    // Encode the transaction using EIP-2718 encoding.
    let tx_encoded = tx_envelope.encoded_2718();

    // Send the raw transaction. The transaction is sent to the Flashbots relay and, if valid, will
    // be included in a block by a Flashbots builder. Note that the transaction request, as defined,
    // is invalid and will not be included in the blockchain.
    let pending = provider.send_raw_transaction(&amp;tx_encoded).await?.register().await?;

    println!("Sent transaction: {}", pending.tx_hash());

    Ok(())
}</code></pre>
<p>在 Github 上找到源代码 <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/transactions/examples/send_private_transaction.rs" title="" target="_blank">here</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="钱包"><a class="header" href="#钱包">钱包</a></h2>
<ul>
<li><a href="examples/wallets/aws_signer.html">AWS 签名器</a></li>
<li><a href="examples/wallets/ledger_signer.html">Ledger 签名器</a></li>
<li><a href="examples/wallets/private_key_signer.html">私钥签名器</a></li>
<li><a href="examples/wallets/mnemonic_signer.html">助记词签名器</a></li>
<li><a href="examples/wallets/sign_message.html">签名消息</a></li>
<li><a href="examples/wallets/verify_message.html">验证消息</a></li>
<li><a href="examples/wallets/sign_permit_hash.html">签名许可哈希</a></li>
<li><a href="examples/wallets/trezor_signer.html">Trezor 签名器</a></li>
<li><a href="examples/wallets/yubi_signer.html">Yubi 签名器</a></li>
<li><a href="examples/wallets/keystore_signer.html">密钥库签名器</a></li>
<li><a href="examples/wallets/create_keystore.html">创建密钥库</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><!-- DO NOT EDIT THIS FILE. IT IS GENERATED BY RUNNING `./scripts/update.sh` -->
<!-- ANY CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN -->
<!-- EDIT OR CREATE THIS TEMPLATE INSTEAD: ./src/templates/wallets/aws_signer.md -->
<!-- LATEST UPDATE: https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="示例-aws_signer"><a class="header" href="#示例-aws_signer">示例: <code>aws_signer</code></a></h2>
<h3 id="示例-76"><a class="header" href="#示例-76">示例</a></h3>
<p>要运行此示例：</p>
<ul>
<li>克隆 <a href="https://github.com/alloy-rs/examples" title="" target="_blank">examples</a> 仓库：<code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>运行：<code>cargo run --example aws_signer</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example showing how to use the AWS KMS signer.

use alloy::signers::{aws::AwsSigner, Signer};
use aws_config::BehaviorVersion;
use eyre::Result;

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    let Ok(key_id) = std::env::var("AWS_KEY_ID") else {
        return Ok(());
    };

    let config = aws_config::load_defaults(BehaviorVersion::latest()).await;
    let client = aws_sdk_kms::Client::new(&amp;config);
    let signer = AwsSigner::new(client, key_id, Some(1)).await?;

    let message = "Hello, world!";
    let signature = signer.sign_message(message.as_bytes()).await?;

    assert_eq!(signature.recover_address_from_msg(message)?, signer.address());

    Ok(())
}</code></pre>
<p>在 Github 上可以找到源代码 <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/wallets/examples/aws_signer.rs" title="" target="_blank">这里</a>。</p>
<div style="break-before: page; page-break-before: always;"></div><!-- DO NOT EDIT THIS FILE. IT IS GENERATED BY RUNNING `./scripts/update.sh` -->
<!-- ANY CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN -->
<!-- EDIT OR CREATE THIS TEMPLATE INSTEAD: ./src/templates/wallets/ledger_signer.md -->
<!-- LATEST UPDATE: https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="示例ledger_signer"><a class="header" href="#示例ledger_signer">示例：<code>ledger_signer</code></a></h2>
<h3 id="示例-77"><a class="header" href="#示例-77">示例</a></h3>
<p>要运行此示例：</p>
<ul>
<li>克隆 <a href="https://github.com/alloy-rs/examples" title="" target="_blank">examples</a> 仓库：<code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>运行：<code>cargo run --example ledger_signer</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example of signing and sending a transaction using a Ledger device.

use alloy::{
    network::{EthereumWallet, TransactionBuilder},
    primitives::{address, U256},
    providers::{Provider, ProviderBuilder},
    rpc::types::TransactionRequest,
    signers::ledger::{HDPath, LedgerSigner},
};
use eyre::Result;

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    // Set up the HTTP transport which is consumed by the RPC client.
    let rpc_url = "https://eth.merkle.io".parse()?;

    // Instantiate the application by acquiring a lock on the Ledger device.
    let signer = LedgerSigner::new(HDPath::LedgerLive(0), Some(1)).await?;
    let wallet = EthereumWallet::from(signer);

    // Create a provider with the wallet.
    let provider =
        ProviderBuilder::new().with_recommended_fillers().wallet(wallet).on_http(rpc_url);

    // Build a transaction to send 100 wei from Alice to Vitalik.
    // The `from` field is automatically filled to the first signer's address (Alice).
    let vitalik = address!("d8dA6BF26964aF9D7eEd9e03E53415D37aA96045");
    let tx = TransactionRequest::default().with_to(vitalik).with_value(U256::from(100));

    // Send the transaction and wait for inclusion with 3 confirmations.
    let tx_hash =
        provider.send_transaction(tx).await?.with_required_confirmations(3).watch().await?;

    println!("Sent transaction: {tx_hash}");

    Ok(())
}</code></pre>
<p>在 Github 上可以找到源代码 <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/wallets/examples/ledger_signer.rs" title="" target="_blank">here</a>。</p>
<div style="break-before: page; page-break-before: always;"></div><!-- DO NOT EDIT THIS FILE. IT IS GENERATED BY RUNNING `./scripts/update.sh` -->
<!-- ANY CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN -->
<!-- EDIT OR CREATE THIS TEMPLATE INSTEAD: ./src/templates/wallets/private_key_signer.md -->
<!-- LATEST UPDATE: https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="示例private_key_signer"><a class="header" href="#示例private_key_signer">示例：<code>private_key_signer</code></a></h2>
<h3 id="示例-78"><a class="header" href="#示例-78">示例</a></h3>
<p>运行此示例：</p>
<ul>
<li>克隆 <a href="https://github.com/alloy-rs/examples" title="" target="_blank">examples</a> 仓库：<code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>运行：<code>cargo run --example private_key_signer</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example of using a local wallet to sign and send a transaction.

use alloy::{
    network::{EthereumWallet, TransactionBuilder},
    node_bindings::Anvil,
    primitives::{address, U256},
    providers::{Provider, ProviderBuilder},
    rpc::types::TransactionRequest,
    signers::local::PrivateKeySigner,
};
use eyre::Result;

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    // Spin up a local Anvil node.
    // Ensure `anvil` is available in $PATH.
    let anvil = Anvil::new().block_time(1).try_spawn()?;

    // Set up signer from the first default Anvil account (Alice).
    // [RISK WARNING! Writing a private key in the code file is insecure behavior.]
    // The following code is for testing only. Set up signer from private key, be aware of danger.
    // let signer: PrivateKeySigner = "&lt;PRIVATE_KEY&gt;".parse().expect("should parse private key");
    let signer: PrivateKeySigner = anvil.keys()[0].clone().into();
    let wallet = EthereumWallet::from(signer);

    // Create a provider with the wallet.
    let rpc_url = anvil.endpoint().parse()?;
    let provider =
        ProviderBuilder::new().with_recommended_fillers().wallet(wallet).on_http(rpc_url);

    // Build a transaction to send 100 wei from Alice to Vitalik.
    // The `from` field is automatically filled to the first signer's address (Alice).
    let tx = TransactionRequest::default()
        .with_to(address!("d8dA6BF26964aF9D7eEd9e03E53415D37aA96045"))
        .with_value(U256::from(100));

    // Send the transaction and wait for inclusion.
    let tx_hash = provider.send_transaction(tx).await?.watch().await?;

    println!("Sent transaction: {tx_hash}");

    Ok(())
}</code></pre>
<p>在 Github 上找到源代码 <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/wallets/examples/private_key_signer.rs" title="" target="_blank">here</a>。</p>
<div style="break-before: page; page-break-before: always;"></div><!-- DO NOT EDIT THIS FILE. IT IS GENERATED BY RUNNING `./scripts/update.sh` -->
<!-- ANY CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN -->
<!-- EDIT OR CREATE THIS TEMPLATE INSTEAD: ./src/templates/wallets/mnemonic_signer.md -->
<!-- LATEST UPDATE: https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="示例mnemonic_signer"><a class="header" href="#示例mnemonic_signer">示例：<code>mnemonic_signer</code></a></h2>
<h3 id="示例-79"><a class="header" href="#示例-79">示例</a></h3>
<p>要运行此示例：</p>
<ul>
<li>克隆 <a href="https://github.com/alloy-rs/examples" title="" target="_blank">examples</a> 仓库： <code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>运行：<code>cargo run --example mnemonic_signer</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example of using `MnemonicBuilder` to access a wallet from a mnemonic phrase.

use alloy::signers::local::{coins_bip39::English, MnemonicBuilder};
use eyre::Result;

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    let phrase = "work man father plunge mystery proud hollow address reunion sauce theory bonus";
    let index = 0u32;
    let password = "TREZOR123";

    // Access mnemonic phrase with password.
    // Child key at derivation path: m/44'/60'/0'/0/{index}.
    let wallet = MnemonicBuilder::&lt;English&gt;::default()
        .phrase(phrase)
        .index(index)?
        // Use this if your mnemonic is encrypted.
        .password(password)
        .build()?;

    println!("Wallet: {}", wallet.address());

    // Generate a random wallet (24 word phrase) at custom derivation path.
    let wallet = MnemonicBuilder::&lt;English&gt;::default()
        .word_count(24)
        .derivation_path("m/44'/60'/0'/2/1")?
        // Optionally add this if you want the generated mnemonic to be written
        // to a file `.write_to(path)`.
        .build_random()?;

    println!("Random wallet: {}", wallet.address());

    Ok(())
}</code></pre>
<p>在 Github 上查看源代码 <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/wallets/examples/mnemonic_signer.rs" title="" target="_blank">here</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><!-- DO NOT EDIT THIS FILE. IT IS GENERATED BY RUNNING `./scripts/update.sh` -->
<!-- ANY CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN -->
<!-- EDIT OR CREATE THIS TEMPLATE INSTEAD: ./src/templates/wallets/sign_message.md -->
<!-- LATEST UPDATE: https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="示例-sign_message"><a class="header" href="#示例-sign_message">示例: <code>sign_message</code></a></h2>
<h3 id="示例-80"><a class="header" href="#示例-80">示例</a></h3>
<p>要运行此示例：</p>
<ul>
<li>克隆 <a href="https://github.com/alloy-rs/examples" title="" target="_blank">examples</a> 仓库：<code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>运行：<code>cargo run --example sign_message</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example of signing a message with a signer.

use alloy::signers::{local::PrivateKeySigner, Signer};
use eyre::Result;

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    // Set up a random signer.
    let signer = PrivateKeySigner::random();

    // Optionally, the wallet's chain id can be set, in order to use EIP-155
    // replay protection with different chains.
    let signer = signer.with_chain_id(Some(1337));

    // The message to sign.
    let message = b"hello";

    // Sign the message asynchronously with the signer.
    let signature = signer.sign_message(message).await?;

    println!("Signature produced by {}: {:?}", signer.address(), signature);
    println!("Signature recovered address: {}", signature.recover_address_from_msg(&amp;message[..])?);

    Ok(())
}</code></pre>
<p>在 Github 上可以找到源码 <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/wallets/examples/sign_message.rs" title="" target="_blank">这里</a>。</p>
<div style="break-before: page; page-break-before: always;"></div><!-- DO NOT EDIT THIS FILE. IT IS GENERATED BY RUNNING `./scripts/update.sh` -->
<!-- ANY CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN -->
<!-- EDIT OR CREATE THIS TEMPLATE INSTEAD: ./src/templates/wallets/verify_message.md -->
<!-- LATEST UPDATE: https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="示例-verify_message"><a class="header" href="#示例-verify_message">示例: <code>verify_message</code></a></h2>
<h3 id="示例-81"><a class="header" href="#示例-81">示例</a></h3>
<p>要运行此示例：</p>
<ul>
<li>克隆 <a href="https://github.com/alloy-rs/examples" title="" target="_blank">examples</a> 仓库: <code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>运行: <code>cargo run --example verify_message</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example of verifying that a message was signed by the provided address.

use alloy::signers::{local::PrivateKeySigner, SignerSync};
use eyre::{Ok, Result};

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    // Instantiate a signer.
    let signer = PrivateKeySigner::random();

    // Sign a message.
    let message = "Some data";
    let signature = signer.sign_message_sync(message.as_bytes())?;

    // Recover the signer from the message.
    let recovered = signature.recover_address_from_msg(message)?;
    assert_eq!(recovered, signer.address());

    Ok(())
}</code></pre>
<p>在 Github 上可以找到源码 <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/wallets/examples/verify_message.rs" title="" target="_blank">here</a>。</p>
<div style="break-before: page; page-break-before: always;"></div><!-- DO NOT EDIT THIS FILE. IT IS GENERATED BY RUNNING `./scripts/update.sh` -->
<!-- ANY CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN -->
<!-- EDIT OR CREATE THIS TEMPLATE INSTEAD: ./src/templates/wallets/sign_permit_hash.md -->
<!-- LATEST UPDATE: https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="示例-sign_permit_hash"><a class="header" href="#示例-sign_permit_hash">示例: <code>sign_permit_hash</code></a></h2>
<h3 id="示例-82"><a class="header" href="#示例-82">示例</a></h3>
<p>要运行这个示例：</p>
<ul>
<li>克隆 <a href="https://github.com/alloy-rs/examples" title="" target="_blank">examples</a> 仓库: <code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>运行: <code>cargo run --example sign_permit_hash</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example of signing a permit hash using a wallet.

use alloy::{
    primitives::{address, keccak256, U256},
    signers::{local::PrivateKeySigner, Signer},
    sol,
    sol_types::{eip712_domain, SolStruct},
};
use eyre::Result;
use serde::Serialize;

sol! {
    #[allow(missing_docs)]
    #[derive(Serialize)]
    struct Permit {
        address owner;
        address spender;
        uint256 value;
        uint256 nonce;
        uint256 deadline;
    }
}

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    // Set up a random signer.
    let signer = PrivateKeySigner::random();

    let domain = eip712_domain! {
        name: "Uniswap V2",
        version: "1",
        chain_id: 1,
        verifying_contract: address!("B4e16d0168e52d35CaCD2c6185b44281Ec28C9Dc"),
        salt: keccak256("test"),
    };

    let permit = Permit {
        owner: signer.address(),
        spender: address!("B4e16d0168e52d35CaCD2c6185b44281Ec28C9Dc"),
        value: U256::from(100),
        nonce: U256::from(0),
        deadline: U256::from(0),
    };

    // Derive the EIP-712 signing hash.
    let hash = permit.eip712_signing_hash(&amp;domain);

    // Sign the hash asynchronously with the wallet.
    let signature = signer.sign_hash(&amp;hash).await?;

    println!(
        "Recovered address matches wallet address: {}",
        signature.recover_address_from_prehash(&amp;hash)? == signer.address()
    );

    println!("Wallet signature matches: {}", signer.sign_hash(&amp;hash).await? == signature);

    Ok(())
}</code></pre>
<p>在 Github 上查看源代码 <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/wallets/examples/sign_permit_hash.rs" title="" target="_blank">here</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><!-- DO NOT EDIT THIS FILE. IT IS GENERATED BY RUNNING `./scripts/update.sh` -->
<!-- ANY CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN -->
<!-- EDIT OR CREATE THIS TEMPLATE INSTEAD: ./src/templates/wallets/trezor_signer.md -->
<!-- LATEST UPDATE: https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="示例-trezor_signer"><a class="header" href="#示例-trezor_signer">示例: <code>trezor_signer</code></a></h2>
<h3 id="示例-83"><a class="header" href="#示例-83">示例</a></h3>
<p>要运行这个示例：</p>
<ul>
<li>克隆 <a href="https://github.com/alloy-rs/examples" title="" target="_blank">examples</a> 仓库: <code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>运行: <code>cargo run --example trezor_signer</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example of signing and sending a transaction using a Trezor device.

use alloy::{
    network::{EthereumWallet, TransactionBuilder},
    primitives::{address, U256},
    providers::{Provider, ProviderBuilder},
    rpc::types::TransactionRequest,
    signers::trezor::{HDPath, TrezorSigner},
};
use eyre::Result;

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    // Set up the HTTP transport which is consumed by the RPC client.
    let rpc_url = "https://eth.merkle.io".parse()?;

    // Instantiate the application by acquiring a lock on the Trezor device.
    let signer = TrezorSigner::new(HDPath::TrezorLive(0), Some(1)).await?;
    let wallet = EthereumWallet::from(signer);

    // Create a provider with the wallet.
    let provider =
        ProviderBuilder::new().with_recommended_fillers().wallet(wallet).on_http(rpc_url);

    // Build a transaction to send 100 wei from Alice to Vitalik.
    // The `from` field is automatically filled to the first signer's address (Alice).
    let vitalik = address!("d8dA6BF26964aF9D7eEd9e03E53415D37aA96045");
    let tx = TransactionRequest::default().with_to(vitalik).with_value(U256::from(100));

    // Send the transaction and wait for inclusion with 3 confirmations.
    let tx_hash =
        provider.send_transaction(tx).await?.with_required_confirmations(3).watch().await?;

    println!("Sent transaction: {tx_hash}");

    Ok(())
}</code></pre>
<p>在 Github 上找到源码 <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/wallets/examples/trezor_signer.rs" title="" target="_blank">这里</a>。</p>
<div style="break-before: page; page-break-before: always;"></div><!-- 不要编辑这个文件。它是通过运行 `./scripts/update.sh` 生成的 -->
<!-- 对这个文件的任何修改都会被覆盖 -->
<!-- 请编辑或创建此模板：./src/templates/wallets/yubi_signer.md -->
<!-- 最新更新： https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="示例yubi_signer"><a class="header" href="#示例yubi_signer">示例：<code>yubi_signer</code></a></h2>
<h3 id="示例-84"><a class="header" href="#示例-84">示例</a></h3>
<p>运行这个示例：</p>
<ul>
<li>克隆 <a href="https://github.com/alloy-rs/examples" title="" target="_blank">examples</a> 仓库：<code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>运行：<code>cargo run --example yubi_signer</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example of signing and sending a transaction using a Yubi device.

use alloy::{
    network::{EthereumWallet, TransactionBuilder},
    primitives::{address, U256},
    providers::{Provider, ProviderBuilder},
    rpc::types::TransactionRequest,
    signers::local::{
        yubihsm::{Connector, Credentials, UsbConfig},
        YubiSigner,
    },
};
use eyre::Result;

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    // Set up the HTTP transport which is consumed by the RPC client.
    let rpc_url = "https://eth.merkle.io".parse()?;

    // We use USB for the example, but you can connect over HTTP as well. Refer
    // to the [YubiHSM](https://docs.rs/yubihsm/0.34.0/yubihsm/) docs for more information.
    let connector = Connector::usb(&amp;UsbConfig::default());

    // Instantiate the connection to the YubiKey. Alternatively, use the
    // `from_key` method to upload a key you already have, or the `new` method
    // to generate a new keypair.
    let signer = YubiSigner::connect(connector, Credentials::default(), 0);
    let wallet = EthereumWallet::from(signer);

    // Create a provider with the wallet.
    let provider =
        ProviderBuilder::new().with_recommended_fillers().wallet(wallet).on_http(rpc_url);

    // Build a transaction to send 100 wei from Alice to Vitalik.
    // The `from` field is automatically filled to the first signer's address (Alice).
    let vitalik = address!("d8dA6BF26964aF9D7eEd9e03E53415D37aA96045");
    let tx = TransactionRequest::default().with_to(vitalik).with_value(U256::from(100));

    // Send the transaction and wait for inclusion with 3 confirmations.
    let tx_hash =
        provider.send_transaction(tx).await?.with_required_confirmations(3).watch().await?;

    println!("Sent transaction: {tx_hash}");

    Ok(())
}</code></pre>
<p>在 Github 上找到源码 <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/wallets/examples/yubi_signer.rs" title="" target="_blank">这里</a>。</p>
<div style="break-before: page; page-break-before: always;"></div><!-- 请勿编辑此文件。它是通过运行 `./scripts/update.sh` 生成的 -->
<!-- 对此文件所做的任何更改都将被覆盖 -->
<!-- 请编辑或创建这个模板文件：./src/templates/wallets/keystore_signer.md -->
<!-- 最新更新：https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="示例-keystore_signer"><a class="header" href="#示例-keystore_signer">示例: <code>keystore_signer</code></a></h2>
<h3 id="示例-85"><a class="header" href="#示例-85">示例</a></h3>
<p>要运行此示例：</p>
<ul>
<li>克隆 <a href="https://github.com/alloy-rs/examples" title="" target="_blank">examples</a> 仓库：<code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>运行：<code>cargo run --example keystore_signer</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example of using a keystore wallet to sign and send a transaction.

use alloy::{
    network::{EthereumWallet, TransactionBuilder},
    node_bindings::Anvil,
    primitives::{address, U256},
    providers::{Provider, ProviderBuilder},
    rpc::types::TransactionRequest,
    signers::local::LocalSigner,
};
use eyre::Result;
use std::{env, path::PathBuf};

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    // Spin up a local Anvil node.
    // Ensure `anvil` is available in $PATH.
    let anvil = Anvil::new().block_time(1).try_spawn()?;

    // Password to decrypt the keystore file with.
    let password = "test";

    // Set up signer using Alice's keystore file.
    // The private key belongs to Alice, the first default Anvil account.
    let keystore_file_path =
        PathBuf::from(env::var("CARGO_MANIFEST_DIR")?).join("examples/keystore/alice.json");
    let signer = LocalSigner::decrypt_keystore(keystore_file_path, password)?;
    let wallet = EthereumWallet::from(signer);

    // Create a provider with the wallet.
    let rpc_url = anvil.endpoint().parse()?;
    let provider =
        ProviderBuilder::new().with_recommended_fillers().wallet(wallet).on_http(rpc_url);

    // Build a transaction to send 100 wei from Alice to Vitalik.
    // The `from` field is automatically filled to the first signer's address (Alice).
    let vitalik = address!("d8dA6BF26964aF9D7eEd9e03E53415D37aA96045");
    let tx = TransactionRequest::default().with_to(vitalik).with_value(U256::from(100));

    // Send the transaction and wait for inclusion.
    let tx_hash = provider.send_transaction(tx).await?.watch().await?;

    println!("Sent transaction: {tx_hash}");

    Ok(())
}</code></pre>
<p>在 Github 上查找源码 <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/wallets/examples/keystore_signer.rs" title="" target="_blank">here</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><!-- 不要编辑此文件，该文件是通过运行 `./scripts/update.sh` 生成的 -->
<!-- 对此文件所做的任何更改都将被覆盖 -->
<!-- 请编辑或创建以下模板: ./src/templates/wallets/create_keystore.md -->
<!-- 最新更新: https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="示例-create_keystore"><a class="header" href="#示例-create_keystore">示例: <code>create_keystore</code></a></h2>
<h3 id="示例-86"><a class="header" href="#示例-86">示例</a></h3>
<p>要运行此示例：</p>
<ul>
<li>克隆 <a href="https://github.com/alloy-rs/examples" title="" target="_blank">examples</a> 仓库: <code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>运行: <code>cargo run --example create_keystore</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example of creating a keystore file from a private key and password, and then reading it back.

use alloy::{primitives::hex, signers::local::LocalSigner};
use eyre::Result;
use rand::thread_rng;
use std::fs::read_to_string;
use tempfile::tempdir;

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    let dir = tempdir()?;
    let mut rng = thread_rng();

    // Private key of Alice, the first default Anvil account.
    let private_key = hex!("ac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80");

    // Password to encrypt the keystore file with.
    let password = "test";

    // Create a keystore file from the private key of Alice, returning a [Wallet] instance.
    let (wallet, file_path) =
        LocalSigner::encrypt_keystore(&amp;dir, &amp;mut rng, private_key, password, None)?;

    let keystore_file_path = dir.path().join(file_path);

    println!("Wrote keystore for {} to {:?}", wallet.address(), keystore_file_path);

    // Read the keystore file back.
    let recovered_wallet = LocalSigner::decrypt_keystore(keystore_file_path.clone(), password)?;

    println!(
        "Read keystore from {:?}, recovered address: {}",
        keystore_file_path,
        recovered_wallet.address()
    );

    // Assert that the address of the original key and the recovered key are the same.
    assert_eq!(wallet.address(), recovered_wallet.address());

    // Display the contents of the keystore file.
    let keystore_contents = read_to_string(keystore_file_path)?;

    println!("Keystore file contents: {keystore_contents:?}");

    Ok(())
}</code></pre>
<p>在 Github 上可以找到源码 <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/wallets/examples/create_keystore.rs" title="" target="_blank">here</a>。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="高级"><a class="header" href="#高级">高级</a></h2>
<ul>
<li><a href="examples/advanced/any_network.html">使用 <code>AnyNetwork</code></a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><!-- 请勿编辑此文件。它是通过运行 `./scripts/update.sh` 生成的 -->
<!-- 对此文件所做的任何更改都将被覆盖 -->
<!-- 请改为编辑或创建该模板：./src/templates/advanced/any_network.md -->
<!-- 最新更新： https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620 -->
<h2 id="示例any_network"><a class="header" href="#示例any_network">示例：<code>any_network</code></a></h2>
<h3 id="示例-87"><a class="header" href="#示例-87">示例</a></h3>
<p>要运行此示例：</p>
<ul>
<li>克隆 <a href="https://github.com/alloy-rs/examples" title="" target="_blank">examples</a> 仓库：<code>git clone git@github.com:alloy-rs/examples.git</code></li>
<li>运行：<code>cargo run --example any_network</code></li>
</ul>
<pre><code class="language-rust ignore">//! Example of using `AnyNetwork` to get a type-safe representation of
//! network-specific data.
//!
//! In this example, we extract the `gasUsedForL1` and `l1BlockNumber` fields
//! of Arbitrum's transaction receipts.

use alloy::{
    network::{AnyNetwork, EthereumWallet},
    primitives::{address, Address, U128, U256, U64},
    providers::ProviderBuilder,
    signers::local::PrivateKeySigner,
    sol,
};
use eyre::Result;

// The address of the contract below deployed to Arbitrum Sepolia.
const COUNTER_CONTRACT_ADDRESS: Address = address!("d62FC4aB418580919F22E2aC3A0D93F832A95E70");

sol! {
    #[allow(missing_docs)]
    #[sol(rpc)]
    contract Counter {
        uint256 public number;

        function setNumber(uint256 newNumber) public {
            number = newNumber;
        }

        function increment() public {
            number++;
        }
    }
}

#[derive(Debug, serde::Deserialize)]
struct ArbOtherFields {
    #[serde(rename = "gasUsedForL1")]
    gas_used_for_l1: U128,
    #[serde(rename = "l1BlockNumber")]
    l1_block_number: U64,
}

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    // [RISK WARNING! Writing a private key in the code file is insecure behavior.]
    // The following code is for testing only. Set up signer from private key, be aware of danger.
    let signer: PrivateKeySigner = "&lt;PRIVATE_KEY&gt;".parse().expect("should parse private key");
    let wallet = EthereumWallet::from(signer);

    let rpc_url = "https://sepolia-rollup.arbitrum.io/rpc".parse()?;
    let provider = ProviderBuilder::new()
        .with_recommended_fillers()
        .network::&lt;AnyNetwork&gt;()
        .wallet(wallet)
        .on_http(rpc_url);

    let contract = Counter::new(COUNTER_CONTRACT_ADDRESS, &amp;provider);

    let builder = contract.setNumber(U256::from(42));
    let receipt = builder.send().await?.get_receipt().await?;

    let arb_fields: ArbOtherFields = receipt.other.deserialize_into()?;
    let l1_gas = arb_fields.gas_used_for_l1.to::&lt;u128&gt;();
    let l1_block_number = arb_fields.l1_block_number.to::&lt;u64&gt;();

    println!("Gas used for L1: {}", l1_gas);
    println!("L1 block number: {}", l1_block_number);

    Ok(())
}</code></pre>
<p>在 Github 上找到源码 <a href="https://github.com/alloy-rs/examples/tree/6ac6ececdbfb33142c128f21df07cd0e92a96620/examples/advanced/examples/any_network.rs" title="" target="_blank">here</a>。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contributing-to-alloy"><a class="header" href="#contributing-to-alloy">Contributing to Alloy</a></h1>
<p>🎈 Thanks for your help improving the project! We are so happy to have
you!</p>
<p>There are opportunities to contribute to Alloy at any level. It doesn't
matter if you are just getting started with Rust or are the most weathered
expert, we can use your help.</p>
<p><strong>No contribution is too small and all contributions are valued.</strong></p>
<p>This guide will help you get started. <strong>Do not let this guide intimidate you</strong>.
It should be considered a map to help you navigate the process.</p>
<p>The <a href="https://t.me/ethers_rs">dev channel</a> is available for any concerns not covered in this guide,
please join us!</p>
<h2 id="conduct"><a class="header" href="#conduct">Conduct</a></h2>
<p>The Alloy project adheres to the <a href="https://www.rust-lang.org/policies/code-of-conduct">Rust Code of Conduct</a>. This describes
the <em>minimum</em> behavior expected from all contributors. Instances of violations
of the Code of Conduct can be reported by contacting the project team at
<a href="mailto:james@prestwi.ch">james@prestwich</a>.</p>
<h2 id="contributing-in-issues"><a class="header" href="#contributing-in-issues">Contributing in Issues</a></h2>
<p>For any issue, there are fundamentally three ways an individual can contribute:</p>
<ol>
<li>
<p>By opening the issue for discussion: For instance, if you believe that you
have uncovered a bug in Alloy, creating a new issue in the Alloy
issue tracker is the way to report it.</p>
</li>
<li>
<p>By helping to triage the issue: This can be done by providing
supporting details (a test case that demonstrates a bug), providing
suggestions on how to address the issue, or ensuring that the issue is tagged
correctly.</p>
</li>
<li>
<p>By helping to resolve the issue: Typically this is done either in the form of
demonstrating that the issue reported is not a problem after all, or more
often, by opening a Pull Request that changes some bit of something in
Alloy in a concrete and reviewable manner.</p>
</li>
</ol>
<p><strong>Anybody can participate in any stage of contribution</strong>. We urge you to
participate in the discussion around bugs and participate in reviewing PRs.</p>
<h3 id="asking-for-general-help"><a class="header" href="#asking-for-general-help">Asking for General Help</a></h3>
<p>If you have reviewed existing documentation and still have questions or are
having problems, you can open an issue asking for help.</p>
<p>In exchange for receiving help, we ask that you contribute back a documentation
PR that helps others avoid the problems that you encountered.</p>
<h2 id="pull-requests"><a class="header" href="#pull-requests">Pull Requests</a></h2>
<p>Pull Requests are the way concrete changes are made to the code, documentation,
and dependencies in the Alloy repository.</p>
<p>Even tiny pull requests (e.g., one character pull request fixing a typo in API
documentation) are greatly appreciated. Before making a large change, it is
usually a good idea to first open an issue describing the change to solicit
feedback and guidance. This will increase the likelihood of the PR getting
merged.</p>
<p>When opening a PR <strong>please select the "Allow Edits From Maintainers" option</strong>.
Alloy maintains strict standards for code quality and style, as well as
commit signing. This option allows us to make small changes to your PR to bring
it in line with these standards. It helps us get your PR in faster, and with
less work from you.</p>
<h3 id="commits"><a class="header" href="#commits">Commits</a></h3>
<p>It is a recommended best practice to keep your changes as logically grouped as
possible within individual commits. There is no limit to the number of commits
any single Pull Request may have, and many contributors find it easier to review
changes that are split across multiple commits.</p>
<p>That said, if you have a number of commits that are "checkpoints" and don't
represent a single logical change, please squash those together.</p>
<p>Note that multiple commits often get squashed when they are landed (see the
notes about <a href="appendix/contributing.html#commit-squashing">commit squashing</a>).</p>
<h4 id="commit-message-guidelines"><a class="header" href="#commit-message-guidelines">Commit message guidelines</a></h4>
<p>Commit messages should follow the
<a href="https://www.conventionalcommits.org/en/v1.0.0/">Conventional Commits</a>
specification.</p>
<h3 id="usage"><a class="header" href="#usage">Usage</a></h3>
<p>This section lists some commonly needed commands.</p>
<p>First create a <a href="https://github.com/alloy-rs/book/fork">fork</a>.</p>
<p>Next clone your fork with the <code>--recurse-submodules</code> flag:</p>
<pre><code class="language-sh">git clone --recurse-submodules $FORK_URL
</code></pre>
<p>The book is build with <a href="https://github.com/rust-lang/mdBook"><code>mdbook</code></a>, which you can get by running <code>cargo install mdbook</code>.</p>
<p>The book requires <a href="https://github.com/jonahgoldwastaken/mdbook-external-links"><code>mdbook-external-links</code></a>: <code>cargo install mdbook-external-links</code> and <a href="https://github.com/Michael-F-Bryan/mdbook-linkcheck"><code>mdbook-linkcheck</code></a>: <code>cargo install mdbook-linkcheck</code>.</p>
<p>To see the book change live run:</p>
<pre><code class="language-sh">mdbook serve
</code></pre>
<p>To run the book with docker, run:</p>
<pre><code class="language-sh">docker run -p 3000:3000 -v `pwd`:/book peaceiris/mdbook serve
</code></pre>
<p>To perform an update of generated output inspect and run <code>./scripts/update.sh</code>.</p>
<p>To add a new section (file) to the book, add it to <code>./src/SUMMARY.md</code>.</p>
<h3 id="discuss-and-update"><a class="header" href="#discuss-and-update">Discuss and update</a></h3>
<p>You will probably get feedback or requests for changes to your Pull Request.
This is a big part of the submission process so don't be discouraged! Some
contributors may sign off on the Pull Request right away, others may have
more detailed comments or feedback. This is a necessary part of the process
in order to evaluate whether the changes are correct and necessary.</p>
<p><strong>Any community member can review a PR and you might get conflicting feedback</strong>.
Keep an eye out for comments from code owners to provide guidance on conflicting
feedback.</p>
<p><strong>Once the PR is open, do not rebase the commits</strong>. See
<a href="appendix/contributing.html#commit-squashing">Commit Squashing</a> for more details.</p>
<h3 id="commit-squashing"><a class="header" href="#commit-squashing">Commit Squashing</a></h3>
<p>In most cases, <strong>do not squash commits that you add to your Pull Request during
the review process</strong>. When the commits in your Pull Request land, they may be
squashed into one commit per logical change. Metadata will be added to the
commit message (including links to the Pull Request, links to relevant issues,
and the names of the reviewers). The commit history of your Pull Request,
however, will stay intact on the Pull Request page.</p>
<h2 id="reviewing-pull-requests"><a class="header" href="#reviewing-pull-requests">Reviewing Pull Requests</a></h2>
<p><strong>Any Alloy community member is welcome to review any pull request</strong>.</p>
<p>All Alloy contributors who choose to review and provide feedback on Pull
Requests have a responsibility to both the project and the individual making the
contribution. Reviews and feedback must be helpful, insightful, and geared
towards improving the contribution as opposed to simply blocking it. If there
are reasons why you feel the PR should not land, explain what those are. Do not
expect to be able to block a Pull Request from advancing simply because you say
"No" without giving an explanation. Be open to having your mind changed. Be open
to working with the contributor to make the Pull Request better.</p>
<p>Reviews that are dismissive or disrespectful of the contributor or any other
reviewers are strictly counter to the Code of Conduct.</p>
<p>When reviewing a Pull Request, the primary goals are for the codebase to improve
and for the person submitting the request to succeed. <strong>Even if a Pull Request
does not land, the submitters should come away from the experience feeling like
their effort was not wasted or unappreciated</strong>. Every Pull Request from a new
contributor is an opportunity to grow the community.</p>
<h3 id="review-a-bit-at-a-time"><a class="header" href="#review-a-bit-at-a-time">Review a bit at a time.</a></h3>
<p>Do not overwhelm new contributors.</p>
<p>It is tempting to micro-optimize and make everything about relative performance,
perfect grammar, or exact style matches. Do not succumb to that temptation.</p>
<p>Focus first on the most significant aspects of the change:</p>
<ol>
<li>Does this change make sense for Alloy?</li>
<li>Does this change make Alloy better, even if only incrementally?</li>
<li>Are there clear bugs or larger scale issues that need attending to?</li>
<li>Is the commit message readable and correct? If it contains a breaking change
is it clear enough?</li>
</ol>
<p>Note that only <strong>incremental</strong> improvement is needed to land a PR. This means
that the PR does not need to be perfect, only better than the status quo. Follow
up PRs may be opened to continue iterating.</p>
<p>When changes are necessary, <em>request</em> them, do not <em>demand</em> them, and <strong>do not
assume that the submitter already knows how to add a test or run a benchmark</strong>.</p>
<p>Specific performance optimization techniques, coding styles and conventions
change over time. The first impression you give to a new contributor never does.</p>
<p>Nits (requests for small changes that are not essential) are fine, but try to
avoid stalling the Pull Request. Most nits can typically be fixed by the
Alloy Collaborator landing the Pull Request but they can also be an
opportunity for the contributor to learn a bit more about the project.</p>
<p>It is always good to clearly indicate nits when you comment: e.g.
<code>Nit: change foo() to bar(). But this is not blocking.</code></p>
<p>If your comments were addressed but were not folded automatically after new
commits or if they proved to be mistaken, please, <a href="https://help.github.com/articles/managing-disruptive-comments/#hiding-a-comment">hide them</a>
with the appropriate reason to keep the conversation flow concise and relevant.</p>
<h3 id="be-aware-of-the-person-behind-the-code"><a class="header" href="#be-aware-of-the-person-behind-the-code">Be aware of the person behind the code</a></h3>
<p>Be aware that <em>how</em> you communicate requests and reviews in your feedback can
have a significant impact on the success of the Pull Request. Yes, we may land
a particular change that makes Alloy better, but the individual might just
not want to have anything to do with Alloy ever again. The goal is not just
having good code.</p>
<h3 id="abandoned-or-stalled-pull-requests"><a class="header" href="#abandoned-or-stalled-pull-requests">Abandoned or Stalled Pull Requests</a></h3>
<p>If a Pull Request appears to be abandoned or stalled, it is polite to first
check with the contributor to see if they intend to continue the work before
checking if they would mind if you took it over (especially if it just has nits
left). When doing so, it is courteous to give the original contributor credit
for the work they started (either by preserving their name and email address in
the commit log, or by using an <code>Author: </code> meta-data tag in the commit.</p>
<p><em>Adapted from the <a href="https://github.com/tokio-rs/tokio/blob/master/CONTRIBUTING.md">Tokio contributing guide</a></em>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
